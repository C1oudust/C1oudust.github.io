<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vedfolnir</title>
  <icon>https://www.gravatar.com/avatar/52fb66bdac74c922b9ce4ddd419e8656</icon>
  <subtitle>我们飞翔得越高,在那些不能飞翔的人眼中的形象越渺小</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Cloudust.coding.me/"/>
  <updated>2019-01-20T07:36:42.633Z</updated>
  <id>http://Cloudust.coding.me/</id>
  
  <author>
    <name>C1oudust</name>
    <email>amerkiousy@outlook.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>对你来说活着意味着什么？</title>
    <link href="http://Cloudust.coding.me/blog/%E5%AF%B9%E4%BD%A0%E6%9D%A5%E8%AF%B4%E6%B4%BB%E7%9D%80%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%8820190119/"/>
    <id>http://Cloudust.coding.me/blog/对你来说活着意味着什么20190119/</id>
    <published>2019-01-18T16:00:00.000Z</published>
    <updated>2019-01-20T07:36:42.633Z</updated>
    
    <content type="html"><![CDATA[<p>小说是从 P 站上一位画师那知道的，自然被这个名字所吸引。联想到少年与少女站在樱花树下的插图和带有一丝悬疑色彩的名字，不由地想：“究竟是怎样一个故事呢？”直到看完了小说，电影，和最近上映的动漫电影。</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/50960701.jpg" alt=""><br><a id="more"></a></div></p><p>电影是用插叙和倒叙来展开剧情。中年的志贺春树在母校做了老师，教导主任想起志贺学生时代是旧图书馆的图书管理员，于是便把整理旧书搬到校临时图书馆的责任就交到了志贺手上。</p><p>志贺走进阔别了多年的图书馆，恍惚中仿佛看到当年那个满脸笑容的少女从他面前一晃而过。于是时光倒流，镜头转向少年与少女相遇的那一刻，故事开始了。</p><p>而动漫采用与原作相同的开头——“同学山内樱良的告别式，是在一个和她性格完全不相称的雨天举行的”。之后志贺回忆起和樱良之间的种种，被“我”以笔触记录了下来。</p><p>本来虐心剧情我是比较逃避看多次的，不过这部影片，重点不在虐心。我从中感受到的是两个迥异的性格，因为某种催化剂产生反应，最后对彼此都带来了改变。他们在一个季节里相识，相知，分别的过程，就好像樱花的绽放与凋零，短暂而又绚烂。</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/suizou4.jpg" alt=""></div></p><p><div align="left"><br>“我听说啊，樱花会假装凋谢然后再次盛放的。假装已经凋零了，其实它们会马上长出新芽，然后沉睡起来，根本没有凋零这回事。只是为了吓吓大家藏起来罢了。然后到了温暖的季节，就再一口气长出花朵来，给大家一个惊喜。”少女如是说到。</div></p><p>面对死亡，樱良总是摆出满不在乎的令人心疼的笑容，随后独自一人时，却又不争气的流下眼泪。</p><p>我们存活于世，总会把那个真实的自我小心翼翼地隐藏起来，反而当知道自己不久于世时，也许会活的更洒脱一点吧。但人就是这样，越坚强的人，一旦受伤，就会变得愈加脆弱，于是继续掩饰，伤口却难以隐藏。</p><p>唯一的一次，是在酒店玩真心话大冒险的最后一局。在酒精的作用下，少女终于坦露出脆弱的内心：</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/suizou1.jpg" alt=""></div></p><div align="left"><p>志贺想起打开少女背包时看到的满满的药片，说：我选大冒险。<br>一直假装坚强的她遇到了那个与自己心意相通的人，从此不用将真心掩藏起来，因为终于有了一个能够呵护爱惜自己真心的人，这是一件很幸福的事情吧。然而就是这样的幸福氛围，越能体现出悲剧的色彩。</p><p>活着，对你来说意味着什么？</p><p>“活着就是和某个人心意相通吧，欣赏某个人，喜欢上他，讨厌他，和某个人在一起，手牵着手，相互拥抱，相互错过。”</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/suizou2.jpg" alt=""></div></p><p><div align="left"><br>春树和樱良之间，并不是简单的友情或爱情，而是在那之上的更加纯粹的关系。心意相通也好，为对方做出改变也好，“这些都不是偶然，也不是命运的安排，而是你做出的选择和我做出的选择，让我们遇见了彼此。我们是靠自己的意愿相遇的”。</div></p><p>村上春树曾经写到：死不是生的对立面，而是作为生的一部分永恒。<br>作者给樱良安排的结局并不是传统爱情故事那样圆满的结局，甚至连因病而死都无法做到，而是很突然地在见男主的路途中遇害了。虽然之前就有了伏笔，不过看到这里还是不免感到揪心。不过想到了这句话，感觉打破这种浪漫氛围其实也让春树被救赎的剧情得到了升华 。</p><p>樱良活着的时候，她的温暖和阳光融化了春树的自我封闭；樱良死后，她的灵魂会活在在春树心中，她的“死”将作为春树“生”的一部分永恒。所以樱良的生用什么方式结束也不再那么值得去争议，因为从那个时刻起，无论樱良用什么方式死去，她的“生”都会注定在春树身上续存。</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/suizou3.jpg" alt=""></div></p><p><div align="left"><br>“为什么你就是不喊我的名字呢？。因为春树，你一次都没喊过我的名字对吧。从认识到最后都是“你”“你”“你”的叫我，很过分耶。可是啊，你偷偷跑进医院那次，我才终于明白了，你总有一天会失去我，但我不想做你的朋友或是恋人，不想做你心中那个特别的人。不过，我憧憬着这样的你，憧憬着那个和谁都不牵扯，自己独立生活，那么坚强的你。因为我很脆弱，会让朋友和家人被我的悲伤影响，但春树，你一直都能保持自我。你真的很厉害，所以也请把这些勇气，分一点给大家吧，然后去喜欢上某个人，牵起对方的手，拥抱对方，即便心情郁闷，哪怕犹豫不决，也要和很多人交流沟通，连我的份一起。嗯，活下去。我啊，想变成像春树那样的人，想活在你身体里，不行，不能说这些陈腔滥调的话啊。对了，可能你会不喜欢，我果然…”</div></p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/suizoumain.jpg" alt=""></div></p><div align="left"><p>在电影的结尾，春树泪流满面的拿着樱良留给恭子的信去往她的婚礼现场，并说出了在樱良面前练习多次的那句话“可以做我的朋友吗”。动漫的结局则是悲剧之中多了一点浪漫，春树和恭子成为了朋友，并且一起给樱良扫墓后，相约前去樱良家。少年因为少女做出了改变，欢声笑语中，樱花飞舞，触动人心，温暖人心。</p><p>怀抱美好感情的人，只能写出拙劣的文字。庆幸看到它，感受它，思考它。有一个心意相通的人真的很美好呢，就像吃掉你的胰脏，就能活在你身体里一样。</p><p>以上。</p></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小说是从 P 站上一位画师那知道的，自然被这个名字所吸引。联想到少年与少女站在樱花树下的插图和带有一丝悬疑色彩的名字，不由地想：“究竟是怎样一个故事呢？”直到看完了小说，电影，和最近上映的动漫电影。&lt;/p&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/50960701.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://Cloudust.coding.me/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="电影" scheme="http://Cloudust.coding.me/source/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="动漫" scheme="http://Cloudust.coding.me/source/tags/%E5%8A%A8%E6%BC%AB/"/>
    
  </entry>
  
  <entry>
    <title>计算机操作系统调度算法模拟程序设计（C#）</title>
    <link href="http://Cloudust.coding.me/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A120181214/"/>
    <id>http://Cloudust.coding.me/blog/计算机操作系统调度算法模拟程序设计20181214/</id>
    <published>2018-12-13T16:00:00.000Z</published>
    <updated>2018-12-16T10:45:41.503Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a><strong>实验目的</strong></h2></blockquote><p>用 C#语言编程实现对 N 个进程采用四种进程调度算法——先来先服务算法（FCFS）、短进程优先算法（SJF）、高响应比优先调度算法(HRRN)和时间片轮转调度算法（RR）调度执行模拟。</p><a id="more"></a><blockquote><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a><strong>实验原理</strong></h2></blockquote><p>先构建每个用来标识进程的进程控制块 PCB，包括以下字段：</p><ul><li>进程标识数 id</li><li>进程优先数 priority，并规定优先数越大的进程，其优先权越高</li><li>进程到达时间 arriveTime</li><li>进程已占用 CPU 时间 serveTime</li><li>进程还需占用的 CPU 时间 needTime。当进程运行完毕时，needTime 变为 0</li><li>进程被阻塞的时间 blockTime，表示已阻塞的进程再等待 blockTime 个时间片后，将转换成就绪状态</li><li>进程状态 state</li></ul><h3 id="FCFS-算法"><a href="#FCFS-算法" class="headerlink" title="FCFS 算法"></a><strong>FCFS 算法</strong></h3><p>先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用 FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，然后投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</p><h3 id="SJ-P-F-算法"><a href="#SJ-P-F-算法" class="headerlink" title="SJ(P)F 算法"></a><strong>SJ(P)F 算法</strong></h3><p>短作业(进程)优先调度算法 SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。</p><h3 id="HRRN-算法"><a href="#HRRN-算法" class="headerlink" title="HRRN 算法"></a><strong>HRRN 算法</strong></h3><p>高响应比算法，是一种动态调整优先级的算法。HRRN 算法每次都计算作业的优先级，随着作业等待时间的变长，优先级不断的提高，所以能够得到更快的执行。<br>这个优先级可以描述为: 优先级 = (作业已等待时间 + 作业的服务时间) / 作业的服务时间<br>在本实验的代码模拟中，设定初始优先级固定，之后当进程运行一个时间片后，优先级减 3，同时就绪队列中的其他进程优先级加 1。</p><h3 id="RR-算法"><a href="#RR-算法" class="headerlink" title="RR 算法"></a><strong>RR 算法</strong></h3><p>RR 算法是使用非常广泛的一种调度算法。<br>首先将所有就绪的队列按 FCFS 策略排成一个就绪队列，然后系统设置一定的时间片，每次给队首作业分配时间片。如果此作业运行结束，即使时间片没用完，立刻从队列中去除此作业，并给下一个作业分配新的时间片；如果作业时间片用完没有运行结束，则将此作业重新加入就绪队列尾部等待调度。</p><blockquote><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a><strong>代码部分</strong></h2></blockquote><h3 id="PCB-类"><a href="#PCB-类" class="headerlink" title="PCB 类"></a><strong>PCB 类</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">using System;</div><div class="line">public class PCB</div><div class="line">&#123;</div><div class="line">    public int id &#123; get; set; &#125;</div><div class="line">    public int priority &#123; get; set; &#125;</div><div class="line">    public int cpuTime &#123; get; set; &#125;</div><div class="line">    public int blockTime &#123; get; set; &#125;</div><div class="line">    public int state &#123; get; set; &#125;</div><div class="line">    public int arriveTime &#123; get; set; &#125;</div><div class="line">    public int serveTime &#123; get; set; &#125;</div><div class="line">    public int needTime &#123; get; set; &#125;</div><div class="line">    public int finishTime &#123; get; set; &#125;</div><div class="line">    //state : 1:ready,2:running</div><div class="line">    public PCB(int id, int arriveTime, int serveTime, int state)</div><div class="line">    &#123;</div><div class="line">        this.id = id;</div><div class="line">        this.arriveTime = arriveTime;</div><div class="line">        this.serveTime = serveTime;</div><div class="line">        this.state = state;</div><div class="line">    &#125;</div><div class="line">    public PCB(int id, int arriveTime, int serveTime, int blockTime, int state)</div><div class="line">    &#123;</div><div class="line">        this.id = id;</div><div class="line">        this.arriveTime = arriveTime;</div><div class="line">        this.serveTime = serveTime;</div><div class="line">        this.blockTime = blockTime;</div><div class="line">        this.state = state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public PCB(int id, int priority, int arriveTime, int serveTime, int state, bool isD)</div><div class="line">    &#123;</div><div class="line">        this.id = id;</div><div class="line">        this.priority = priority;</div><div class="line">        this.arriveTime = arriveTime;</div><div class="line">        this.serveTime = serveTime;</div><div class="line">        this.state = state;</div><div class="line">    &#125;</div><div class="line">    public void showState()</div><div class="line">    &#123;</div><div class="line">        System.Console.WriteLine(&quot;&#123;0&#125;\t\t&#123;1&#125;\t\t&#123;2&#125;\t\t&#123;3&#125;\t\t&#123;4&#125;\t\t&#123;5&#125;&quot;, id, priority, arriveTime, needTime, serveTime, state);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    public void showState(int i)</div><div class="line">    &#123;</div><div class="line">        System.Console.WriteLine(&quot;&#123;0&#125;\t\t&#123;1&#125;\t\t&#123;2&#125;\t\t&#123;3&#125;\t\t&#123;4&#125;\t\t&#123;5&#125;\t\t&#123;6&#125;&quot;, id, priority, arriveTime, needTime, serveTime, blockTime, state);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a><strong>FCFS</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">using System;</div><div class="line">using System.Threading;</div><div class="line">using System.Collections.Generic;</div><div class="line"></div><div class="line">class FCFS</div><div class="line">&#123;</div><div class="line">    List&lt;PCB&gt; Ready = new List&lt;PCB&gt;();</div><div class="line">    static int FCFS_PRIORITY = 15;</div><div class="line">    int times;</div><div class="line">    public void Init()</div><div class="line">    &#123;</div><div class="line">        PCB a = new PCB(1, 0, 3, 1),</div><div class="line">            b = new PCB(2, 2, 6, 1),</div><div class="line">            c = new PCB(3, 4, 4, 1),</div><div class="line">            d = new PCB(4, 6, 5, 1),</div><div class="line">            e = new PCB(5, 8, 2, 1);</div><div class="line">        times = 1;</div><div class="line">        Ready.Add(e);</div><div class="line">        Ready.Add(d);</div><div class="line">        Ready.Add(c);</div><div class="line">        Ready.Add(b);</div><div class="line">        Ready.Add(a);</div><div class="line">        //对优先权priority与服务需要的时间needTime进行赋值</div><div class="line">        for (int i = 0; i &lt; Ready.Count; i++)</div><div class="line">        &#123;</div><div class="line">            Ready[i].priority = FCFS_PRIORITY - Ready[i].needTime;</div><div class="line">            Ready[i].needTime = Ready[i].serveTime;</div><div class="line">        &#125;</div><div class="line">        PCB temp = null;</div><div class="line">        //对优先权排序</div><div class="line">        for (int i = 0; i &lt; Ready.Count - 1; i++)</div><div class="line">        &#123;</div><div class="line">            for (int j = 0; j &lt; Ready.Count - i - 1; j++)</div><div class="line">            &#123;</div><div class="line">                if (Ready[j].priority &lt; Ready[j + 1].priority)</div><div class="line">                &#123;</div><div class="line">                    temp = Ready[j];</div><div class="line">                    Ready[j] = Ready[j + 1];</div><div class="line">                    Ready[j + 1] = temp;</div><div class="line">                &#125;</div><div class="line">                else if (Ready[j].priority == Ready[j + 1].priority)</div><div class="line">                &#123;</div><div class="line">                    if (Ready[j].serveTime &gt; Ready[j + 1].serveTime)</div><div class="line">                    &#123;</div><div class="line">                        temp = Ready[j];</div><div class="line">                        Ready[j] = Ready[j + 1];</div><div class="line">                        Ready[j + 1] = temp;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void Start()</div><div class="line">    &#123;</div><div class="line">        System.Console.WriteLine(&quot;先来先服务(FCFS)&quot;);</div><div class="line">        System.Console.WriteLine(&quot;进程状态标志(procState)：1：准备，2：正在运行&quot;);</div><div class="line">        System.Console.WriteLine(&quot;===================================================================================&quot;);</div><div class="line">        while (Ready != null &amp;&amp; Ready.Count &gt; 0)</div><div class="line">        &#123;</div><div class="line">            System.Console.WriteLine(&quot;Id\t     Priority\t     ArriveTime\t       NeedTime\t    ServeTime\t    State\n&quot;);</div><div class="line">            if (Ready[0] != null)</div><div class="line">            &#123;</div><div class="line">                while (Ready[0].needTime &gt; 0)</div><div class="line">                &#123;</div><div class="line">                    Ready[0].state = 2;</div><div class="line">                    // 输出单个时间片中全部进程的状态</div><div class="line">                    // foreach (var item in Ready)</div><div class="line">                    // &#123;</div><div class="line">                    //     item.showState();</div><div class="line">                    // &#125;</div><div class="line">                    // 仅输出单个时间片运行中的程序状态</div><div class="line">                    Ready[0].showState();</div><div class="line">                    System.Console.WriteLine(&quot;time:&#123;0&#125;&quot;, times);</div><div class="line">                    Thread.Sleep(1000);</div><div class="line">                    System.Console.WriteLine(&quot;-----------------------------------------------------------------------------------&quot;);</div><div class="line">                    Ready[0].needTime--;</div><div class="line">                    times++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            Ready[0].state = 0;</div><div class="line">            System.Console.WriteLine(&quot;===================================================================================&quot;);</div><div class="line">            System.Console.WriteLine(&quot;\t\t\t\t\t\t\t\t\tprocess &#123;0&#125; completed\n&quot;, Ready[0].id);</div><div class="line">            Ready.RemoveAt(0);</div><div class="line">        &#125;</div><div class="line">        System.Console.WriteLine(&quot;                 All processes have been completed,takes &#123;0&#125; times\n&quot;, times - 1);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="SJB"><a href="#SJB" class="headerlink" title="SJB"></a><strong>SJB</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">using System;</div><div class="line">using System.Threading;</div><div class="line">using System.Collections.Generic;</div><div class="line"></div><div class="line">class SJF</div><div class="line">&#123;</div><div class="line">    List&lt;PCB&gt; Ready = new List&lt;PCB&gt;();</div><div class="line">    static int SJF_PRIORITY = 15;</div><div class="line">    int times;</div><div class="line">    public void Init()</div><div class="line">    &#123;</div><div class="line">        PCB a = new PCB(1, 0, 3, 1),</div><div class="line">            b = new PCB(2, 2, 6, 1),</div><div class="line">            c = new PCB(3, 4, 4, 1),</div><div class="line">            d = new PCB(4, 6, 5, 1),</div><div class="line">            e = new PCB(5, 8, 2, 1);</div><div class="line">        times = 1;</div><div class="line">        Ready.Add(e);</div><div class="line">        Ready.Add(d);</div><div class="line">        Ready.Add(c);</div><div class="line">        Ready.Add(b);</div><div class="line">        Ready.Add(a);</div><div class="line">        //对优先权priority与服务需要的时间needTime进行赋值</div><div class="line">        for (int i = 0; i &lt; Ready.Count; i++)</div><div class="line">        &#123;</div><div class="line">            Ready[i].priority = SJF_PRIORITY - Ready[i].serveTime;</div><div class="line">            Ready[i].needTime = Ready[i].serveTime;</div><div class="line">        &#125;</div><div class="line">        PCB temp = null;</div><div class="line">        //对优先权排序</div><div class="line">        for (int i = 0; i &lt; Ready.Count - 1; i++)</div><div class="line">        &#123;</div><div class="line">            for (int j = 0; j &lt; Ready.Count - i - 1; j++)</div><div class="line">            &#123;</div><div class="line">                if (Ready[j].priority &lt; Ready[j + 1].priority)</div><div class="line">                &#123;</div><div class="line">                    temp = Ready[j];</div><div class="line">                    Ready[j] = Ready[j + 1];</div><div class="line">                    Ready[j + 1] = temp;</div><div class="line">                &#125;</div><div class="line">                else if (Ready[j].priority == Ready[j + 1].priority)</div><div class="line">                &#123;</div><div class="line">                    if (Ready[j].arriveTime &gt; Ready[j + 1].arriveTime)</div><div class="line">                    &#123;</div><div class="line">                        temp = Ready[j];</div><div class="line">                        Ready[j] = Ready[j + 1];</div><div class="line">                        Ready[j + 1] = temp;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void Start()</div><div class="line">    &#123;</div><div class="line">        System.Console.WriteLine(&quot;短作业优先(SJF)&quot;);</div><div class="line">        System.Console.WriteLine(&quot;进程状态标志(procState)：1：准备，2：正在运行&quot;);</div><div class="line">        System.Console.WriteLine(&quot;===================================================================================&quot;);</div><div class="line">        while (Ready != null &amp;&amp; Ready.Count &gt; 0)</div><div class="line">        &#123;</div><div class="line">            System.Console.WriteLine(&quot;Id\t     Priority\t     ArriveTime\t       NeedTime\t    ServeTime\t    State\n&quot;);</div><div class="line">            if (Ready[0] != null)</div><div class="line">            &#123;</div><div class="line">                while (Ready[0].needTime &gt; 0)</div><div class="line">                &#123;</div><div class="line">                    Ready[0].state = 2;</div><div class="line">                    // 输出单个时间片中全部进程的状态</div><div class="line">                    // foreach (var item in Ready)</div><div class="line">                    // &#123;</div><div class="line">                    //     item.showState();</div><div class="line">                    // &#125;</div><div class="line">                    // 仅输出单个时间片运行中的程序状态</div><div class="line">                    Ready[0].showState();</div><div class="line">                    System.Console.WriteLine(&quot;time:&#123;0&#125;&quot;, times);</div><div class="line">                    Thread.Sleep(1000);</div><div class="line">                    System.Console.WriteLine(&quot;-----------------------------------------------------------------------------------&quot;);</div><div class="line">                    Ready[0].needTime--;</div><div class="line">                    times++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            Ready[0].state = 0;</div><div class="line">            System.Console.WriteLine(&quot;===================================================================================&quot;);</div><div class="line">            System.Console.WriteLine(&quot;\t\t\t\t\t\t\t\t\tprocess &#123;0&#125; completed\n&quot;, Ready[0].id);</div><div class="line">            Ready.RemoveAt(0);</div><div class="line">        &#125;</div><div class="line">        System.Console.WriteLine(&quot;                 All processes have been completed,takes &#123;0&#125; times\n&quot;, times - 1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="HRRN"><a href="#HRRN" class="headerlink" title="HRRN"></a><strong>HRRN</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">using System;</div><div class="line">using System.Threading;</div><div class="line">using System.Collections.Generic;</div><div class="line"></div><div class="line">class HRRN</div><div class="line">&#123;</div><div class="line">    List&lt;PCB&gt; Ready = new List&lt;PCB&gt;();</div><div class="line">    int times;</div><div class="line">    public void Init()</div><div class="line">    &#123;</div><div class="line">        PCB a = new PCB(1, 2, 0, 3, 1, true),</div><div class="line">            b = new PCB(2, 10, 2, 6, 1, true),</div><div class="line">            c = new PCB(3, 5, 4, 4, 1, true),</div><div class="line">            d = new PCB(4, 3, 6, 5, 1, true),</div><div class="line">            e = new PCB(5, 8, 8, 2, 1, true);</div><div class="line">        times = 1;</div><div class="line">        Ready.Add(e);</div><div class="line">        Ready.Add(d);</div><div class="line">        Ready.Add(c);</div><div class="line">        Ready.Add(b);</div><div class="line">        Ready.Add(a);</div><div class="line">        //对服务需要的时间needTime进行赋值</div><div class="line">        for (int i = 0; i &lt; Ready.Count; i++)</div><div class="line">            Ready[i].needTime = Ready[i].serveTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void Start()</div><div class="line">    &#123;</div><div class="line">        System.Console.WriteLine(&quot;高响应比优先调度算法(HRRN)&quot;);</div><div class="line">        System.Console.WriteLine(&quot;进程状态标志(State)：1：准备，2：正在运行&quot;);</div><div class="line">        System.Console.WriteLine(&quot;===================================================================================&quot;);</div><div class="line">        while (Ready.Count &gt; 0)</div><div class="line">        &#123;</div><div class="line">            PriorityChange();</div><div class="line">            Ready[0].state = 2;</div><div class="line">            System.Console.WriteLine(&quot;Id\t     Priority\t     ArriveTime\t       NeedTime\t    ServeTime\t    State\n&quot;);</div><div class="line">            // 输出单个时间片中全部进程的状态</div><div class="line">            // foreach (var item in Ready)</div><div class="line">            // &#123;</div><div class="line">            //     item.showState(1);</div><div class="line">            // &#125;</div><div class="line">            // 仅输出单个时间片运行中的进程状态</div><div class="line">            Ready[0].showState();</div><div class="line">            Ready[0].needTime--;</div><div class="line">            Ready[0].priority -= 3;</div><div class="line">            if (Ready[0].needTime == 0)</div><div class="line">            &#123;</div><div class="line">                Ready[0].state = 0;</div><div class="line">                System.Console.WriteLine(&quot;\t\t\t\t\t\t\t\t\tprocess &#123;0&#125; completed\n&quot;, Ready[0].id);</div><div class="line">                System.Console.WriteLine(&quot;===================================================================================&quot;);</div><div class="line">                Ready.RemoveAt(0);</div><div class="line">            &#125;</div><div class="line">            for (int i = 1; i &lt; Ready.Count - 1; i++)</div><div class="line">            &#123;</div><div class="line">                Ready[i].priority++;</div><div class="line">            &#125;</div><div class="line">            Thread.Sleep(1000);</div><div class="line">            System.Console.WriteLine(&quot;-----------------------------------------------------------------------------------&quot;);</div><div class="line">            System.Console.WriteLine(&quot;time:&#123;0&#125;&quot;, times);</div><div class="line">            times++;</div><div class="line">        &#125;</div><div class="line">        System.Console.WriteLine(&quot;                 All processes have been completed,takes &#123;0&#125; times\n&quot;, times - 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void PriorityChange()</div><div class="line">    &#123;</div><div class="line">        PCB temp = null;</div><div class="line">        //对优先权排序</div><div class="line">        for (int i = 0; i &lt; Ready.Count - 1; i++)</div><div class="line">        &#123;</div><div class="line">            for (int j = 0; j &lt; Ready.Count - i - 1; j++)</div><div class="line">            &#123;</div><div class="line">                if (Ready[j].priority &lt; Ready[j + 1].priority)</div><div class="line">                &#123;</div><div class="line">                    temp = Ready[j];</div><div class="line">                    Ready[j] = Ready[j + 1];</div><div class="line">                    Ready[j + 1] = temp;</div><div class="line">                &#125;</div><div class="line">                else if (Ready[j].priority == Ready[j + 1].priority) //优先权相同则短任务优先</div><div class="line">                &#123;</div><div class="line">                    if (Ready[j].serveTime &gt; Ready[j + 1].serveTime)</div><div class="line">                    &#123;</div><div class="line">                        temp = Ready[j];</div><div class="line">                        Ready[j] = Ready[j + 1];</div><div class="line">                        Ready[j + 1] = temp;</div><div class="line">                    &#125;</div><div class="line">                    else if (Ready[j].arriveTime &gt; Ready[j + 1].arriveTime) //服务时间相同则先到优先</div><div class="line">                    &#123;</div><div class="line">                        temp = Ready[j];</div><div class="line">                        Ready[j] = Ready[j + 1];</div><div class="line">                        Ready[j + 1] = temp;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="RR"><a href="#RR" class="headerlink" title="RR"></a><strong>RR</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">using System;</div><div class="line">using System.Threading;</div><div class="line">using System.Collections.Generic;</div><div class="line"></div><div class="line">class RR</div><div class="line">&#123;</div><div class="line">    List&lt;PCB&gt; Ready = new List&lt;PCB&gt;();</div><div class="line">    List&lt;PCB&gt; Block = new List&lt;PCB&gt;();</div><div class="line">    static int RR_PRIORITY = 15;</div><div class="line">    int times;</div><div class="line">    public void Init()</div><div class="line">    &#123;</div><div class="line">        PCB a = new PCB(1, 0, 3, 1, 1),</div><div class="line">            b = new PCB(2, 2, 6, 1, 1),</div><div class="line">            c = new PCB(3, 4, 4, 1, 1),</div><div class="line">            d = new PCB(4, 6, 5, 1, 1),</div><div class="line">            e = new PCB(5, 8, 2, 1, 1);</div><div class="line">        times = 1;</div><div class="line">        Ready.Add(e);</div><div class="line">        Ready.Add(d);</div><div class="line">        Ready.Add(c);</div><div class="line">        Ready.Add(b);</div><div class="line">        Ready.Add(a);</div><div class="line">        //对优先权priority与服务需要的时间needTime进行赋值</div><div class="line">        for (int i = 0; i &lt; Ready.Count; i++)</div><div class="line">        &#123;</div><div class="line">            Ready[i].priority = RR_PRIORITY - Ready[i].needTime;</div><div class="line">            Ready[i].needTime = Ready[i].serveTime;</div><div class="line">        &#125;</div><div class="line">        PCB temp = null;</div><div class="line">        //对优先权排序</div><div class="line">        for (int i = 0; i &lt; Ready.Count - 1; i++)</div><div class="line">        &#123;</div><div class="line">            for (int j = 0; j &lt; Ready.Count - i - 1; j++)</div><div class="line">            &#123;</div><div class="line">                if (Ready[j].priority &lt; Ready[j + 1].priority)</div><div class="line">                &#123;</div><div class="line">                    temp = Ready[j];</div><div class="line">                    Ready[j] = Ready[j + 1];</div><div class="line">                    Ready[j + 1] = temp;</div><div class="line">                &#125;</div><div class="line">                else if (Ready[j].priority == Ready[j + 1].priority)</div><div class="line">                &#123;</div><div class="line">                    if (Ready[j].serveTime &gt; Ready[j + 1].serveTime)</div><div class="line">                    &#123;</div><div class="line">                        temp = Ready[j];</div><div class="line">                        Ready[j] = Ready[j + 1];</div><div class="line">                        Ready[j + 1] = temp;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void Start()</div><div class="line">    &#123;</div><div class="line">        System.Console.WriteLine(&quot;时间片轮转(RR)&quot;);</div><div class="line">        System.Console.WriteLine(&quot;进程状态标志(procState):1：准备，2：正在运行&quot;);</div><div class="line">        System.Console.WriteLine(&quot;===================================================================================&quot;);</div><div class="line">        while (Ready.Count &gt; 0 || Block.Count &gt; 0)</div><div class="line">        &#123;</div><div class="line"></div><div class="line">            if (Ready.Count &gt; 0)</div><div class="line">            &#123;</div><div class="line">                Ready[0].state = 2;</div><div class="line">                System.Console.WriteLine(&quot;Id\t     Priority\t     ArriveTime\t       NeedTime\t    ServeTime\t    blockTime\t     State\n&quot;);</div><div class="line">                // 输出单个时间片中全部进程的状态</div><div class="line">                // foreach (var item in Ready)</div><div class="line">                // &#123;</div><div class="line">                //     item.showState(1);</div><div class="line">                // &#125;</div><div class="line">                // 仅输出单个时间片运行中的进程状态</div><div class="line">                Ready[0].showState(1);</div><div class="line">                Ready[0].needTime--;</div><div class="line">                if (Ready[0].needTime == 0)</div><div class="line">                &#123;</div><div class="line">                    Ready[0].state = 0;</div><div class="line">                    System.Console.WriteLine(&quot;\t\t\t\t\t\t\t\t\tprocess &#123;0&#125; completed\n&quot;, Ready[0].id);</div><div class="line">                    System.Console.WriteLine(&quot;===================================================================================&quot;);</div><div class="line">                    Ready.RemoveAt(0);</div><div class="line">                &#125;</div><div class="line">                else</div><div class="line">                &#123;</div><div class="line">                    Block.Add(Ready[0]);</div><div class="line">                    Ready.RemoveAt(0);</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                System.Console.WriteLine(&quot;Ready list is empty!&quot;);</div><div class="line"></div><div class="line">            Thread.Sleep(1000);</div><div class="line">            if (Block.Count &gt; 0)</div><div class="line">            &#123;</div><div class="line"></div><div class="line">                Block[0].blockTime--;</div><div class="line">                if (Block[0].blockTime == 0)</div><div class="line">                &#123;</div><div class="line">                    Block[0].blockTime = 1;</div><div class="line">                    Ready.Add(Block[0]);</div><div class="line">                    Block.RemoveAt(0);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            System.Console.WriteLine(&quot;-----------------------------------------------------------------------------------&quot;);</div><div class="line">            System.Console.WriteLine(&quot;time:&#123;0&#125;&quot;, times);</div><div class="line">            times++;</div><div class="line">        &#125;</div><div class="line">        System.Console.WriteLine(&quot;                 All processes have been completed,takes &#123;0&#125; times\n&quot;, times - 1);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a><strong>实验心得</strong></h2></blockquote><p>操作系统这门课程并不是教如何使用操作系统的，而是讲操作系统内部机制的。操作系统的目标是为用户提供一个良好的界面，方便用户使用计算机，同时对内部各种软硬件资源能够进行有效地管理和分配，使整个系统能高效率得运行。操作系统主要有五大功能：处理机管理、存储器管理、设备管理、文件管理、用户接口。我们现在使用的大多是 PC 机，都是只有一块 CPU，而有时却要在计算机上运行多个程序，那么每道程序在什么时候使用 CPU，这需要合理得分配协调才行，操作系统关于处理机的分配有相应的调度算法，这些工作都由操作系统实现。</p><p>这次综合实验利用 C#语言对 4 种调度算法进行了设计和模拟实现，并充分考虑了进程在执行过程中可能发生的多种情况，更好的体现了进程的就绪态和执行态二者之间的关系以及相互的转换。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h2 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的&quot; class=&quot;headerlink&quot; title=&quot;实验目的&quot;&gt;&lt;/a&gt;&lt;strong&gt;实验目的&lt;/strong&gt;&lt;/h2&gt;&lt;/blockquote&gt;
&lt;p&gt;用 C#语言编程实现对 N 个进程采用四种进程调度算法——先来先服务算法（FCFS）、短进程优先算法（SJF）、高响应比优先调度算法(HRRN)和时间片轮转调度算法（RR）调度执行模拟。&lt;/p&gt;
    
    </summary>
    
      <category term="C#" scheme="http://Cloudust.coding.me/categories/C/"/>
    
    
      <category term="C#" scheme="http://Cloudust.coding.me/source/tags/C/"/>
    
      <category term="操作系统" scheme="http://Cloudust.coding.me/source/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>《太吾绘卷》是否能成为武侠迷期待的真正江湖？</title>
    <link href="http://Cloudust.coding.me/blog/%E3%80%8A%E5%A4%AA%E5%90%BE%E7%BB%98%E5%8D%B7%E3%80%8B%E6%98%AF%E5%90%A6%E8%83%BD%E6%88%90%E4%B8%BA%E6%AD%A6%E4%BE%A0%E8%BF%B7%E6%9C%9F%E5%BE%85%E7%9A%84%E7%9C%9F%E6%AD%A3%E6%B1%9F%E6%B9%96%EF%BC%9F20181013/"/>
    <id>http://Cloudust.coding.me/blog/《太吾绘卷》是否能成为武侠迷期待的真正江湖？20181013/</id>
    <published>2018-10-12T16:00:00.000Z</published>
    <updated>2018-11-03T05:23:56.147Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/201810TheScrollofTaiwu.png" alt=""><br></div><br><a id="more"></a><br>对于关注国产游戏的玩家来说，这段时间最火莫过于《太吾绘卷》了,我在耳闻目染后，便亲自体验了一番。这篇“测评”是我将在玩游戏中途即兴写的感受合在了一起，吐槽度比较大。下面开始正文。<br><br><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/201810WuXia_game_recent.jpg" alt="最近的几款武侠风游戏"><br></div><p>其实这段时间以武侠为卖点的国产游戏不少，前些时候的《天命奇御》，最近刚上架的《侠隐行录：困境疑云》、《御俠客》以及即将上线的《河洛群侠传》。相比之下，《太吾绘卷》没有精美的人物与场景建模，没有爽快的实时打斗，却在短短十天内完成了 40 万销量的壮举。<br>在体验过太吾后，不得不大呼过瘾。游戏虽然还在 EA 阶段，但却足够复杂。玩家需要花足够多的时间去熟悉它的诸多玩法，这也正是《太吾绘卷》的魅力所在。玩过 P 社游戏的玩家会知道，通常需要 20 小时左右的时间才能完全上手这些游戏。</p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/201810jiyi.png" alt="各种技艺"><br></div><p>正所谓开放式江湖，《太吾绘卷》在设计上下了很多功夫。数百种可供修炼的武学以及中国传统技艺——木工、炼铁、医术、纺丝等等。高深的武功往往除了天资之外，还对应着相同的心法。一位行走江湖如鱼得水的侠客仅仅靠武功还不够，更需要有诗书礼乐方面的造诣。角色的立场参照了 DND 九宫盒，从刚正到唯我，玩家可以根据喜好选择选项，惩恶扬善还是唯我独尊，从而打造出属于自己的江湖侠客。下图为解包得到的功法数据，可以看到策划相当给力。</p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/201810Gongfu_Data.png" alt="解包得到的功法数据，可以看到策划相当给力。"><br></div><p>类似于《巫师》里的广为流传的昆特牌，《太吾绘卷》也引入了一个极其有趣的休闲玩法——促织决斗，说白了就是斗蛐蛐。作者确实在这个玩法中下了很大功夫——总共做了 35 种不同的蛐蛐动画，每种 80 帧，共占游戏 300M 左右。听说作者为了给蛐蛐写介绍，几乎翻烂了《促织经》。</p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/201810ququ.png" alt=""><br></div><p><strong> 《太吾绘卷》的“成功”值得我们思考。</strong></p><p>国产游戏圈内曾一度掀起武侠游戏的热潮，从《仙剑系列》《轩辕剑》《金庸群侠传》这些老一辈的武侠 rpg 到前文所提到的现时期的武侠游戏。玩家一方面仍旧喜爱这些老游戏所创造出的武侠世界，另一方面又被这个概念过度消费，新兴的武侠游戏往往喜欢打“情怀”的旗号，实际上基本玩法还是没有太大改变。就目前而言，除了商业游戏，独立游戏依旧是武侠 rpg 的传统体系：“完成任务 → 提高属性 → 学武功心法 → 打败更强的敌人”，周而复始。而《太吾绘卷》的出现似乎让陈旧的武侠游戏环境生出了一缕新芽，这不仅仅在于其复杂的游戏系统，同样归功于太吾在 roguelike 随机性上的尝试——除了玩家，整个“江湖”中，人物的所有数据皆是随机生成。在给玩家带来新鲜感的同时，其弊端也不可不谈。随机生成的 NPC 只是一堆数据，相比以往的武侠游戏来说，他们毫无故事与感情，就如同《底特律》里尚未觉醒的仿生人。</p><p><strong> 这是《太吾绘卷》在以往武侠游戏基础上的大胆尝试，也是其最大的不足之处。</strong></p><p>我们为什么喜欢武侠类游戏？比起读武侠小说和看武侠剧，武侠类游戏能给我们更好的代入感，然后我们置身于武侠的世界，体验一幕幕难忘的瞬间。我们玩《古剑奇谭》，会被百里屠苏、风晴雪一行人的经历而感动，而《太吾绘卷》中，这些随机生成的 NPC 并不能给我们足够的代入感。有人也许会说，这是一个 Roguelike 啊，数据本身就是随机的。诚然如此，但比起操纵一堆随机复制的 NPC，我还是更喜欢跟有血有肉的 NPC 交谈，在偌大的世界中听他们各自的故事。</p><p>在游戏设计上我们可以看到制作组的野心——模拟经营，角色扮演，地图探索…《太吾绘卷》几乎囊括了这些传统武侠和文字策略类游戏的所有玩法，制作组给所有玩法都构建了一套足够复杂的系统，但每一个系统，都做的不甚完美。拿太吾村的经营来说，玩家花大量时间收集资源在村子里建造的大多数建筑，只是为了对修炼或者制造提供方便，那些建筑完全可以在很多门派里找到啊，而一位侠客获得盘缠的方法，除了随地“卖艺”，居然只能靠村子里的产业。</p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/201810TaiwuVillage.png" alt="太吾村建筑"><br></div><p>在玩法上《太吾绘卷》最终还是没能完全脱离那一套传统体系。即使你在江湖中安安稳稳的学武，娶妻生子，或者隐居太吾村，游戏界面右上方的任务就会时刻提醒你：该去打 boss 了，不打 boss 提升支持度还怎么获得更好的武功？这样你就必须去把武功的等级和心法都修炼的更好，可悲的是，《太吾绘卷》的修炼系统，依然很复杂，很“浪费”时间，至少笔者在修炼的时候，只想快点了事，完全没有感觉到它的乐趣。而修炼的结果呢？《太吾绘卷》的战斗体系，按理说应该是武侠游戏中足够重要的系统，却做的极其简陋——有人戏称其为“回合制皮影戏”，不是没有道理。但这毕竟是一个文字游戏，不能表现出实时战斗的畅快场面也无可厚非，不过笔者还是希望这种一板一眼的回合打斗能够被一个更加灵活、更能体现出武侠风格的战斗模式替代。继续说地图探索，在创建人物界面中看到可供选择出生地点时，笔者可以说对地形系统比较感兴趣，但在玩游戏的过程中却大失所望。</p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/201810qipan.png" alt="略显单调的走棋盘玩法"><br></div><p>roguelike 或者沙盒的一大特点是什么？就是探索，而《太吾绘卷》在其玩法上却只是蜻蜓点水。地图中棋盘的地形可谓比较多样，但除了在获得资源数量和经过所需时间以外，完全没有任何区别，刨去提前可以看到的随机战斗事件和奇遇事件，整个随机生成的地图大而空，没有任何交互。在游戏中要从地图上的一个地方走到门派或者城市，只能一格一格走，在多次重复进行鼠标或者键盘的按压中，玩家的耐心也被渐渐消磨殆尽。</p><p>最后再就剧情吐槽一句：“都轮回了这么多世了，义父您在哪儿啊…”</p><p>说了这么多缺点，不能否认的是这款游戏依旧很好玩，比较贴近我心目中的武侠世界。笔者喜欢武侠，执着于独立游戏，当然对《太吾绘卷》抱有很大的期待。</p><p>现阶段的太吾绘卷，跟文章题目里的“真正江湖”相比还只是尚未长成的嫩芽，唯一知道的是，这朵花也许会很大，足以成为国产游戏万花丛中最独一无二的一朵。期待太吾正式版的发布，希望《太吾绘卷》能不负期待，成为武侠迷想象中真正的“会呼吸的江湖”。</p><p>以上</p>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/201810TheScrollofTaiwu.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="测评" scheme="http://Cloudust.coding.me/categories/%E6%B5%8B%E8%AF%84/"/>
    
    
      <category term="游戏" scheme="http://Cloudust.coding.me/source/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="steam" scheme="http://Cloudust.coding.me/source/tags/steam/"/>
    
  </entry>
  
  <entry>
    <title>使用EasyX图形库编写2D游戏</title>
    <link href="http://Cloudust.coding.me/blog/%E4%BD%BF%E7%94%A8easyx%E5%9B%BE%E5%BD%A2%E5%BA%93%E7%BC%96%E5%86%992D%E6%B8%B8%E6%88%8F20180723/"/>
    <id>http://Cloudust.coding.me/blog/使用easyx图形库编写2D游戏20180723/</id>
    <published>2018-07-22T16:00:00.000Z</published>
    <updated>2018-11-03T05:25:24.892Z</updated>
    
    <content type="html"><![CDATA[<p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20187Flappy_Paper_Plane_menu.png" alt=""><br><a id="more"></a></div></p><h2 id="什么是-EasyX"><a href="#什么是-EasyX" class="headerlink" title="什么是 EasyX"></a>什么是 EasyX</h2><p>一言以蔽之，EasyX 是一个 C++ 图形库，封装了一些基本的绘图函数，可以实现在控制台窗口绘制图像，帮助 C/C++语言初学者快速上手图形编程。</p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>那么如何使用呢？<br>首先去它的<a href="https://www.easyx.cn/downloads/" target="_blank" rel="external">官网</a>下载安装包，选择对应的 VS 版本，可以看到这个库虽然年代比较久远，不过也对新版本的 VS 有所支持。<br>由于我使用的是 VS2017，所以下载最新的 2018 春分版。下载好解压，双击安装，库文件就会一键安装到你的 VS 路径里。<br>然后在项目里引用头文件 graphics.h 就可以使用了。<br>我们可以在 EasyX 官网的<a href="https://www.easyx.cn/samples/" target="_blank" rel="external">范例程序</a>里看到很多免费的小项目和例子，再结合官网的入门教程，就可以很轻松的入门了。</p><h2 id="开始设计"><a href="#开始设计" class="headerlink" title="开始设计"></a>开始设计</h2><p>这里我用它来设计一个基础的小游戏 —— Flappy Paper Plane。<br>游戏类似 Flappy Bird ,玩家控制纸飞机躲避障碍。</p><h3 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h3><p>本程序应完成以下几方面的功能：</p><ul><li><p>开始界面菜单的显示；</p></li><li><p>通过按键对玩家进行控制；</p></li><li><p>实现障碍物的自动移动；</p></li><li><p>游戏结束提示。</p></li></ul><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><ul><li>整个游戏流程放在一个 while 循环中。</li><li>通过控制图片坐标来实现玩家的上下移动和障碍物的左右移动。</li><li>程序函数模块：<ul><li>初始化游戏数据 initGame()</li><li>加载游戏所需位图 loadImages()</li><li>控制玩家移动 fly()</li><li>控制障碍物移动 thornMove()</li><li>碰撞检测 judgement()</li><li>打印图像 print()</li></ul></li></ul><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>首先创建玩家和障碍物的结构体，用结构体以便后续对游戏功能进行拓展。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thornPoint</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">int</span> y;</div><div class="line">&#125;thornPoint;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">playerPoint</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">int</span> y;</div><div class="line">&#125;playerPoint;</div></pre></td></tr></table></figure><h4 id="初始化游戏数据"><a href="#初始化游戏数据" class="headerlink" title="初始化游戏数据"></a>初始化游戏数据</h4><p>包括创建绘图窗口，初始化坐标系，初始化角色与障碍物坐标。</p><p>首先使用 initgraph 函数用来创建一个 1000x600 大小的绘图窗口。</p><p>由于图形库默认坐标原点在窗口左上角，因此将其设置为常见的平面直角坐标系以便于坐标计算。但由于将坐标系倒过来了，因此要求图片文件也是倒过来的，这样加载进绘图窗口中就是正的了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setorigin(<span class="number">0</span>, <span class="number">600</span>);</div><div class="line">setaspectratio(<span class="number">1</span>, <span class="number">-1</span>);</div></pre></td></tr></table></figure><p>接下来对玩家和障碍物坐标的初始化。完整代码段如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">initgraph(HORIZONAL, VERTICAL);   <span class="comment">// 创建绘图窗口</span></div><div class="line">setorigin(<span class="number">0</span>, <span class="number">600</span>);      <span class="comment">//设置坐标原点</span></div><div class="line">setaspectratio(<span class="number">1</span>, <span class="number">-1</span>);  <span class="comment">//设置为直角坐标系</span></div><div class="line"></div><div class="line">srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>)); <span class="comment">//初始化障碍物与玩家坐标</span></div><div class="line">thornPoint.y = <span class="number">-300</span>;</div><div class="line">thornPoint.x = <span class="number">950</span>;</div><div class="line">playerPoint.x = <span class="number">400</span>;</div><div class="line">playerPoint.y = <span class="number">300</span>;</div><div class="line">isDead = <span class="literal">false</span>;</div><div class="line">speed = <span class="number">0</span>;</div></pre></td></tr></table></figure><h4 id="加载游戏所需位图"><a href="#加载游戏所需位图" class="headerlink" title="加载游戏所需位图"></a>加载游戏所需位图</h4><p>我们需要实现一个图片的背景透明，方法之一就是使用位图的掩码图。</p><p>拿玩家的图片为例：</p><p>掩码图中想要显示的区域为黑色，想透明的区域为白色，如下：</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20187fly.png" alt=""></div></p><p>用 loadimage 函数将所有位图素材的引用保存到定义好的 IMAGE 变量中。拿玩家的位图为例,后两个参数为图片的尺寸（毫米）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IMAGE player,player_;</div><div class="line">loadimage(&amp;player, <span class="string">L"res\\fly.bmp"</span>, <span class="number">120</span>, <span class="number">46</span>);</div><div class="line">loadimage(&amp;player_, <span class="string">L"res\\flyx.bmp"</span>, <span class="number">120</span>, <span class="number">46</span>);</div></pre></td></tr></table></figure><h4 id="控制玩家与障碍物移动"><a href="#控制玩家与障碍物移动" class="headerlink" title="控制玩家与障碍物移动"></a>控制玩家与障碍物移动</h4><p>采用两个变量 isPress 和 speed 控制玩家自然下落和按键上升。<br>当没有按下按键时，此时检测 isPress 的值为 false，玩家坐标下移。<br>当按下按键时，isPress 为 true，这是给 speed 一个值，即为按下按钮时玩家上升的速度。判断速度是否为 0，不为 0 时玩家坐标上移，speed 递减直到为 0。<br>这部分代码段如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">ispress = <span class="literal">false</span>;</div><div class="line"><span class="keyword">if</span> (isPress == <span class="literal">false</span>)</div><div class="line">&#123;</div><div class="line"> playerPoint.y -= <span class="number">1</span>;<span class="comment">//下落</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (_kbhit())<span class="comment">//读取空格</span></div><div class="line">&#123;</div><div class="line">key = _getch();</div><div class="line"><span class="keyword">if</span> (key == <span class="string">' '</span>)</div><div class="line">&#123;</div><div class="line">  speed = <span class="number">40</span>;</div><div class="line">  isPress = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(;speed != <span class="number">0</span>;speed --;)</div><div class="line">&#123;</div><div class="line">    playerPoint.y += <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>控制障碍物移动：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thornPoint.x -= <span class="number">2</span>;</div></pre></td></tr></table></figure><p>使边界坐标判断，使障碍物在离开窗口最左边时回到窗口最右边，并且随机一个纵坐标值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (thornPoint.x &lt;= <span class="number">-100</span>)</div><div class="line">&#123;</div><div class="line">    thornPoint.y = -(rand() % <span class="number">250</span> +<span class="number">100</span>);</div><div class="line">    thornPoint.x = <span class="number">950</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h4><p>使用坐标是否重叠来判断碰撞。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( playerPoint.y &lt;= <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">    isDead = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (playerPoint.y &lt; thornPoint.y + <span class="number">580</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (playerPoint.x + <span class="number">120</span> == thornPoint .x+ <span class="number">50</span> || playerPoint.x == thornPoint.x + <span class="number">50</span>)</div><div class="line">       isDead = <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="将位图输出至绘图窗口"><a href="#将位图输出至绘图窗口" class="headerlink" title="将位图输出至绘图窗口"></a>将位图输出至绘图窗口</h4><p>使用 putimage 函数，拿玩家位图为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">putimage(playerPoint.x, playerPoint.y, &amp;player_, SRCAND);</div><div class="line">putimage(playerPoint.x, playerPoint.y, &amp;player, SRCPAINT);</div></pre></td></tr></table></figure><p>putimage 函数的最后一个参数为三元光栅操作码，代表屏幕颜色和图像颜色的叠加方式，SRCAND 是 AND 方式，而 SRCPAINT 是 OR 方式，大概意思就是：</p><p>白色(1)&amp;任何颜色=原颜色，黑色(0)&amp;任何颜色=黑色,黑色(0)| 任何颜色=原颜色</p><h3 id="游戏效果"><a href="#游戏效果" class="headerlink" title="游戏效果"></a>游戏效果</h3><p><img src="http://c1oudust-blog.test.upcdn.net/20187plane_gameing.png" alt=""></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><ul><li>这个项目是我在课设中做的一个相当简陋的 demo，本来想做成 3D 视角，不过因为时间关系就放弃了。当时只实现了基本功能，甚至连计分功能的没有，不过作为 EasyX 的初学者示范程序来说还是很不错的。</li><li>游戏背景来自画师 Philip Govedare，很喜欢他笔下的天空和大地。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/20187Flappy_Paper_Plane_menu.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="http://Cloudust.coding.me/categories/C/"/>
    
    
      <category term="EasyX" scheme="http://Cloudust.coding.me/source/tags/EasyX/"/>
    
  </entry>
  
  <entry>
    <title>阻止我们成功的，只有懒惰</title>
    <link href="http://Cloudust.coding.me/blog/%E9%98%BB%E6%AD%A2%E6%88%91%E4%BB%AC%E6%88%90%E5%8A%9F%E7%9A%84%EF%BC%8C%E5%8F%AA%E6%9C%89%E6%87%92%E6%83%B020180625/"/>
    <id>http://Cloudust.coding.me/blog/阻止我们成功的，只有懒惰20180625/</id>
    <published>2018-06-24T16:00:00.000Z</published>
    <updated>2018-11-03T05:26:10.134Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/2018638631998_p0_master1200.jpg" alt="id=38631998" title="流星雨 id=38631998"><br></div><br><a id="more"></a><br>在一次和舍友的聊天中，我们谈到一个现实中的朋友。<br><br>他刚上大学的时候就很活跃，当我们还在努力将同学的脸和名字对号入座的时候，他就已经在人际关系上八面玲珑了。这些体现在他日常打交道的点滴中 —— 经常去各个宿舍串门、偶尔会送一些水果或零食、私下里会主动去帮老师忙 —— 就连几个比较严厉的老师都对他赞赏有加。<br><br>我当时甚至觉得他几乎把所有的时间都花在了社交和经营关系上。而事实上我个人不太喜欢跟这种人交往，除了不擅长应对他们外，主要是因为我的交际观念在于宜精不宜多，况且我也没有大量时间去跟无论圈内还是圈外的多数人，都维持长时间的优质关系。但这并不影响我对他的佩服，佩服一个能把人脉资源转化为价值的人。<br><br>从认识他第一天起，我就能感受到他身上某种独特的人格魅力。像是对任何事都保持乐观，经常露出自信的微笑，做事果断不拖泥带水之类的话，都不足以完全概括他整个人。而对于外貌，我唯一印象深刻的就是他笑起来有两个酒窝，很甜。<br><br>一个聪明人从来不会去做没有意义的事，之后，这些人脉关系理所当然的有了用武之地。大一的时候，大多数学生处于娱乐状态，他和大四的几个学生合作创办了一家校园外卖，之后因为一些问题变卖了这份“事业”，但这便是他“创业”的开端。在大二到大三两年期间，他成功为学校做了另一个，也学校里唯一一个能直接送到宿舍的校园外卖。之后他垄断了学校的快递产业 —— 整合成统一的快递柜，极大了提高学生寄收快递的效率。他还是学校附近很多培训机构的代理，经常可以看到他活跃于各大兼职群…… 在创业过程中，他的魅力博得了女神的青睐，可以说是“事业与爱情双收”了。在朋友圈，时常能看到他饭局的照片，还带有一些激励性话语。<br><br>当舍友讨论到为什么我们成为不了他那样的人时，我插了一句：因为懒。<br><br>这句话便引起了一次思想碰撞，他们坚持认为成功不是我想的那么容易，更重要的是金钱、人脉和机会，而勤奋，只不过是满足了所有前提之后的理所当然的手段罢了，勤奋相比这些而言根本不值一提。<br><br>对成功而言，金钱、人脉、机遇的确必不可少，但我想，当一个人有这种想法时，他在这件事上的失败就已经注定了。<br><br><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/2018616317335_p0_master1200.jpg" alt="id=16317335" title="流星雨 id=16317335"><br></div><p>朋友创业的过程，在我眼里其实并没有那么的举步维艰，也没有传说中的“浸透了奋斗的泪泉, 洒遍了牺牲的血雨”，只是认准了目标，以力所能及的方式努力着。很多人喜欢用成功者的天赋或者机遇来进行自我安慰，不是因为天生智商或者后天情商上的差距，只是因为懒，懒到不敢去想自己怎么去做，懒到不愿意付出，懒到想付出立刻就有回报，懒到想不付出就能坐享其成。</p><p>还没有开始，就放弃了，实在可悲。反过来想想，成功人士之所以很少，就是因为有很多还没有做就放弃了的人，再加上做了一半放弃的人，而真正成功的不就是那些坚持到最后的人吗？ 在很多人望洋兴叹感慨自己余力不足的时候，另一些人在默默努力着，他们就是下一个成功者。</p><p>大学是人生的一个分水岭，也是一个小型社会 —— 你会见到形形色色的人。有刻苦学习然后考研走上光明仕途的人，有在人际交往中游刃有余利用人脉获取利益的人，有着迷于某个事物最后在其兴趣领域获得良好评价的人，也有放弃学习娱乐至上最后凭借关系获得权势的人。每当你想要批判别人的时候，你就要记住，这个世界上并不是人人都有你的优越条件，换句话说，你的优势并不是与生俱来的天赋，而是很多人或者是你努力的结果。</p><p>很多人把成功人士的成功看作是在极其恶劣竞争中所诞生的幸运儿，换句话说，就是换了时间、地点、人物，就不可能成功。从某种意义上来说的确如此，但他们的高估往往使他们感到恐惧，因而面对成功，理所当然地认为自己无法达到，而当有人满怀热血的想去尽力争取时，他们便不屑一顾，甚至对其冷嘲热讽。把别人与他们置于同一种境地 —— 自己无法达到的目标，面对那遥遥领先的成功者，其他人又如何达到呢？</p><p>他们并没有看到成功者努力的身影，也没用有看到成功者被像他们一样的人讽刺时的眼神，只是自以为自己看的很透 —— “那些成功者都是妖孽中的妖孽，是我们这种凡人无论怎么努力也达不到的存在，你看，我就是因为知道自己根本达不到才放弃追求成功，而进去自己的舒适区中，舒服地过着美好的每一天，难道不好吗？明知道自己没有天赋，还非要去争取的愣头青，等你失败，就会知道我现在的话都是苦口良药了” —— 他们经常这么安慰自己，并以此规劝想要为成功付出的年轻人，想让他们不思进取，让他们满足于当前暂时舒适的生活，让他们最终成为自己。</p><p>阻止我们成功的，永远都是懒惰。有很多时候我们自甘堕落，躺在床上刷一天微博或抖音，看一下午直播，通宵玩游戏。可是后来想想，为什么要花这么多宝贵的时间到这些为了消遣而诞生的东西上呢？因为我们害怕付出得不到收获，我们更喜欢轻松地达成目的，这就是人类，从古至今，人类的每一个发明不都是为了方便自己吗。而现代不需要这样了，即使足不出户，只需要一部手机，我们也能轻松获得精神愉悦感。大多数情况下，比起成功的喜悦感，人们更喜欢这些很轻松就能获得的精神愉悦感，即使他们转瞬即逝，不过并不重要，他们很乐意投入更多的时间来维持这种愉悦感。</p><p>归根结底，成功者成功的原因，不单在于勤奋，而失败者之所以失败，只是因为懒。</p>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/2018638631998_p0_master1200.jpg&quot; alt=&quot;id=38631998&quot; title=&quot;流星雨 id=38631998&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://Cloudust.coding.me/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://Cloudust.coding.me/source/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="思想" scheme="http://Cloudust.coding.me/source/tags/%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Windows10下使用Linux的另一种方式 —— WSL与其桌面环境安装</title>
    <link href="http://Cloudust.coding.me/blog/Windows10%E4%B8%8B%E4%BD%BF%E7%94%A8Linux%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%20%E2%80%94%E2%80%94%20WSL%E4%B8%8E%E5%85%B6%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%8520180509/"/>
    <id>http://Cloudust.coding.me/blog/Windows10下使用Linux的另一种方式 —— WSL与其桌面环境安装20180509/</id>
    <published>2018-05-08T16:00:00.000Z</published>
    <updated>2018-11-03T05:24:44.010Z</updated>
    
    <content type="html"><![CDATA[<p>早在 Build 2016 上，微软就介绍了处于 Beta 阶段的 Windows 下的 Linux 子系统 —— Windows Subsystem for Linux（WSL），它可以让开发者们在 Windows 10 下不需要虚拟机就可以运行 Linux 系统。</p><a id="more"></a><h3 id="Ubuntu-子系统的安装"><a href="#Ubuntu-子系统的安装" class="headerlink" title="Ubuntu 子系统的安装"></a>Ubuntu 子系统的安装</h3><p>为了体验这一功能，需要在<code>控制面板-&gt;程序和功能-&gt;启用或关闭Windows功能</code> 中 开启 WSL 服务，如图所示：</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185OpenWSLService.png" alt=""></div></p><p>也可以通过在 PowerShell(管理员) 运行以下命令开启开启</p><p><code>Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</code></p><p>之后在设置里开启开发人员模式</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185developerMode.png" alt=""></div></p><p>然后在 Windows 的应用商店里就能只能下载想要体验的 Linux 子系统了。可以看到它提供了很多类型的 Linux 系统，这里就选择我最喜欢的 Ubuntu Linux 来做演示。</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185WSLwindowstore.png" alt=""></div></p><p>等待安装完成后，点击开始菜单里的 Ubuntu 图标或者在 powershell 里输入<code>bash</code>即可启动 Ubuntu Linux 子系统。等待了几分钟的初始化之后，我们输入用户名和密码（可以跳过），然后就能看到 Ubuntu 的命令行界面了.</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185ubuntuOnWindows.png" alt=""></div></p><p>在刚安装好 WSL 后，与普通实体机上的 Ubuntu 系统一样，需要更新软件列表和软件包：<br><code>sudo apt update</code><br><code>sudo apt upgrade</code></p><p>这样就可以像使用普通 Ubuntu 系统一样使用 WSL 了。</p><h3 id="桌面环境的安装与启动"><a href="#桌面环境的安装与启动" class="headerlink" title="桌面环境的安装与启动"></a>桌面环境的安装与启动</h3><p>WSL 的方便之处就在于它和双系统的 Linux 没有很大区别，并且比虚拟机性能更快一点。美中不足的是，WSL 并没有自带图形化界面，因此如果想要运行桌面应用，就不禁徒叹奈何了。<br>不过在 WSL 推出不久，就有大神提供了 WSL 安装桌面环境的方法，并发到了 WSL github 的 issues 里：<a href="http://t.cn/R3AWMQo" target="_blank" rel="external">Run any Desktop Environment in WSL</a></p><p>根据这个教程，我们就可以在 WSL 里安装桌面环境以获得比较完整的体验。</p><ul><li><p><strong>安装 X-Windows</strong></p><p>可供选择安装的 X-Windows 有多个：VcXsrv Windows X Server、Xming、Cygwin X Server，教程中选择的是 VcXsrv，因为比较容易和稳定。</p><p>软件首页：<br><a href="https://sourceforge.net/projects/vcxsrv/" target="_blank" rel="external">https://sourceforge.net/projects/vcxsrv/</a></p><p>下载地址：<br><a href="https://ncu.dl.sourceforge.net/project/vcxsrv/vcxsrv/1.19.3.3/vcxsrv-64.1.19.3.3.installer.exe" target="_blank" rel="external">https://ncu.dl.sourceforge.net/project/vcxsrv/vcxsrv/1.19.3.3/vcxsrv-64.1.19.3.3.installer.exe</a></p><p>安装后首次启动会自动进入界面设置。</p><p>选择：“one large window”，Display number 设置成 0，其它默认：</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185Xwindow.png" alt=""></div></p></li><li><p><strong>WSL 安装桌面环境</strong></p><p>这里选择安装 unity 桌面环境，我们同样可以选择 xfce4 桌面环境。</p><p>在 bash 下执行 <code>sudo apt-get install ubuntu-desktop unity compizconfig-settings-manager</code></p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185installdesktop.png" alt=""></div></p><p>需要提醒的是，Ubuntu 桌面版自带的 unity 桌面环境与依赖包有 600 多 M，解压之后近 2.6G，所以前提需要保证足够的磁盘空间。</p></li><li><p><strong>配置 compiz 并运行桌面环境</strong></p><p>启动 X-Windows，在 Bash 中执行：</p><p><code>export DISPLAY=localhost:0</code></p><p><code>ccsm</code></p><p>在 X-windows 中，即会弹出 ccsm 的配置界面，勾选需要的 Desktop 组件（只需要勾选 Desktop 中的 Ubuntu Unity Plugin 即可，其它默认）：</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185ccsm.png" alt=""></div></p><p>点击 close 关闭 ccsm，执行 compiz，短暂的加载后，在 X-windows 的界面中就能看到桌面版的 Ubuntu 了。</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185compiz.png" alt=""><br><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185UbuntuDesktoponWSL.png" alt=""></div></div></p></li></ul><h3 id="其他推荐"><a href="#其他推荐" class="headerlink" title="其他推荐"></a>其他推荐</h3><p>关于 WSL 的玩法有很多，可以参照：<a href="http://t.cn/RtbzH6h" target="_blank" rel="external">玩转 Windows 10 中的 Linux 子系统</a> 和 <a href="http://t.cn/RTsqoVJ" target="_blank" rel="external">Windows10 内置 Linux 子系统初体验</a></p><p>这里推荐一个软件 —— <a href="https://goreliu.github.io/wsl-terminal/README.zh_CN.html" target="_blank" rel="external">wsl-terminal</a>，用于 WSL 的终端模拟器，基于 mintty 和 wslbridge。github 上有很全的中文文档，添加了很多实用功能，可以利用终端做更多很酷很有趣的事~</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185cmatrix.gif" alt=""></div></p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185w3cbaidu.png" alt=""></div></p><p>自此，开始折腾自己的 Linux 吧~</p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早在 Build 2016 上，微软就介绍了处于 Beta 阶段的 Windows 下的 Linux 子系统 —— Windows Subsystem for Linux（WSL），它可以让开发者们在 Windows 10 下不需要虚拟机就可以运行 Linux 系统。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://Cloudust.coding.me/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="http://Cloudust.coding.me/source/tags/Ubuntu/"/>
    
      <category term="Windows" scheme="http://Cloudust.coding.me/source/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>腾讯没梦想，自媒体有春梦</title>
    <link href="http://Cloudust.coding.me/blog/%E8%85%BE%E8%AE%AF%E6%B2%A1%E6%A2%A6%E6%83%B3%EF%BC%8C%E8%87%AA%E5%AA%92%E4%BD%93%E6%9C%89%E6%98%A5%E6%A2%A620180509/"/>
    <id>http://Cloudust.coding.me/blog/腾讯没梦想，自媒体有春梦20180509/</id>
    <published>2018-05-08T16:00:00.000Z</published>
    <updated>2018-11-03T05:26:03.115Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185mmexport1525840185248.jpg" alt=""><br></div><a id="more"></a><blockquote><p>这是一个辜负了曾经那些认真的文字工作者的疯狂流量时代，这是一个读者平均阅读水平 low 穿地球的时代，写爆文成了考量自媒体水平的最大标准，于是就不管文章观点是否客观，不管论述是否符合逻辑，只管大把写，然后大把捞钱。这些自媒体人现在看到了商机，一个个都摇身一变成了天才，自己是个太监没有阴茎就能教你性交，自己考不上清华北大就能教你高效学习法，自己没法成功就能教你成功，自己没法自律就能教你自律，自己写的东西像狗屎一样就能教你写作，自己没有大公司的管理经验能教几千亿市值公司的老板怎么开公司。</p></blockquote><p>&emsp; &emsp; &emsp;&emsp; &emsp; &emsp;&emsp; &emsp; &emsp;&emsp; &emsp; &emsp;&emsp; &emsp; &emsp;&emsp; &emsp; &emsp;&emsp; &emsp; &emsp;&emsp; &emsp; &emsp;——语出俄罗斯著名作家，诺贝尔文学奖获得者沃兹基·硕德</p><p>因为一篇阅读量百万+的批评腾讯的雄文，这两天科技圈已然完全炸掉了，所有大佬和互联网人士都在讨论腾讯到底有没有梦想……</p><p>首先刷屏的原文是这个:<br><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDczODM3Mw==&amp;mid=2653028142&amp;idx=1&amp;sn=0dd174c676138016803af3d9ac77e919&amp;scene=21#wechat_redirect" target="_blank" rel="external">《腾讯没有梦想》</a></p><p>然后因此冒出了无数反驳的文章，比如：</p><p>《驳腾讯没有梦想》</p><p>《谁说腾讯没有梦想？》</p><p>《讨论“腾讯的梦想”是个伪命题》</p><p>《腾讯需要有梦想吗》</p><p>《讨论腾讯有没有梦想，不是大课是唠嗑》</p><p>《难以让人信服的“腾讯没有梦想”》</p><p>《腾讯没有梦想？只是你不希望 ta 有罢了》</p><p>……</p><p>不知道大家看到这么多七七八八的标题的时候，是什么感受，反正我觉得有点辣眼睛……</p><p>总之我当时的关注点，并不是这篇文章到底说的对不对，而是觉得非常有趣，<strong>因为这算是一个非常成功的传播学案例。</strong></p><p>这篇文章作者作为一个资深编辑，深谙写出传播能力广文章的诀窍，其行文手法之高明，令人叹服，所以这篇文章就是来分析这位编辑的“高明”手法的。至于他写的到底正确与否，嘿嘿。</p><h3 id="用极端和奇葩的观点博人眼球"><a href="#用极端和奇葩的观点博人眼球" class="headerlink" title="用极端和奇葩的观点博人眼球"></a>用极端和奇葩的观点博人眼球</h3><p>这篇文章的标题就是这样，《腾讯没有梦想》这六个字，观点<strong>非常极端，博人眼球</strong>，我相信大部分人在朋友圈看到这样的标题，都会去点开。</p><p>越极端的观点越能吸引人，这是一个被媒体人玩烂了的道理，相关的案例随手拈来，例如几个小时前罗永浩发了篇微博，声称“<strong>5 月 15 号（锤子发布会）之后失去灵魂的苹果将会疯狂的抄袭我们。”</strong>：</p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185mmexport1525840189719.jpg" alt=""><br></div><p>是个人都能看出，没有人会相信罗永浩的这么一套言论，罗永浩是在用奇葩的观点吸引眼球，就算转发他微博和观点的人全部都是在骂他，<strong>他的目的仍然达到了——为了给锤子发布会造势吸引流量。</strong></p><p>罗永浩并不是第一次使用这样的技巧，前两年罗永浩就说过自己以后会收购“必将衰落的苹果”，有网友认为这种手段很低劣，但事实却证明每次都非常的奏效，尴尬的是，在吐槽罗永浩的同时，这篇文章也同样陷入了罗永浩想要吸引流量的圈套。</p><h3 id="用废话式的论述和结论，来显得自己很有道理"><a href="#用废话式的论述和结论，来显得自己很有道理" class="headerlink" title="用废话式的论述和结论，来显得自己很有道理"></a>用废话式的论述和结论，来显得自己很有道理</h3><p>文中似乎下了很多结论性的东西，乍一看还非常有道理的样子，包括但不限于以下几句：</p><blockquote><p>“市场还有机会，但机会不一定再属于腾讯。”</p><p>“腾讯内部的数据并不互通，腾讯内部各部门的冲突和分化导致腾讯在整体上无法形成统一而强有力的战略和执行”。</p><p>“原本的确定性红利吃完了，腾讯的优势就不一定是绝对垄断性的了。 ”</p></blockquote><p>上面分别引用了文中的三处内容，发现什么共同特征没有？</p><p>这些经过一番论述后产生的结论性的句子，初看起来都宛如箴言一般，鞭辟入里，一副极为有道理的样子。</p><p>但仔细思考你就会发现，这其实都是废话。</p><p>第一句，套在任何公司上都不违和……谁都知道市场上还有机会，谁都知道机会不一定属于自己公司……</p><p>第二句，这很明显是大公司的通病，直到现在也没人能拿出解决方案，潘乱把大公司的通病写出来是想做什么，自己能拿出解决方案吗？方案呢？不过一个写自媒体的编辑，就想解决那么多大企业的管理人才都解决不了的事情吗？只能说勇气可嘉，天真烂漫。</p><p>第三句也很明显是废话，因为对于未来发生的事情，这世上几乎就没有多少真正一定的事情。即便是明天早上太阳会不会升起，也没人敢说一定，因为万一小行星撞地球世界毁灭了呢？更何况是一个公司未来的发展呢。</p><p>这种废话型的结论，看似愚蠢，但实则杀伤力很强，很多鸡汤也运用了类似的语言技巧，因为大家通读下来找不到这些结论的毛病，很多思考能力不强的人就觉得说的非常正确，很有道理什么的，但仔细想想就会发现说的都是一些不痛不痒、毫无营养的废话。</p><h3 id="以偏概全与错误归因"><a href="#以偏概全与错误归因" class="headerlink" title="以偏概全与错误归因"></a>以偏概全与错误归因</h3><p>什么叫错误归因呢？</p><p>还是举文中的例子。作者把王者荣耀没有成功出海，和绝地求生手游版在海外的成功做对比，论证出了王者荣耀开发的时候，因为没有考虑版本全球化所以才会出海失败，而绝地求生手游因为考虑了版本全球化所以才成功。</p><p>这就犯了错误归因的错误，是个人都知道，绝地求生是一个早就在全球非常火的电脑端网游了，腾讯拿到绝地求生的正版授权后，做出来的手游只要不太差，在国外一定会大火，和什么版本全球化关系很小。为什么，因为电脑版玩家的受众明明白白的摆在那了啊！而王者荣耀不同，本身就是一个本土化的游戏，出海困难很正常啊，这怎么能类比呢？</p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185PUBG.jpg" alt=""><br></div><p>至于以偏概全的例子就太多了。例如，是个人都知道，腾讯在游戏这一块，尤其是手游，对于中国的其他企业几乎是碾压级别的优势，其他的企业……几乎一个能打的都没有……</p><p>但是你要搞清楚，作者可是想证明“腾讯没有梦想”啊！怎么能容忍腾讯这种霸主级别的碾压呢！要知道，腾讯可是一个没有梦想的公司啊！</p><p>但这位作者实在是在腾讯的游戏领域挑不出几个毛病了，于是开始春秋笔法了：</p><blockquote><p>对手游来说，玩家成长速度消耗速度都很快，流量转化的难度在逐渐变大。最初用户没得玩，腾讯推什么用户就玩什么，比如天天系列的大众休闲游戏，靠微信和应用宝导量就能轻易横扫市场；再后来用户的需求更深度，腾讯就推一些好的游戏， 比如王者荣耀和飞车炫舞，靠的也还是端游 IP 和端游玩法的移植；到如今，用户更垂直，审美更多元，玩家对游戏的需求更多样化个性化，对于《恋与制作人》、《旅行青蛙》这样的针对特定人群的特色游戏，腾讯一时有些使不上力气。</p></blockquote><p>这段文字，光前面的论述，就有一种“虽然你很牛逼，但是你没什么了不起，不过是你走运罢了”的酸臭感，最后看到“腾讯一时有些使不上力气”这句话的时候，我甚至差点笑出声，看来作者实在是觉得，光是靠以偏概全的两个游戏《恋与制作人》，《旅行青蛙》（居然这个也被作者拿来凑数，心疼旅行青蛙），确实难以得出腾讯游戏药丸的结论，所以就语焉不详的写了这句话……</p><p>还有，作者在文中对于腾讯做信息流败给今日头条这件事，着墨很多，想通过腾讯这样的失败证明腾讯没有梦想。<strong>这也犯了以偏概全的错误。</strong></p><p>每个公司都有成功的产品，也有失败的产品，和小公司不同，对于大公司来讲，个别产品的失败其实并不重要，他们拥有很多试错的机会，只要十个产品里面能成一个，那就算是巨大的成功了。</p><p>且不论腾讯除了信息流之外还有多少成功的产品，就算只比信息流，也完全得不出“腾讯没有梦想”来，因为，做信息流和短视频最成功的就只有今日头条+旗下的抖音了，快手也算一个，那么我们岂不是要说除了今日头条和快手之外所有做信息流的公司都没有梦想呢？</p><p>要知道，抖音这款 app 火了，影响最大的可是微博，对于微信影响很小，根本就不是一个竞品，有人会因为玩抖音不上微博，没有人会因为玩抖音不聊天吧？建议作者再写几篇《新浪没有梦想》，《网易没有梦想》，《小米没有梦想》。</p><h3 id="用含混的定义来混淆逻辑"><a href="#用含混的定义来混淆逻辑" class="headerlink" title="用含混的定义来混淆逻辑"></a>用含混的定义来混淆逻辑</h3><p>我觉得人人都应该学一点数学，学完之后至少学会了用定义式思维思考问题，这样思考的话，你会发现有些概念根本就是模糊不清的，</p><p>正如汪峰经常问的问题：“你的梦想是什么？”一样，文中的作者说的“梦想”到底是个什么东西？是创新？是好口碑？还是市值增长？作者并没有给出明确的定义，这就给了作者很大的混淆空间。</p><p>那时候大家都很羡慕海外的创投环境，因为当时美国的大公司非常喜欢收购小公司，这让市场充满了新鲜的活力，而彼时的腾讯总是被喷抄袭，所以创业者都要面临一个问题：“如果你做的东西，腾讯也做了怎么办？”毫无疑问，这一定是毁灭性的。</p><p>而后来腾讯从良了，不抄了，现在开始像国外的巨头一样投资小公司了，你以为这就能挡住大神的口水攻击了吗？<strong>并不能，大神会说你没有梦想……</strong></p><p><strong>如果这样叫没有梦想，那我宁愿腾讯天天没有梦想，日日没有梦想才好。</strong></p><h3 id="总结：批评的姿势"><a href="#总结：批评的姿势" class="headerlink" title="总结：批评的姿势"></a>总结：批评的姿势</h3><p>总的来说，这篇作者在干的事情就是：</p><p><strong>以一个写自媒体的编辑的身份</strong>，以一个没有任何巨头公司的任何管理经验的身份，以一个对腾讯真正的内部战略和公司形势并不知情的身份，仅靠一篇文章，就站在一个类似于洞察者一般至高无上的角度，<strong>对一个如日中天、市值几千亿美金的大公司，对一个随便拉出一个高管，才能都远超自己的公司</strong>，各种横加批评和各种否定其战略和模式，不知道是哪里来的自信和勇气？</p><p>先操心下自己的房贷能不能还上，操心下自己儿子小学入学的问题，再来考虑一个几千亿美金市值的大公司的宏观战略部署好吧？</p><p>赚着互联网民工的钱，操着市值几千亿美金公司老总的心。</p><p>这篇文章让我想到了知乎的一个问题，当时 alphago 下围棋完胜李世石，引起世界轰动后，高晓松评论道：</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185gxs1.jpg" alt=""><br><img src="http://c1oudust-blog.test.upcdn.net/20185gxs2.jpg" alt=""><br><img src="http://c1oudust-blog.test.upcdn.net/20185gxs3.jpg" alt=""><br></div></p><p><div align="center"><br>嗯……高晓松说alphago下棋没有美感……没有美感……</div></p><p><div align="center"><br>对此，知乎上答主@伯张的老爷写出了犀利无比的答案…..</div></p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185bzdly.jpg" alt=""></div></p><p>套用在这里就是：</p><p>“那如果当真是所向披靡的公司，上市之后市值暴涨几百倍呢？”</p><p>潘乱沉吟半晌。</p><p>“那，就说他没有梦想。”</p><p><div align="left"><br>以上。</div></p><hr><p>文章转载自：<a href="http://t.cn/R3Zej8q" target="_blank" rel="external">逆鳞先生</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/20185mmexport1525840185248.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://Cloudust.coding.me/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://Cloudust.coding.me/source/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="互联网" scheme="http://Cloudust.coding.me/source/tags/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>《救赎之路》到底救赎了谁？</title>
    <link href="http://Cloudust.coding.me/blog/%E3%80%8A%E6%95%91%E8%B5%8E%E4%B9%8B%E8%B7%AF%E3%80%8B%E5%88%B0%E5%BA%95%E6%95%91%E8%B5%8E%E4%BA%86%E8%B0%81%EF%BC%9F20180429/"/>
    <id>http://Cloudust.coding.me/blog/《救赎之路》到底救赎了谁？20180429/</id>
    <published>2018-04-28T16:00:00.000Z</published>
    <updated>2018-11-03T05:24:18.742Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20184sinner.jpg" alt=""><br></div><br><a id="more"></a><br>早些时间在B站看到过这个游戏的试玩视频，当时的第一反应：哎呦，不错啊，这是国产？<br><br>时至今日，当我手动通关了这个游戏之后的第一反应是这样的：<br><br><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20184emmmm.jpg" alt=""><br></div><p>一言难尽。</p><p>我不会说游戏与黑魂到底有多么相似，因为一个独立游戏从质量上来说，无论是画面还是战斗都自然无法和 3A 大作相比较。</p><p>《救赎之路》砍掉了普通角色扮演游戏中的一系列流程，这可能是制作组开始游戏企划时一个比较艰难的决定。想做一款类魂游戏，但在时间和经历上不是很允许或者根本无法达到，因此只能放弃很多元素，只把游戏体验放到了魂系列的一个核心点——挑战难度极大的 boss 战上。其实这也无可厚非，只要能在 boss 战上做到比较好的效果，那它也能算是一款不错的独立游戏。</p><p>那么，《救赎之路》的 boss 战模式设计成功了吗？我的答案是：基本成功了。</p><ul><li><p>在游戏中，每个 boss 无论是形态还是攻击方式，都比较贴合其对应的那一宗罪。而其攻击方式的变化也是比较多的，大部分 boss 都有两种形态，也算是把难度提升了一大截。再来开看主角的攻击方式：主角有在游戏开始有两种武器，大剑和剑盾，剑盾攻击不高，好在比较灵敏的攻击速度，而大剑是我比较喜欢的武器，尤其是攻击到敌人后那个比较明显的停顿，有种刀刀入骨感觉，从战斗的手感来说已经是比较优秀了。</p></li><li><p>boss 所在的场景是游戏中一个比较出彩的地方，得益于强大的虚幻 4 引擎的表现和制作组用心的设计，每个场景都十分有特色。个人比较喜欢色欲和傲慢以及暴怒所在的场景。</p></li></ul><p>就色欲而言，茭白的月光倒映在镜面般的湖泊中，加上四周生长的银色藤蔓，整个场景有种静谧诡异的魔法气息。</p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20184Lust.png" alt="露纳之湖" title="露纳之湖"><br></div><p>而傲慢所在的场景，周围的断垣残壁与高高的石柱，和身材高大的 boss 交相呼应，则显得十分壮阔大气。</p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20184Pride.png" alt="失落荣耀竞技场" title="失落荣耀竞技场"><br></div><p>同样，在充满熔岩的火焰长廊尽头，身材巨大的暴怒从岩浆中缓缓出现，给人以一种压抑与兴奋并存的感觉。</p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20184Wrath.png" alt="折磨深渊" title="折磨深渊"><br></div><ul><li>游戏独特的创新处 —— Level-Down 系统。每挑战一个 boss 时，主角都会进行献祭，根据所挑战 boss 的不同，主角被减弱的能力就各有不同，这是体现游戏难度的另一个要素。而哟西本身并没有规定打 boss 的顺序，这样玩家就能自行选择，并在能力削弱上达成比较合理的安排。但这个设计在影响游戏难度上的变化不够明显。游戏是难，但只能说是个别 boss 难，而不是越来越难，因为对于一个“抖 M”玩家来说，通常只要摸清 boss 的攻击模式，击败 boss 就是套路级别的事了。而被削弱的各项能力，对于击败 boss 来说影响也不是很大，因此个人认为，Level-Down 系统的设计虽然新颖，但创新力度还是不够。</li></ul><p>以上是《救赎之路》的一些优点，而游戏本身还是有一些瑕疵的，不过它们并不是很影响游戏本身的体验：</p><ul><li><p>BGM 的缺乏。音效部分可以说是《救赎之路》最大的短板之一，无论是攻击，行走，还是背景音乐，在游戏中都没有过多的表现。背景音乐？不存在的，貌似嫉妒的场景是有 BGM 的==，当然一个独立游戏制作组想要请专业的团队制作配乐，毫无疑问代价太大了，所以 bgm 的缺乏完全能够理解。</p></li><li><p>未锁定 boss 时的镜头依然不能自由转动视角，也就是所谓的锁镜头方式。不过好在游戏只有 boss，因此个人倒是没有什么可吐槽的，如果是一个杂兵多而场景大的游戏，用锁镜头那真是要狠狠地吐槽一顿了。</p></li><li><p>弹反的时机把控要十分精准才能完成，这个机制的设计基本都是聊胜于无了，个人感觉，因为有了翻滚，用到弹反的地方还是很少的。喜欢弹反的朋友可以试试能否弹反 boss 的攻击。</p></li><li><p>武器种类并不是很多，而通关主线会给一把暴食的双剑，通关三周目又能获得一把镰刀。目前个本人也就仅仅通关了一周目，而且没有继续通关二周目和打挑战模式的想法。</p></li></ul><p>以下是一些吐槽：</p><ul><li><p>主角最后的剧情并没有看懂，意思是最后救赎了自己然后获得了王位？</p></li><li><p>总有很多人说这个游戏中 boss 的动作抄袭黑暗之魂，血缘等游戏。但其实并没有，因为游戏中大部分的动作都是虚幻 4 商城里的，这里应该手动滑稽。</p></li><li><p>这个游戏的手感个人认为是近几年国产动作游戏里不能说数一数二，也是名列前茅。和之前的《隐龙传》和《初体计划》相比也是有其优势。有些人总是拿国产小型制作组做的独立游戏跟国外的大作比，然后一顿批判，似乎这种“哀其不幸，怒其不争”的态度能让中国的单机游戏市场环境能够更好一点。如果你真心希望国产单机能够越来越好，就请不要践踏制作组的心血，如果不是和某个靠打着幌子骗玩家钱的制作组一样，大部分国产制作组还是很良心的。</p></li><li><p>另外，据说这游戏的动作捕捉都是让美术自己上去做的，制作组是真的穷。给国产点信心吧，有钱了会更好。</p></li></ul><p><strong> 总之，《救赎之路》算是一款比较不错的独立游戏，如果你喜欢类魂游戏高难度的 boss 战或者对国产动作游戏比较感兴趣，那你大可以去尝试一下这部作品。如果你喜欢精巧的构思和值得思索的剧情，那这款游戏并不适合你。 </strong></p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/20184sinner.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="测评" scheme="http://Cloudust.coding.me/categories/%E6%B5%8B%E8%AF%84/"/>
    
    
      <category term="游戏" scheme="http://Cloudust.coding.me/source/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>不太“硬核”的硬核动作游戏 —— 《隐龙传隐踪》</title>
    <link href="http://Cloudust.coding.me/blog/%E4%B8%8D%E5%A4%AA%E2%80%9C%E7%A1%AC%E6%A0%B8%E2%80%9D%E7%9A%84%E7%A1%AC%E6%A0%B8%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F%20%E2%80%94%E2%80%94%20%E3%80%8A%E9%9A%90%E9%BE%99%E4%BC%A0%E9%9A%90%E8%B8%AA%E3%80%8B20180407/"/>
    <id>http://Cloudust.coding.me/blog/不太“硬核”的硬核动作游戏 —— 《隐龙传隐踪》20180407/</id>
    <published>2018-04-06T16:00:00.000Z</published>
    <updated>2018-11-03T05:24:56.430Z</updated>
    
    <content type="html"><![CDATA[<p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20184hidden dragon.jpg" alt=""><br><a id="more"></a></div></p><p>之前听说在 CJ 上火的不得了的游戏，无奈因为在通关另一款游戏而搁置了，现在刚好遇到清明假期，就挤出时间玩一下。</p><h3 id="画面"><a href="#画面" class="headerlink" title="画面"></a>画面</h3><p>首先值得肯定的是《隐龙传》使用了三渲二技术，画面比起普通的 2D 格斗上了一个档次，特效做起来也十分炫目。<br><img src="http://c1oudust-blog.test.upcdn.net/20184The cell.jpg" alt="游戏开始时的牢房，可以看到地下狱卒的尸体"></p><p><img src="http://c1oudust-blog.test.upcdn.net/20184LUO YANG.jpg" alt="洛阳城"></p><p><img src="http://c1oudust-blog.test.upcdn.net/20184Bamboo Grove.jpg" alt="竹林"></p><p><img src="http://c1oudust-blog.test.upcdn.net/20184Organs castle.jpg" alt="机关城，可以看到不是很精细的贴图，但场景设计的还不错"></p><p><img src="http://c1oudust-blog.test.upcdn.net/20184The hidden city.jpg" alt="隐城山道"></p><p>从开局的牢房，到后来的洛阳城，竹林，机关城，隐城，每个场景的建模都很有古风场景的特色，除了竹林，其他场景均以暗色调为主。游戏建模方面给人感觉略显粗糙，主要是贴图不够精细，而场景的亮度又偏暗导致的。这点倒是可以理解，毕竟只是独立游戏，本人也对独立游戏的画面精美性没有硬性要求。个人比较喜欢的是游戏中介绍世界观时出现的水墨画场景，很有感觉。<br><img src="http://c1oudust-blog.test.upcdn.net/20184Ink.jpg" alt=""></p><h3 id="游戏性"><a href="#游戏性" class="headerlink" title="游戏性"></a>游戏性</h3><p>横版动作游戏中一气呵成的打斗连招是最判断一个动作游戏操作性的重要标准。《隐龙传》的上手难度并不算高，通过轻重攻击能打出很华丽的连招，但连招的动作却给人一种很僵硬的感觉，尤其是以重攻击开头的连招能看到很明显的停顿。游戏可以在地上可以释放的连招只有寥寥几套，而敌人的血量又通常偏高，在玩家反复使用这几套连招而丧失新鲜感后，就只会觉得疲惫和乏味。<br><img src="http://c1oudust-blog.test.upcdn.net/20184combo.jpg" alt=""></p><p>游戏一共有两种武器 —— 剑和飞刀（钩爪是辅助用的不能算是武器）。在前期伤害不高，几乎没有用飞刀，在后期就成了消耗神器，所以一定要点满飞刀的技能。游戏中一个比较独特，也可以说是弊病的设计 —— 霸体系统，在霸体状态下的人物无法被打断出招和产生僵直。<br><img src="http://c1oudust-blog.test.upcdn.net/20184bati.jpg" alt=""></p><p>游戏后几章的绝大多数精英小兵和 boss 都有霸体状态，这给游戏增加了不少难度。由于无法打断技能，因此没有霸体的你只有规避他而不能用技能打断其出招。在后期，你的连招很有可能没有放完就被霸体的敌人打出僵直，这就会让玩家感到更加烦躁，很难获得动作游戏的爽快感。另外，由于这个十分不友好的设定，游戏要无伤通关基本是不可能的，这些设定完全违背了作为一个动作游戏的本质。<br><img src="http://c1oudust-blog.test.upcdn.net/20184combo_2.jpg" alt=""></p><p>游戏的闪避系统需要消耗体力，没有装备特殊心法只能一次性闪避三次，同时等待体力恢复。而闪避系统的收益 —— 防反，虽然炫酷，但实则有点鸡肋，还不如击飞敌人或使敌人僵直来得实在。</p><p>游戏中有几个需要解密的场景，解密不难，却略显枯燥，比如机关城中的五行石盘。在主角前往机关城的路中有一段需要跑酷的场景，几段需要精确把握跳跃时机的路和周围爆炸傀儡的追赶，成为了游戏中最具有难度的一关（居然比 boss 战都难，有没有搞错）。而失败几次后你就会看到制作组充满恶意的嘲讽 —— 弹幕护体!游戏中像这样的跳跃关卡还有很多，在拿到了钩爪后这些关卡就变成了纯粹的背板。<br><img src="http://c1oudust-blog.test.upcdn.net/20184parkour.jpg" alt="满满的恶意"></p><p>关于游戏的收集系统。游戏中的宝箱分为两种，一种是普通的箱子，里面只有蓝魂和药，另一种就是比较“高端”一点的，里面可以拿到武器、心法还有一些特殊收集品。但游戏第一周目中第二种宝箱实在是少的可怜，而可供收集的武器和心法又那么多，所以一周目的流程无论如何都没办法收集齐所有的心法加武器，这也太坑爹了吧 OTZ，这只是一个横版动作游戏不是什么 RPG 啦！更坑爹的是这游戏居然没有存档点，自动存档大概是在小关卡的门口，剧情过后和 boss 战前。人家《艾希》好歹有个标注存档位置的机器人啊，哪怕是自动保存，这游戏却连一个已存档的提示都没有。</p><h3 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h3><p>作为一个资深游戏剧情爱好者，对这个游戏的剧情塑造极其不满。游戏的背景设定中规中矩 —— 武氏后人、渴望复仇的神秘组织“爻”，惨遭灭门的玄剑门，化身于剑中为主角指引方向的剑魂。主角作为玄剑门的最后一人，对灭门案进行探查，经过神秘人的指引，拨开重重疑云，最终完成复仇归隐山林。<br><img src="http://c1oudust-blog.test.upcdn.net/20184Hidden dragon_End.jpg" alt="结局是归隐山林"></p><p>这明明是一个很极其王道的江湖武侠故事，但在游戏中却丝毫没有表现力，在短短 5 6 个小时的游戏流程中，细节可谓是少之又少，过场剧情动画也是简单粗暴，这跟显得比较宏伟的开场动画相比就十分尴尬了。不说在剧情中对主角是玄剑门弟子的描写桥段甚少，就连主角的名字“陆天源”都是由 boss 叫出来才知道的。关于玄剑门灭门案可以推测出是二师兄背叛了宗门，与“爻”联合杀死了掌门，之后自己也沦为丹药的牺牲品（莫名想起奎尔萨拉斯之战）。</p><p>在主角刚开始所在的牢房中可以看到几个躺着的狱卒尸体，而一路走下去只有在牢房外才看到活着的狱卒，那么牢房中的狱卒究竟是如何死的，牢房为何空无一人，主角又是如何幸免于难，这些都未作说明。</p><p>作为指引主角的神秘人“朱红”的身世也没有详细描述。玩家只知道她是吐蕃族匠人，也是铸造龙鼎之人，用剩余材料铸成隐龙剑，以身化为剑魂以便后人报仇。</p><p><img src="http://c1oudust-blog.test.upcdn.net/2018420180405133339_1.jpg" alt=""><br>后期主角找到隐城的方式也是槽点满满，杀死了暗鸦，断了线索，这里应该是由“朱红”对主角做指引，或者主角发现暗鸦房间后进行探索比较好，而游戏中仅仅是因为妹子想起了白鬼和暗鸦房间里的画，主角就找到了隐城，这段剧情实在让人摸不着头脑。这让我想起另一个江湖风横版动作游戏《雨雪》，对于剧情描述的把控比《隐龙传》不知道高到哪里去了。</p><p><img src="http://c1oudust-blog.test.upcdn.net/20184bamboo_2.jpg" alt="剧情动画中我最喜欢的一个分镜"></p><p><strong>总之，《隐龙传隐踪》是一款不太“硬核”的硬核动作游戏，如果你是一个硬核 ACT 爱好者，那可能会失望不少，如果你只是单纯喜欢武侠风或者横版卷轴式动作游戏，不太追求丰富的剧情和华丽的画面，它会是一个不错的选择。在国产独立游戏中，《隐龙传》的质量也能勉强跻身于中上水平。</strong></p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/20184hidden dragon.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="测评" scheme="http://Cloudust.coding.me/categories/%E6%B5%8B%E8%AF%84/"/>
    
    
      <category term="游戏" scheme="http://Cloudust.coding.me/source/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="steam" scheme="http://Cloudust.coding.me/source/tags/steam/"/>
    
  </entry>
  
  <entry>
    <title>冰冷世界中的孤独爱恋 —— 《水形物语》与《沙耶之歌》</title>
    <link href="http://Cloudust.coding.me/blog/%E5%86%B0%E5%86%B7%E4%B8%96%E7%95%8C%E4%B8%AD%E7%9A%84%E5%AD%A4%E7%8B%AC%E7%88%B1%E6%81%8B%20%E2%80%94%E2%80%94%20%E3%80%8A%E6%B0%B4%E5%BD%A2%E7%89%A9%E8%AF%AD%E3%80%8B%E4%B8%8E%E3%80%8A%E6%B2%99%E8%80%B6%E4%B9%8B%E6%AD%8C%E3%80%8B20180322/"/>
    <id>http://Cloudust.coding.me/blog/冰冷世界中的孤独爱恋 —— 《水形物语》与《沙耶之歌》20180322/</id>
    <published>2018-03-21T16:00:00.000Z</published>
    <updated>2018-11-03T05:25:40.817Z</updated>
    
    <content type="html"><![CDATA[<p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20183saya_and_water.jpg" alt=""><br><a id="more"></a></div></p><p>三月飞雪，恰逢雪后初晴，空气中还残留着化雪后寒意。呼出的暖气凝结在镜片上，变成淡淡薄霜，又渐渐消散。鲜有行人的街道上，苍白的路灯光透过丝丝冷风，沉浸在《水形物语》的意境中。</p><p>比起定位成奇幻爱情片，《水形物语》更是一部黑暗成人童话。除了色调和音乐上的讨喜，《水形物语》对孤独的诠释也足以成为使之获得金狮奖的原因之一。位于社会最底层的哑巴清洁工，研究所中身负枷锁的鱼人，同性恋老年落魄画家，背叛了一切的克格勃科学家 —— 无时无刻不在倾诉着这个孤独的世界。</p><p>所以，整个故事无非是孤独者的彼此救赎。</p><p>那么孤独的人聚集在一起就能摆脱孤独吗？答案当然是不能。畸形人兽恋在伦理中无法被理解，同性恋最终受到排斥，为了心中的大义所背叛一切的人最终被其大义背叛。</p><p>这点与《沙耶之歌》似乎如出一辙 —— 老虚笔下所描绘的渴望变成人类的“怪物”沙耶与厌恶世界的病态主人公郁纪的绝望爱情故事。</p><p>郁纪在车祸之后所看到的，是一个充满污秽与肮脏的世界，人类变成 “肉块” ，声音令人作呕，建筑上充满了鲜血、腐肉与不可言状之物，所及之处是破碎和混乱的风景。于是他的性格变得极端，自私，人性的黑暗完全体现在了他身上。身陷腐肉固然痛苦，然而真正使他化为恶魔的却是他自身的劣根性。后来郁纪对自己曾经朋友所犯下的恶行，很多是源于他的食欲与性欲。</p><p>但幸运的是，他遇到了同类——沙耶，一个在病态的郁纪眼里以少女形态出现的生物，在郁纪被视为异端，孤立无援之时出现的一盏灯。沙耶为郁纪的接纳而开心，郁纪为这个柔软美好的存在而稍微从孤独中挣脱出来了。沙耶就是“人”这个符号的象征 —— 被发现吃人肉时的惊恐，不想被郁纪知道真身的自卑，对瑶进行改造后的喜悦，这都是人类所具有的情感与性格。</p><p>“无论形态如何，那灵魂的形状是与我们所接近的。”</p><p>《水形物语》中主人公的生活环境虽然不如《沙耶之歌》中的那么恶劣与极端，但依然在强烈体现着孤独。</p><p>故事的大背景发生在冷战时期的美国，剧院上的小隔间以及工作所在研究所，是哑女千篇一律生活的起点与终点。</p><p>哑女是孤独的 —— 生活简单的千篇一律，唯一的乐趣是在浴缸里自慰。无法说话，自然不能表达出自己的情感，只有用狠狠的砸墙来表达其极度想要拯救男主的心情。</p><p>老年画家是孤独的 —— 同性恋，画作从未被接受，始终与猫为伴。</p><p>鱼人是孤独的 —— 被南美土著奉为神灵却在研究所遭受折磨。它是所有人的玩物，更是女主收养的美丽的宠物。</p><p>苏联科学家是孤独的 —— 不被美国人信任，不被自己人信任，甚至自己的名字 “迪米特里” 也是一个不能说出口的秘密。他是影片中唯一一个三观正常的人，却也是第一个死掉的人。</p><p>连大反派也是孤独的 —— 在家庭与工作中，都格格不入，只有通过虐待男主来发泄心中的郁闷。</p><p>他们的孤独，不被也无法被人理解，以至于通过相互依赖才能缓解独自存活的痛苦。在现实生活中越是难以被人理解、心灵和精神越孤独的人，越想要在幻想中创造一个这样能完全理解、完全接受自己的灵魂。孤独之人所在的世界是冰冷的，唯一能抵御冰冷孤独世界的东西，只有爱 —— 畸形的爱。而就好像人类离不开食物一样，当这种爱变成赖以生存的食粮，一种病态而美丽的安全感就会滋生其中 —— 像毒品使人沦陷。</p><p>《水形物语》中，鱼人与哑女最终突破了囚禁他们的冰冷牢笼，哑女脖颈间的神秘伤疤化为腮，与鱼人重获新生。在《沙耶之歌》中，爱仍旧是存在的。一个结局里，身处绝境濒临死亡两“人”仍然艰难地接近彼此，想要在生命最后留住对方的体温，而另一个结局里，沙耶结束了自己的生命，孕育出了无数“孢子”，为郁纪创造了一个美丽的新世界。他们的确相爱着，即使曾经自私冷酷，但在这一秒，心脏只为对方悸动，灵魂也只为对方无私。</p><div align="center"><p><img src="http://c1oudust-blog.test.upcdn.net/20183songofsaya.jpg" alt="沙耶之歌"></p><p><img src="http://c1oudust-blog.test.upcdn.net/20183water.jpeg" alt="水形物语"></p><p><div align="left"><br>　　这就是世界。没有纯粹的善恶，也不像英雄电影那种非黑即白。而我们是人类，始终贪婪丑陋自私，也始终追求着能令自己变得无私美好的迷失。每个人都是孤独的个体，在漫漫时间长河中，能遇到一个自己所爱的事物，即使相隔深渊，也依然要去追寻吧。<br>　　以上。</div></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/20183saya_and_water.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://Cloudust.coding.me/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="游戏" scheme="http://Cloudust.coding.me/source/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="电影" scheme="http://Cloudust.coding.me/source/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>关于自学计算机专业课程的一点体会</title>
    <link href="http://Cloudust.coding.me/blog/%E5%85%B3%E4%BA%8E%E8%87%AA%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E7%9A%84%E4%B8%80%E7%82%B9%E4%BD%93%E4%BC%9A20180226/"/>
    <id>http://Cloudust.coding.me/blog/关于自学计算机专业课程的一点体会20180226/</id>
    <published>2018-02-25T16:00:00.000Z</published>
    <updated>2018-11-03T05:25:33.283Z</updated>
    
    <content type="html"><![CDATA[<p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20182Bangalore_India_Tech_books_for_sale_small.jpg" alt=""><br><a id="more"></a></div></p><blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2></blockquote><p>作为一个计算机专业的大学生，深感学校课堂试教育的局限性，从而在大学中的许多课程基本都靠自学。因此对自学计算机专业的课程做以总结。</p><p>其实在实际开发中，并不能完全用到那些枯燥抽象的计算机专业课。所以为什么还要去学它们呢？原因只有一个，让你在计算机行业能有更长远的发展，以防止程序员只能吃青春饭的现象。这些专业理论课就如同武侠小说中的内功，而编程语言框架等则都属于外功招式。试想，一个徒有花拳绣腿的人怎么可能与一个拥有深厚内功的人抗衡呢。</p><p>经过对比，可以发现各个大学计算机专业的核心课程高度一致，这是国际计算机学会 ACM(Association for Computing Machinery) 和 IEEE-CS 联合工作组发布的 CS2013(计算机科学课程指南 2013) 报告，提出的计算机科学知识体的概念。该报告给出的关于计算机科学的十八个知识领域如下：</p><div align="center"><table><thead><tr><th style="text-align:center">缩写</th><th style="text-align:left">英文</th><th style="text-align:left">中文</th></tr></thead><tbody><tr><td style="text-align:center">AL</td><td style="text-align:left">Algorithms and Complexity</td><td style="text-align:left">《算法与复杂度》</td></tr><tr><td style="text-align:center">AR</td><td style="text-align:left">Architecture and Organization</td><td style="text-align:left">《计算机结构体系与组织》</td></tr><tr><td style="text-align:center">CN</td><td style="text-align:left">Computational Science</td><td style="text-align:left">《计算科学》</td></tr><tr><td style="text-align:center">DS</td><td style="text-align:left">Discrete Structures</td><td style="text-align:left">《离散数学》</td></tr><tr><td style="text-align:center">GV</td><td style="text-align:left">Graphics and Visualization</td><td style="text-align:left">《图形与可视化》</td></tr><tr><td style="text-align:center">HCI</td><td style="text-align:left">Human-Computer Interaction</td><td style="text-align:left">《人机交互》</td></tr><tr><td style="text-align:center">IAS</td><td style="text-align:left">Information Assurance and Security</td><td style="text-align:left">《信息保障与安全》</td></tr><tr><td style="text-align:center">IM</td><td style="text-align:left">Information Management</td><td style="text-align:left">《信息管理》</td></tr><tr><td style="text-align:center">IS</td><td style="text-align:left">Intelligent Systems</td><td style="text-align:left">《智能系统》</td></tr><tr><td style="text-align:center">NC</td><td style="text-align:left">Networking and Communications</td><td style="text-align:left">《网络与通讯》</td></tr><tr><td style="text-align:center">OS</td><td style="text-align:left">Operating Systems</td><td style="text-align:left">《操作系统》</td></tr><tr><td style="text-align:center">PBD</td><td style="text-align:left">Platform-based Development</td><td style="text-align:left">《基于平台的开发》</td></tr><tr><td style="text-align:center">PD</td><td style="text-align:left">Parallel and Distributed Computing</td><td style="text-align:left">《并行与分布式计算》</td></tr><tr><td style="text-align:center">PL</td><td style="text-align:left">Programming Languages</td><td style="text-align:left">《程序设计语言》</td></tr><tr><td style="text-align:center">SDF</td><td style="text-align:left">Software Development Fundamentals</td><td style="text-align:left">《软件开发基本原理》</td></tr><tr><td style="text-align:center">SE</td><td style="text-align:left">Software Engineering</td><td style="text-align:left">《软件工程》</td></tr><tr><td style="text-align:center">SF</td><td style="text-align:left">Systems Fundamentals</td><td style="text-align:left">《系统基本原理》</td></tr><tr><td style="text-align:center">SP</td><td style="text-align:left">Social Issues and Professional Practice</td><td style="text-align:left">《社会问题与专业实践》</td></tr></tbody></table><div align="left"><p>而 ACM 又将对这些知识的掌握程度分为以下三级：</p><ul><li><p>Familiarity: What do you know about this? 理解一个概念是什么或意味着什么。</p></li><li><p>Usage: What do you know how to do? 能够以具体的方式使用或应用概念。例如，在程序中适当地使用特定的概念，使用特定的证明技术，或执行特定的分析。</p></li><li><p>Assessment: Why would you do that? 能够从多角度考虑一个概念和/或为解决某个特定问题选择特定的方法。这种程度的掌握涉及到从能够解决问题的所有方案中中选择最适合的方法的能力。</p></li></ul><p>那么在业余时间自学计算机专业课程是否可能？完全可以！计算机专业是人类历史上第一个可以在互联网上学到到几乎所有专业知识的专业，在互联网，可以听到从本科到研究生层次，从国内重点大学到国外知名高校的几乎所有的课程，除了一些硬件课程需要必备的设备之外，其他课程只需要一台能上网的电脑就完全足够了。</p><blockquote><h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2></blockquote><p><img src="http://oyq24xmaa.bkt.clouddn.com/20182学习路线.png" alt="学习路线"></p><ul><li><p>首先需要对计算机科学和计算机产业进行总体的认识，可以通过阅读计算机导论有关的书籍进行了解。</p></li><li><p>在对计算机概论有一个比较全面的了解后，我们最先需要的就是掌握一门编程语言，同时学好数学。在大学的计算机专业中，这两部分往往安排在大一至大二。</p><p>关于初学者第一门编程语言，比较常见的有这几种：</p><ul><li><strong>C</strong>：国内大多高校所普遍使用的入门语言。</li><li><strong>JAVA/C#</strong>：两者都是很典型的面向对象的编程语言，后期的课程如数据结构与算法也有不少学校使用其作为范例编程语言。 JAVA 有很多非常活跃的开源社区与数不尽的开发者为其提供代码以供学习。而 C# 的背后则是 IT 巨头微软，并且 C# 的语法糖被很多新生语言所借鉴，如 Google 现今的官方开发语言 kotlin。</li><li><strong>Python</strong>：典型的动态语言，国内一部门高校所选用的新兴入门语言，应用极为广泛。尤其是现今的大数据与人工智能时代，更加离不开 Python。</li></ul></li></ul><p>这些编程语言的均可以通过书籍与视频结合的学习方法。关于学习的书籍和视频网上已经有很多了，这里就不做赘述。</p><p>计算机专业必须掌握的四门数学课程，包括高等数学、离散数学、线性代数、概率论与数理统计。为什么要学数学？因为具备基本的数学能力是对所有计算机专业人员的基本要求。在实际开发项目中，对程序员的数学功底要求其实并不高，很多框架的底层都有强大的算法作为支撑，但初级程序员并不需要完全理解这些算法。对于初级程序员来说，仅仅需要有高中的数学基础加上一些数据结构的知识就行了。但对于中高级程序员来说，则必须基本良好的数学功底，尤其是需要使用一些特定技术进行开发，建模或者设计相关算法，例如现今比较流行的人工智能，它的实现就需要强大的 AI 算法——这意味的技术水平的提高，学习领域的深入，所需要的数学功底也是逐渐提高的。</p><p>本人以前觉得只要掌握大学中所学的数学就足够了，然而在深入学习中却发现大学中所学的数学基础课程还远远不够用于开发，例如我在学习 unity 的过程中，经常碰到三维向量，欧拉角与四元数等等，为了理解这些东西，我重新回过头来学习了一遍计算机图形学中的 3D 数学。</p><p>国内的大部分数学教材，往往只讲相关的法则定理证明等等理论知识，而不会涉及到其发展历史和具体应用，不强调解决特定问题的思路，文字枯燥，并不适合自学。还有些教材往往写的过于简练，比如经常出现“由此可见”，“由此可得”等词语，本人在自学的过程中对这些词眼极为头疼，于是便放弃了使用国内的教材。</p><p>这里可以参考知乎上@周筠 的回答：<a href="https://www.zhihu.com/question/26761596/answer/36428134" target="_blank" rel="external">计算机系的高数，离散，线代都是用在哪些方面的？ - 周筠的回答 - 知乎</a>，讲的很不错。</p><ul><li><p>在掌握了编程语言与数学基础后，就可以进入专业基础课和一些使用技术的学习。各个学校的计算机专业基础课都大同小异，总数有十多门。但最重要的就是以下四门科目，也是计算机专业学生的考研科目——数据结构与算法、计算机组成原理、操作系统、计算机网络。同样采用视频与教材结合的方式。</p><ul><li><strong>数据结构与算法</strong>：参考书籍：机械工业出版社的 <a href="https://book.douban.com/subject/26696971/" target="_blank" rel="external">《算法基础 打开算法之门》</a>和<a href="https://book.douban.com/subject/20432061/" target="_blank" rel="external">《算法导论》</a></li></ul><p>公开课：<br><a href="http://t.cn/REb4byh" target="_blank" rel="external">麻省理工学院公开课：算法导论</a></p><p><a href="http://t.cn/R006U7j" target="_blank" rel="external">Data Structures • 数据结构</a></p><ul><li><strong>计算机组成原理</strong>：这门课可以用两个字概括——抽象。对于在校大学生，我们不需要(也不可能)完整的理解它，因此可以把它和操作系统这门课结合起来学习。<br>参考书籍：人民邮电出版社的<a href="http://book.douban.com/subject/1886058/" target="_blank" rel="external">《计算机组成：结构化方法》</a></li></ul><p>公开课：<br><a href="http://t.cn/REbGSJL" target="_blank" rel="external">计算机组成原理</a></p><ul><li><strong>操作系统</strong>：</li></ul><p>参考书籍：中国电力出版社的<a href="https://book.douban.com/subject/1230413/" target="_blank" rel="external">《深入理解计算机系统》</a></p><p>公开课：<br><a href="http://t.cn/R5A810s" target="_blank" rel="external">浙江大学操作系统 38 讲</a></p><p><a href="http://t.cn/REb5TGW" target="_blank" rel="external">操作系统原理</a></p><ul><li><strong>计算机网络</strong>：这门课应该从上层往下层学习，而且需要通过实验以加深理解。</li></ul><p>参考书籍：<a href="https://book.douban.com/subject/21267825/" target="_blank" rel="external">《计算机网络教程：自顶向下方法》</a></p><p>公开课：<br>哈工大的 <a href="http://t.cn/R8wibet" target="_blank" rel="external">计算机网络</a></p><p><a href="http://t.cn/REbcou4" target="_blank" rel="external">计算机网络基础</a></p><p>作为大学生，以上科目可以先完整的看一遍教学视频，配合参考书籍和学校的教程进一步学习，重点还是在学习的过程中多去实践。在学习理论科目的同时，我们可以学习一些相关的实用技术，如各种流行的开发框架和工具等来加深理解。</p></li></ul><ul><li>在完成了以上学习后，就进入了一个新的自学阶段，这一阶段的学习就可以针对你感兴趣的特定领域进行了解和学习。比如人工智能，物联网，大数据，web 开发，游戏开发等等。这一阶段的学习目的非常明确，就是培养特定领域的专业编程技能，从而能够选择进入相关领域继续研究(考研考博)或者进入参加。</li></ul><p>最重要的一点是：你需要打好扎实的基础。其实在很多大公司眼里，新人只是一张能够吸墨的白纸，你的基础扎实程度就代表你能够吸收多少墨汁。所以在大学期间，不要过分追求项目经验。但这并不代表着你不需要对所学的知识加以实践，只是相比“怎么做”，你更加需要明白“为什么”。</p><blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2></blockquote><p>上面的课程有些我已经学完了，而有些还在学习过程中。<br>我喜欢去总结我所经历的事物，即使人生发生的种种只是过眼云烟，但我还是希望一些有意义的事能永远留下。</p><p>以上。</p><blockquote><p>参考：</p></blockquote><p><a href="http://ai.stanford.edu/users/sahami/CS2013/" target="_blank" rel="external"><em>Computer Science Curricula 2013</em></a></p><p><a href="http://t.cn/REbVxPz" target="_blank" rel="external"><em>计算机专业如何自学好以及职业规划？</em></a></p></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/20182Bangalore_India_Tech_books_for_sale_small.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="http://Cloudust.coding.me/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="http://Cloudust.coding.me/source/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>关于手机刷机的个人总结</title>
    <link href="http://Cloudust.coding.me/blog/%E6%9C%89%E5%85%B3%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA%E7%9A%84%E6%80%BB%E7%BB%9320180219/"/>
    <id>http://Cloudust.coding.me/blog/有关手机刷机的总结20180219/</id>
    <published>2018-02-18T16:00:00.000Z</published>
    <updated>2018-11-03T05:25:51.711Z</updated>
    
    <content type="html"><![CDATA[<p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20182android.jpg" alt=""><br><a id="more"></a></div></p><blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2></blockquote><p>从接触第一部智能机到学会刷机再到现在养老已经很久了，现在看刷机，早已没有刚开始的新奇劲，那种进入新系统的激动与喜悦。</p><p>因此，我觉得有必要对安卓刷机做一个个人总结，算是我搞机生涯的结束吧( • ̀ω•́ )✧</p><blockquote><h2 id="刷机前需要了解的东西"><a href="#刷机前需要了解的东西" class="headerlink" title="刷机前需要了解的东西"></a>刷机前需要了解的东西</h2></blockquote><h4 id="为什么要刷机"><a href="#为什么要刷机" class="headerlink" title="为什么要刷机"></a>为什么要刷机</h4><ul><li>获取最新的系统更新</li><li>获取原本无法没有的特性</li><li>通过刷机改善因手机使用时间太长导致的机器变慢</li><li><p>刷机这个行为本身就是刷机者所追求的——为了刷机/好玩去刷机——像大爆炸里的台词一样：</p><blockquote><p>“为什么要刷机？”</p><p>“因为可以这么做”</p></blockquote></li></ul><h4 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h4><ul><li><strong>Bootloader</strong>：通称 BL ，字面上来看就是启动加载的意思。BL 就相当于手机的 Bios，在手机启动的时候根据基带初始化硬件，然后引导系统内核，直到系统启动。如果 BL 不能正常加载，手机无法正常启动和使用。这也就是为什么 BL 被锁的手机必须要解锁才能刷入 REC 以至于卡刷第三方 ROM。</li><li><strong>REC</strong>：Recovery，手机内置的独立备份恢复工具，类似电脑上的还原系统，在系统出问题时可以打开然后复原系统。手机出厂内置 REC，但厂商提供的 REC 通常不能刷第三方的 Rom,因此在刷机前需要刷入第三方 REC。</li><li><strong>卡刷 &amp; 线刷</strong>：卡刷的意思是把第三方 ROM 下载到手机内存中，进入 REC 刷机的一种的刷机方式，是普遍采用的刷机方式。而与对应的线刷，则是连接电脑上工具进行刷机，这种方式通常用来救砖——即恢复系统坏了的手机。需要知道的是，线刷是不需要解锁 BL 的，因为线刷是在 BL 内的 FastBoot 状态下进行的，而卡刷需要 BL 进一步加载 REC。</li><li><strong>双清</strong>：清除手机数据和缓存，刷机前必须的工作，意味着手机所有应用和其数据都会被清空，但不包括手机内存空间和 SD 卡，因此刷机前需要备份重要的资料如通讯录等。REC 中有一键双清的功能。</li></ul><blockquote><h2 id="第三方-REC"><a href="#第三方-REC" class="headerlink" title="第三方 REC"></a>第三方 REC</h2></blockquote><ul><li><p><strong>TWRP</strong></p><p><a href="twrp.me">官网</a></p><p>目前最普及的第三方 REC，由 TeamWin 团队开发并在 GitHub 上开源。<br>通常可以进 FastBoot 模式用 adb 命令刷入，不过很多论坛大佬做出了一键刷入 twrp 的工具，因此去各手机的论坛就能找到了。</p></li><li><p><strong>Red Wolf</strong></p><p>Red Wolf Recovery 是一个基于 TWRP 源码的第三方 Recovery，并且有许多会让人感叹的特性。提供了一些 TWRP 中没有的功能，并且这是世界上第*个(此词违反中国广告法)提供密码保护功能的 Recovery。</p></li></ul><blockquote><h2 id="ROM-包"><a href="#ROM-包" class="headerlink" title="ROM 包"></a>ROM 包</h2></blockquote><p>我个人用过很多的第三方 ROM，包括 Ubuntu Touch 和 Sailfish OS，不过这两个不在讨论之内。同样，国产深度定制 OS 如 MIUI，Flyme 以及很老的百度云 OS,点心 OS 和乐蛙 OS 等也不在讨论范围内。</p><p>关于你机型的最全的 ROM 包 都在 <a href="forum.xda-developers.com">XDA 论坛</a> 里，在搜索栏里输入机型的英文名就能找到。</p><p>同样，也可以在国内相对应机型的论坛里找到 ROM 包，不过有些还是从 XDA 上搬运的，XDA 上的包虽然是英文的，但大多都有很完整的中文翻译，刷入后在设置中选择中文就可以了。</p><p>这里列举一下的用过且目前为止仍在更新的第三方 ROM 包。</p><ul><li><p><strong>LineageOS</strong></p><p><a href="www.lineageos.org">官网</a></p><p>  <div align="center"><br>  <img src="http://c1oudust-blog.test.upcdn.net/20182LineageOS.jpg" alt=""></div></p><p>LineageOS 的前身是 Cyanogenmod —— 由目前全球最大的 Android 第三方编译团队 Cyanogen 团队开发。<br>作为安卓上支持设备最多的 ROM，它也被二次开发成了很多新的 ROM。</p></li><li><p><strong>Resurrection Remix OS</strong></p><p><a href="www.resurrectionremix.com">官网</a></p><p>  <div align="center"><br>  <img src="http://c1oudust-blog.test.upcdn.net/20182ResurrectionRemixOS.png" alt=""></div></p><p>通称 RR，一个基于 LineageOS 的定制 ROM，有非常多的自定义功能，系统稳定，省电。</p></li><li><p><strong>AospExtended ROM</strong></p><p><a href="www.aospextended.com">官网</a></p><p>  <div align="center"><br>  <img src="http://c1oudust-blog.test.upcdn.net/20182AEX.png" alt=""></div></p><p>通称 AEX，基于安卓原生 AOSP，纯净，流畅。</p></li><li><p><strong>Pixel Experience</strong></p><p><a href="www.pixelexperience.org">官网</a></p><p>  <div align="center"><br>  <img src="http://c1oudust-blog.test.upcdn.net/20182Pixel Experience.jpg" alt=""></div></p><p>谷歌亲儿子 Pixel 的 ROM，基于 AOSP，自带谷歌全家桶。</p></li><li><p><strong>Android Ice Cold Project</strong></p><p><a href="http://aicp-rom.com" target="_blank" rel="external">官网</a></p><p>  <div align="center"><br>  <img src="http://c1oudust-blog.test.upcdn.net/20182AICP.png" alt=""></div></p><p>通称 AICP ，目前基于 AOSP 的一款定制系统，和 AEX 一样有着原生的体验和 RR 的多样定制化功能。</p></li><li><p><strong>Dirty Unicorns</strong></p><p><a href="www.dirtyunicorns.com">官网</a></p><p>  <div align="center"><br>  <img src="http://c1oudust-blog.test.upcdn.net/20182DIRTY UNICORNS.jpg" alt=""></div></p><p>肮脏独角兽，个人最喜欢的 ROM 之一，优化特别好，可惜官方适配的机型太少。开发者又跟 XDA 闹了矛盾，互相封杀对方，导致很多人对这个 ROM 的印象不好，因此非官方包的数量也很少。不过一加一刷了这个真是能重获新生啊，非常好用的包。</p></li><li><p><strong>DOToS</strong></p><p><a href="dotos.github.io">官网</a></p><p>  <div align="center"><br>  <img src="http://c1oudust-blog.test.upcdn.net/20182dotos.jpg" alt=""></div></p><p>一个刚刚兴起没多久的 ROM，相对于其他类原生 ROM 还是有很多亮点的，UI 上也很不错，过渡动画很舒服。在酷安基佬的安利下刷了这个 ROM,ROM 包很小，但自定义功能还算是比较多的。</p></li><li><p><strong>Cosmic OS</strong></p><p><a href="cosmic-os.github.io">官网</a></p><p>  <div align="center"><br>  <img src="http://c1oudust-blog.test.upcdn.net/20182cosmic.png" alt=""></div></p><p>新兴 ROM 之一，宇宙系统，名字略显高大上啊，目前的自定义功能很多，系统优化还算不错。</p></li><li><p><strong>Nitrogen OS</strong></p><p>  <div align="center"><br>  <img src="http://c1oudust-blog.test.upcdn.net/20182NitrogenOS.png" alt=""></div></p><p>基于 AOSP 的定制系统，目前为止最好用的第三方安卓 8.1，bug 很少，流畅稳定。</p></li><li><p><strong>crDroid</strong></p><p>  <div align="center"><br>  <img src="http://c1oudust-blog.test.upcdn.net/20182crDroid.png" alt=""></div></p><p>老牌 ROM，支持很多古董机型。</p></li><li><p><strong>MoKee</strong></p><p><a href="www.mokeedev.com">官网</a></p><p>  <div align="center"><br>  <img src="http://c1oudust-blog.test.upcdn.net/20182MoKee.jpg" alt=""></div></p><p>中文名魔趣，是由中古时代(2012 年)成功走到现代的国产定制 ROM，早期基于 CM，现在基于 AOSP。官方适配的机型很多，也是我比较喜欢的一款 ROM。<br>作为一个本土开源项目，魔趣的本地化非常好，很符合国内使用的情况。在原生的界面体验下加入了很多特色的功能，比如调教好的宙斯盾和 Viper 音效。</p></li><li><p><strong>Blisspop</strong></p><p><a href="www.blissroms.com">官网</a></p><p>  <div align="center"><br>  <img src="http://c1oudust-blog.test.upcdn.net/20182blisspop.png" alt=""></div></p><p>很久前一加刷过的系统，最近看了一下，还出了 x86 桌面版，顺便一提，remix 凉了之后国内能用的 x86 就只有凤凰了，现在又有新选择了，改天就去试一下！<br>当时的一加一 ROM 还远没有现在多，在刷了 sudamod,mokee 等 ROM 后我选择了这款系统作为长久使用。</p></li></ul><blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2></blockquote><p>人总是要不断接触新事物的，与其拘泥于单一，不如在好奇与兴趣中继续探索。</p><p>我就是这样一个人，总喜欢去尝试新事物，却又常常屈服于前进的障碍，也许会迷茫一阵子，不过所有迷茫最终会化为前进的力量。</p><blockquote><p>我们都在阴沟里，但仍有人仰望星空。</p></blockquote><p>王尔德的这句话一直是我的动力，生活确有不如意的地方，但生活总是会向前。</p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/20182android.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="安卓" scheme="http://Cloudust.coding.me/categories/%E5%AE%89%E5%8D%93/"/>
    
    
      <category term="安利" scheme="http://Cloudust.coding.me/source/tags/%E5%AE%89%E5%88%A9/"/>
    
      <category term="Android" scheme="http://Cloudust.coding.me/source/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>个人电脑实用软件汇总——Windows(二)</title>
    <link href="http://Cloudust.coding.me/blog/%E4%B8%AA%E4%BA%BA%E7%94%B5%E8%84%91%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%B1%87%E6%80%BB%E2%80%94%E2%80%94Windows(%E4%BA%8C)20180212/"/>
    <id>http://Cloudust.coding.me/blog/个人电脑实用软件汇总——Windows(二)20180212/</id>
    <published>2018-02-11T16:00:00.000Z</published>
    <updated>2018-11-03T05:25:12.288Z</updated>
    
    <content type="html"><![CDATA[<p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20182windows_software.jpg" alt=""><br><a id="more"></a></div></p><blockquote><h2 id="四-效率软件"><a href="#四-效率软件" class="headerlink" title="四.效率软件"></a>四.效率软件</h2></blockquote><h3 id="Everything"><a href="#Everything" class="headerlink" title="Everything"></a>Everything</h3><p><a href="http://www.voidtools.com/" target="_blank" rel="external">官网</a></p><p>善用佳软上的<a href="http://t.cn/hfLUF" target="_blank" rel="external">介绍文章</a></p><p><img src="http://c1oudust-blog.test.upcdn.net/20182everything.png" alt=""><br>简评：如果你已经对 Windows 自带的搜索功能不满意，可以尝试使用这款软件来代替自带搜索功能。<br>Everthing 是当之无愧的最强文件搜索神器，速度快到绝对让你难以置信。它还是一款完全免费的软件，界面简洁高效，体积小巧，但功能却非常丰富。</p><ul><li>支持中文搜索，支持正则表达式搜索。<br>具体的教程，可以看官方网站的<a href="http://www.voidtools.com/faq.php#How_do_I_use_regex" target="_blank" rel="external">Everything 如何使用正则表达式</a> FAQ 部分。</li><li><p>HTTP 和 FTP 文件共享功能<br>Everything 也内置了 HTTP、ETP/FTP 服务器的功能，你可以将你的硬盘变成一个网站或 FTP，方便别人下载你的文件。</p><p>使用时只要点击菜单“工具”-“HTTP 服务器”或“ETP/FTP 服务器”后，就可以启动服务了。HTTP 的服务，在浏览器访问 <a href="http://本机ip:端口号" target="_blank" rel="external">http://本机ip:端口号</a> 即可进行访问。FTP 的服务则需要 FTP 客户端来访问了。你还可以在“工具”-“选项”-“HTTP”或“FTP”中设置端口号和访问密码等。</p></li></ul><h3 id="Wox"><a href="#Wox" class="headerlink" title="Wox"></a>Wox</h3><p><a href="http://www.getwox.com/" target="_blank" rel="external">官网</a></p><p>简评：Wox 是一款国产开源免费的软件快捷启动工具，有点 Alfred Windows 版的味道</p><ul><li><p>搜索软件和文件，支持中文拼音的模糊匹配。</p><p>比如要搜 搜狗浏览器，只需要输入“sg”就能匹配得到。<br><img src="http://c1oudust-blog.test.upcdn.net/20182Wox_search.png" alt=""></p></li><li><p>Wox 支持插件，而且有丰富的插件库满足日常使用</p><p><img src="http://c1oudust-blog.test.upcdn.net/20182Wox_plugin.png" alt=""><br>譬如可以查看天气和快速翻译的插件。<br><img src="http://c1oudust-blog.test.upcdn.net/20182Wox_weather.png" alt=""><br><img src="http://c1oudust-blog.test.upcdn.net/20182Wox_translate.png" alt=""><br>更多的插件可以在官网获取。</p><p>更方便的是，在系统安装了 Everything 时，Wox 的搜索功能会直接调用 Everything ，大大提升了效率。</p><p>但是，直接安装完 Everything 的插件你会发现通过它的命令并不能搜索。这时，你还需要进入插件的目录中，将 x64 或 x86 文件夹(根据你系统来选择)里面的 Everything.dll 复制一个到上层目录，重启 Wox 才能生效。</p></li><li><p>支持自定义快捷键呼出和自定义主题</p><p>可以在设置中自定义启动 Wox 窗口的快捷键和窗口主题</p><p>需要使用的时候，按下 <code>Alt</code>+<code>空格</code>，打开窗口搜索软件或文件，是一件非常酷的事呢。</p></li></ul><h3 id="Roaln"><a href="#Roaln" class="headerlink" title="Roaln"></a>Roaln</h3><p><a href="http://www.irolan.com/" target="_blank" rel="external">官网</a></p><p>简评：Rolan 是一款短小精悍的轻量级快速启动工具，你可以将常用的的软件、游戏、文件(夹)快捷方式拖放到软件窗口中，随时通过键盘快捷键呼出 Rolan，点击图标实现快速启动，功能上类似于 Fences 。<br><img src="http://c1oudust-blog.test.upcdn.net/20182Rolan.png" alt=""></p><ul><li><p>Rolan 的界面设计追求“简单朴素”，很现代化的风格。Rolan 支持两种界面布局：「横向布局」和「纵向布局」，在设置-&gt;显示-&gt;主面板布局中切换。<br>在这里也可以调整「图标大小」、「图标显示方式」和「主面板透明度」。</p></li><li><p>软件的使用非常直观，你只需把文件拖进 Rolan 里就可以创建快捷图标项目了。而且软件支持自由拖拽和图标分组。</p></li><li><p>Rolan 支持多种呼出与隐藏方式：贴边吸附、键盘热键和鼠标中键。</p></li></ul><h3 id="Ditto"><a href="#Ditto" class="headerlink" title="Ditto"></a>Ditto</h3><p><a href="http://ditto-cp.sourceforge.net/" target="_blank" rel="external">官网</a></p><p>简评：Ditto 是 Windows 下一款免费开源的剪贴板增强软件，支持 64 位操作系统，支持中文，并且提供免安装的便携版。使用它，只需像往常一些复制东西，然后按下<code>Ctrl</code>+<code>~</code> （数字 1 左边那个按键），就可以唤出它的界面了，里面记录了所有的复制内容，你可以选择性进行粘贴，非常的方便</p><p><img src="http://c1oudust-blog.test.upcdn.net/20182Ditto.png" alt=""></p><ul><li>支持剪贴板搜索功能</li><li>合并粘贴： Ditto 可以使用 <code>Ctrl</code> 或 <code>Shift</code> 选择多条记录，然后一次性粘贴出来</li></ul><blockquote><h2 id="五-视频"><a href="#五-视频" class="headerlink" title="五.视频"></a>五.视频</h2></blockquote><h3 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a>FFmpeg</h3><p><a href="http://ffmpeg.org/" target="_blank" rel="external">官网</a></p><p>简评：FFmpeg 是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。<br>跨平台，支持几乎所有格式的视频记录、转码，支持按帧转换视频<br>具体教程酷参照简书的这篇<a href="http://t.cn/RRtCN1F" target="_blank" rel="external">文章</a>。</p><h3 id="PotPlayer"><a href="#PotPlayer" class="headerlink" title="PotPlayer"></a>PotPlayer</h3><p><a href="http://ffmpeg.org/" target="_blank" rel="external">官网</a></p><p><img src="http://c1oudust-blog.test.upcdn.net/20182potplayer.png" alt=""><br>简评：KMPlayer 原作者姜勇囍离开并进入新公司 Daum 之后，推出了新一代的作品。无论性能、兼容性和稳定性上的表现均比 KMP 要好不少。</p><p>PotPlayer 内置了非常全面且兼容性良好的视频音频解码器，因此用户无需进行任何手动配置，即可以直接播放几乎目前网络上所有主流的视频音频格式文件。</p><p>PotPlayer 的配置选项非常丰富，各种功能也非常强大，对字幕文件的支持也非常好。</p><h3 id="OBS-Studio"><a href="#OBS-Studio" class="headerlink" title="OBS Studio"></a>OBS Studio</h3><p><a href="https://obsproject.com/" target="_blank" rel="external">官网</a></p><p><img src="http://c1oudust-blog.test.upcdn.net/20182OBSStudio.png" alt=""></p><p>简评：OBS Studio 是一款可以生成视频媒体流以供直播的软件，同样可以用来录制高清视频。很专业很强大，OBS 的<a href="http://t.cn/RiiOk6e" target="_blank" rel="external">贴吧</a>有很具体的使用教程。</p><h3 id="Bandicam"><a href="#Bandicam" class="headerlink" title="Bandicam"></a>Bandicam</h3><p><a href="https://www.bandicam.cn/" target="_blank" rel="external">官网</a></p><p><img src="http://c1oudust-blog.test.upcdn.net/20182Bandicam.png" alt=""></p><p>简评：Bandicam 是本人比较喜欢的录制视频的软件。它录制的视频文件不仅体积小，而且画质相当清晰，支持 H.264 预制高清，以较高的压缩率可录制超过分辨率高达 2560×1600 高画质视频（1080p 全高清视频），录制的同时还能添加水印到视频中，录制后支持编辑视频，支持 bmp、png 、jpeg 等格式截图。</p><blockquote><h2 id="六-文本编辑"><a href="#六-文本编辑" class="headerlink" title="六.文本编辑"></a>六.文本编辑</h2></blockquote><h3 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h3><p><a href="https://atom.io/" target="_blank" rel="external">官网</a></p><p>简评：Atom 是 GitHub 官方推出，称为“21 世纪”的代码编辑器。</p><p>它开源免费跨平台，并且整合 GIT 并提供类似 SublimeText 的包管理功能，可配置性非常高，可以非常方便地安装和管理各种插件，将 Atom 打造成真正适合自己的开发工具。</p><p>其他编辑器比如 ST3 拥有的插件，它几乎都有。本人现在就在用它的 Markdowm Preview 功能写文章。<br><img src="http://c1oudust-blog.test.upcdn.net/20182atom.png" alt=""></p><p>网上关于 Atom 配置的教程很多，关于配置和插件可以参照知乎上的<a href="http://t.cn/RVzYVUg" target="_blank" rel="external">回答</a>和简书的这篇<a href="http://t.cn/RRtlZm8" target="_blank" rel="external">文章</a></p><blockquote><h2 id="七-压缩软件"><a href="#七-压缩软件" class="headerlink" title="七.压缩软件"></a>七.压缩软件</h2></blockquote><h3 id="Bandzip"><a href="#Bandzip" class="headerlink" title="Bandzip"></a>Bandzip</h3><p><a href="http://www.bandisoft.com/" target="_blank" rel="external">官网</a></p><p>简评：虽然 7-Zip 是开源免费压缩工具中的佼佼者，但个人觉得跟 Bandzip 相比还是有些不太顺手。Bandizip 是一款来自韩国的免费优秀的文件压缩/解压缩软件，支持 Win 与 Mac(Mac 版需要付费)，纯净，无广告。</p><p><img src="http://c1oudust-blog.test.upcdn.net/20182bandzip.png" alt=""></p><ul><li><p>界面非常简洁干净，布局和 WinRAR、7-Zip 等同类工具基本一致。Bandizip 同样支持文件右键菜单快速压缩/解压缩文件和文件夹，甚至还可以在右键菜单上快速预览压缩包里的文件列表。</p></li><li><p>实用的快速预览查看压缩包里的图片照片功能。<br>Bandizip 可以直接对压缩包里的图片进行快速预览，不但可以一张张连续番·习页，而且还支持预览加了密码的压缩包。(当然你要知道密码(～￣ ▽ ￣)～ )</p></li></ul><p>本人现在正在使用的比较不错的软件就以上这些了，如果以后碰到其他好用的，会继续补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/20182windows_software.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="软件" scheme="http://Cloudust.coding.me/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Windows" scheme="http://Cloudust.coding.me/source/tags/Windows/"/>
    
      <category term="安利" scheme="http://Cloudust.coding.me/source/tags/%E5%AE%89%E5%88%A9/"/>
    
  </entry>
  
  <entry>
    <title>个人电脑实用软件汇总——Windows(一)</title>
    <link href="http://Cloudust.coding.me/blog/%E4%B8%AA%E4%BA%BA%E7%94%B5%E8%84%91%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%B1%87%E6%80%BB%E2%80%94%E2%80%94Windows(%E4%B8%80)20180205/"/>
    <id>http://Cloudust.coding.me/blog/个人电脑实用软件汇总——Windows(一)20180205/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2018-11-03T05:25:05.100Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h2 id="零-前言"><a href="#零-前言" class="headerlink" title="零.前言"></a>零.前言</h2></blockquote><p>题目中的实用软件并不包括常用软件，只是对个人认为比较好用的软件进行一次汇总。</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20182windows_software.jpg" alt=""><br><a id="more"></a></div></p><blockquote><h2 id="一-浏览器"><a href="#一-浏览器" class="headerlink" title="一.浏览器"></a>一.浏览器</h2></blockquote><h3 id="1-Chromium"><a href="#1-Chromium" class="headerlink" title="1. Chromium"></a>1. Chromium</h3><p><a href="http://www.chromium.org/" target="_blank" rel="external">官网</a></p><p>开源+谷歌——双重信仰加成的浏览器。当然，就算抛开信仰加成，其自身的质量也是相当高。优秀的性能加上丰富的插件，造就的是精简而又强大的浏览利器。另外，它的同步功能也十分好用，只要登录 Google 帐号即可同步书签、历史、主题等，甚至能直接帮你装好扩展。<br>在 Linux 系统上 Chromium 还能享受特殊 buff 加成：只需要在设置里将样式选项改为 GTK+ 即可继承 GTK+ 主题。颜值飙升的同时也与系统完美融合。</p><h3 id="2-Vivaldi"><a href="#2-Vivaldi" class="headerlink" title="2. Vivaldi"></a>2. Vivaldi</h3><p><a href="https://vivaldi.com" target="_blank" rel="external">官网</a></p><p>这是 Opera 制作的基于 Chromium 的浏览器。在 Chromium 的基础上增添了很多实用的功能。<br>比如分页堆叠、支持自定义的手势、方便的“笔记”还有一个能方便搜索书签、历史以及浏览器功能的搜索条。<br>在外观方面虽然看起来没有那么简洁，但效果也不错。而且不仅仅是主题颜色，包括地址栏、标签栏位置等可以看见的大部分内容都可以自定义。</p><h3 id="3-Firefox"><a href="#3-Firefox" class="headerlink" title="3. Firefox"></a>3. Firefox</h3><p><a href="http://www.firefox.com.cn/" target="_blank" rel="external">官网</a></p><p>之前一直在用的浏览器，同样拥有大量的插件，也是个非常优秀的浏览器。<br>不过最后实在受不了各种小毛病，我还是转到 Chromium 了。<br>不过最近听说 Firefox Quantum 的性能超了 Chrome 很多，看来翻身的可能性挺高的。等正式更新之后我可能会试着用回 Firefox。</p><h3 id="Yandex"><a href="#Yandex" class="headerlink" title="Yandex"></a>Yandex</h3><p><a href="https://browser.yandex.com/" target="_blank" rel="external">官网</a></p><p>基于 chrome 内核的浏览器，外观简洁。拥有各种功能齐全强大的俄罗斯本土搜索引擎，个性的是它的搜索条目，对于某些内容真的是毫无限制，应有尽有，注意身体健康，不要超速。<br><del>个人认为最实用的安卓浏览器之一</del>，支持桌面 chrome 和 opera 的扩展，手机上可以用油猴的脚本了！<br>更重要的一点是，有 WP 的客户端，而且是超级良心的 WP 应用。</p><blockquote><h2 id="二-浏览器扩展"><a href="#二-浏览器扩展" class="headerlink" title="二.浏览器扩展"></a>二.浏览器扩展</h2></blockquote><p>使用 Chrome 等浏览器的原因不仅仅是因为它的快速，其所具有的插件功能可以带给用户更棒的体验，</p><h3 id="1-Lastpass"><a href="#1-Lastpass" class="headerlink" title="1. Lastpass"></a>1. Lastpass</h3><p><a href="http://t.cn/RQxSTZ8" target="_blank" rel="external">官网</a></p><p>极其好用的免费密码管理软件。我几乎所有密码都由 lastpass 生成并存放在里面。这个扩展是我每次安装浏览器时最先安装的扩展，没有这个软件我连 Google 帐号都登不上。<br>我使用 lastpass 不仅仅因为安全，lastpass 的自动填写帐号密码以及表单功能也非常方便，免去了手动输入的痛苦。<br>当然也有收费版本，不过免费版的功能已经极大满足我的个人需求了。</p><h3 id="2-OneTab"><a href="#2-OneTab" class="headerlink" title="2. OneTab"></a>2. OneTab</h3><p><a href="http://t.cn/RiZBoVy" target="_blank" rel="external">官网</a></p><p>OneTabs 插件用于临时保存网站，它会先把现有的标签页都缓存起来，然后弹出只有一个恢复窗口的新标签页，在这个 OneTab 插件的标签页中用户可以选择恢复其中有用的 Chrome 标签页而放弃其他应该关闭的标签页，也可以需要关闭浏览器的时候，将想要下次继续看的网站用保存下来，以便下次启动浏览器继续打开，可以释放大量浏览器所占的内存。<br>在恢复标签页的时候，OneTab 插件会以新标签页的方式去恢复</p><h3 id="3-Tampermonkey"><a href="#3-Tampermonkey" class="headerlink" title="3. Tampermonkey"></a>3. Tampermonkey</h3><p><a href="http://t.cn/zTYhW3p" target="_blank" rel="external">官网</a></p><p>油猴本体并没有什么特别的功能，它更像是个承载脚本的容器。通过各式各样的脚本对不同的网站进行自定义，从而实现各种实用功能。</p><ul><li><p><a href="http://t.cn/R08TpdG" target="_blank" rel="external">Userscript+</a><br>油猴的大多数脚本需要在 Greasyfork 或 OpenUserJS 下载，不过很多时候，我们并不知道一些网站是否有用户提供用来优化页面的脚本。这个插件的作用就是，只要打开网页，Userscript+ 就会在网页右下角显示当前网页可用的脚本数，并默认按照评分高低排序推荐给你，并且可以一键安装指定的脚本。<br>当然这个插件也有它蛋疼的地方，比如说没法查看是否已经安装了某个插件。</p></li><li><p><a href="http://t.cn/RCtIz6k" target="_blank" rel="external">大人的 Greasyfork</a><br>在 Greasyfork 的搜索结果中添加 Sleazyfork 上的成人脚本，增加评分与版本号，并在访问匿名不可用脚本时跳转至 Sleazyfork。</p></li><li><p><a href="http://t.cn/RQxSHfW" target="_blank" rel="external">AC-baidu： 优化百度、搜狗、谷歌搜索结果之重定向去除+去广告+favicon</a><br>十分好用的插件: 1.绕过百度、搜狗、谷歌、好搜搜索結果中的自己的跳转，直接访问原始网页 2.去除百度的多余广告 3.添加 Favicon 显示 4.页面 CSS 5.添加计数 6.开关选择以上功能</p></li><li><p><a href="http://t.cn/RaOQN0E" target="_blank" rel="external">EX-百度云盘</a><br>个人认为的针对百度云盘最好用的脚本。解除大文件下载限制，提取直链，支持文件夹下载、多文件下载以及批量复制下载。配合第三方下载器</p></li><li><p><a href="http://t.cn/RQxSH4m" target="_blank" rel="external">解除 B 站区域限制</a><br>通过替换获取视频地址接口的方式, 实现解除 B 站区域限制。国家队、目隐都市的演绎者、进击的巨人第二季可以在 B 站看了！</p></li><li><p><a href="http://t.cn/RQxSHGa" target="_blank" rel="external">bilibili merged flv+mp4+ass+enhance</a><br>在 bilibili 视频的播放数统计旁边添加：超清 FLV 下载，FLV 合并，原生 MP4 下载，ASS 弹幕下载。附带一些小改进：双击全屏，自动滚动到播放器，自动防挡字幕，跳过片头片尾，获取封面，等等。</p></li><li><p><a href="http://t.cn/R8WlAZr" target="_blank" rel="external">B 站直播硬币兑换瓜子翻倍|Bilibili 直播</a><br>通过旧兑换接口，获得双倍银瓜子(1:900)(老爷 1:1000)，每日上限 10(老爷 20)硬币，配合 700:1 换硬币，刷瓜子</p></li><li><p><a href="http://t.cn/RYQWxb1" target="_blank" rel="external">Endless Google</a><br>无需手动点击 Google 搜索结果中「下一页」，实现自动翻页显示搜索内容。</p></li><li><p><a href="http://t.cn/R8WHQHL" target="_blank" rel="external">Giveaway Helper</a><br>一键完成各个免费 steam key 网站任务的脚本。</p></li><li><p><a href="http://t.cn/RChp86S" target="_blank" rel="external">视频站启用 html5 播放器</a><br>拥抱 html5，告别 Flash。添加快捷键：快进、快退、暂停/播放、音量、下一集、切换[万能网页]全屏、上下帧、播放速度。<br>支持站点：优.土、QQ、新浪、微博、网易视频[娱乐、云课堂、新闻]、搜狐、乐视、央视、风行、百度云视频、熊猫、龙珠、战旗直播等，可自定义站点。</p></li><li><p><a href="http://t.cn/RQxSH6T" target="_blank" rel="external">网页限制解除(改)</a><br>通杀大部分网站，可以解除禁止复制、剪切、选择文本、右键菜单的限制。原作者 cat73，因为和搜索跳转脚本冲突，遂进行了改动，改为黑名单制。</p></li><li><p><a href="http://t.cn/R8W8HXQ" target="_blank" rel="external">琉神转</a><br>老司机工具箱，支持(此处省略)等，神秘代码转换成下载链接，网盘自动填写提取密码，F8、Shift+F8 站点切换，Alt+F8 列表浏览，左右方向键文章跳转，Ctrl+左右快捷翻页，Ctrl+上下跳入跳出，下载链接嗅探，绕过重定向跳转，各种和谐补丁</p></li><li><p><a href="http://t.cn/R8WTQIk" target="_blank" rel="external">CNKI 中国知网 PDF 全文下载（特制版）</a> 1.优化了中国知网的文献检索结果列表，可以直接点击下载 PDF 文件(前提是你有下载权限) 2.在博士/硕士学位论文详细信息界面添加了「PDF 下载」按钮，实现了博士/硕士学位论文的 PDF 下载功能。</p></li><li><p><a href="http://t.cn/RqWdybS" target="_blank" rel="external">YouTube +</a><br>可以给 Youtube 增加更多的功能选项，包括小窗口播放视频、播放您最近订阅播放列表、视频截图保存、只允许你订阅频道的视频播放广告等等，只适用于 HTML5 播放器。</p></li><li><p><a href="http://t.cn/RALBveM" target="_blank" rel="external">右键在新标签中打开图片时显示最优化图像质量</a><br>帮助用户在新标签页打开的图片自动切换为高质量原图，脚本任何使用 Google、、、微博、豆瓣等网站的服务器作为存储的图片，都可以定位到图像最高质量上。</p></li></ul><h3 id="3-Stylish"><a href="#3-Stylish" class="headerlink" title="3. Stylish"></a>3. Stylish</h3><p><a href="http://t.cn/R7IxUF5" target="_blank" rel="external">官网</a></p><p>对网页进行美化的扩展，有点类似油猴。只要点击扩展按钮即可查看当前页面可用的样式。并且也能一键安装。</p><ul><li><p><a href="http://t.cn/RQxSQJL" target="_blank" rel="external">Github Dark Material</a> ：Github 的黑色质感主题。</p></li><li><p><a href="http://t.cn/RQxSQRL" target="_blank" rel="external">Google Material</a> ：虽然原本的 Google 已经挺好看的，不过我还是更喜欢这个样式。</p></li><li><p><a href="http://t.cn/RqCdmnb" target="_blank" rel="external">百度轻</a> ：能让百度用上 Material Design 颜值瞬间提示，虽然我挺少用百度的……顺带一提，这个还有去广告的功能。</p></li><li><p><a href="http://t.cn/RT4iTuI" target="_blank" rel="external">Flat-Zhihu</a> ：扁平化的知乎。</p></li><li><p><a href="http://t.cn/RIRJrU8" target="_blank" rel="external">Bilibili 哔哩哔哩 Nekopara</a>：哔哩哔哩艹猫样式</p></li></ul><h3 id="4-Image-Search-Options"><a href="#4-Image-Search-Options" class="headerlink" title="4. Image Search Options"></a>4. <a href="http://t.cn/zliYG1b" target="_blank" rel="external">Image Search Options</a></h3><p>以图搜图的右键菜单插件，支持多个网站并可以自定义</p><h3 id="5-右键搜"><a href="#5-右键搜" class="headerlink" title="5. 右键搜"></a>5. <a href="http://t.cn/8stRzct" target="_blank" rel="external">右键搜</a></h3><p>扩展右键菜单，超过 300 种功能，方便的选择、组合或自定义页面、划词、图片菜单，并有生成、解析二维码和短网址功能。设置可使用云存储。最新增加功能共享、资源下载、重命名等功能。其中右键生成文字、当前网址、链接的二维码的功能是我比较常用的。</p><h3 id="6-Infinity-新标签页"><a href="#6-Infinity-新标签页" class="headerlink" title="6. Infinity 新标签页"></a>6. <a href="http://t.cn/RTYsc42" target="_blank" rel="external">Infinity 新标签页</a></h3><p>可以把 Chrome 默认新标签页换成一个美观实用的 infinity 新标签页。页面美观，可自定义壁纸，图标等，还有快速拨号，邮件提醒，天气预报，笔记功能，待办事项，壁纸，历史记录管理等功能。支持登录账号一键同步。<br>可以在浏览器设置里把 Infinity 设置为启动页面，比导航网站美观！</p><h3 id="7-Adblock-Plus"><a href="#7-Adblock-Plus" class="headerlink" title="7. Adblock Plus"></a>7. <a href="http://t.cn/zlDZ0q6" target="_blank" rel="external">Adblock Plus</a></h3><p>简单的去广告扩展,功能却非常强大，浏览器必备。</p><h3 id="8-FireShot"><a href="#8-FireShot" class="headerlink" title="8. FireShot"></a>8. <a href="http://t.cn/RMmA2Ac" target="_blank" rel="external">FireShot</a></h3><p>FireShot 是个人认为最好用的截图插件之一，支持滚动截图，一键分享，导出为多格式，在线编辑后保存等等。</p><h3 id="9-哔哩哔哩助手：bilibili-com-综合辅助扩展"><a href="#9-哔哩哔哩助手：bilibili-com-综合辅助扩展" class="headerlink" title="9. 哔哩哔哩助手：bilibili.com 综合辅助扩展"></a>9. <a href="http://t.cn/RyXFwr6" target="_blank" rel="external">哔哩哔哩助手：bilibili.com 综合辅助扩展</a></h3><p>哔哩哔哩助手对哔哩哔哩进行了很多扩展，包括一键签到，自动领瓜子，抽奖提醒，自动调整视频位置，获取视频下载链接等等，同时加入右键快捷搜索选项。</p><h3 id="10-ChaZD"><a href="#10-ChaZD" class="headerlink" title="10. ChaZD"></a>10. <a href="http://t.cn/R5Pdoby" target="_blank" rel="external">ChaZD</a></h3><p>ChaZD 是一款风格简洁，灵巧易用的英汉字典扩展程序，支持英、美两种语言发音，并提供在线划词翻译，可自定义快捷键。</p><h3 id="11-Decentraleyes"><a href="#11-Decentraleyes" class="headerlink" title="11. Decentraleyes"></a>11. <a href="http://t.cn/RQxSEvd" target="_blank" rel="external">Decentraleyes</a></h3><p>Decentraleyes 的原理跟 Web Boost 的原理差不多，都是事先将一些第三方库文件在本地加载，当打开网页遇到使用其他第三方库文件时，马上进行拦截并从本地进行加载，这样就可以大大地提高网页的加载速度，特别是在中国。除此之外，还可以帮你减少一些跟踪脚本的跟踪功能，让你上网更加安全一些。</p><h3 id="12-Insight-io-for-Github"><a href="#12-Insight-io-for-Github" class="headerlink" title="12. Insight.io for Github"></a>12. <a href="http://t.cn/RKognSU" target="_blank" rel="external">Insight.io for Github</a></h3><p>浏览托管在 Github 上的项目，更方便查看代码。提供以下功能：</p><ul><li>跳转到定义</li><li>查找引用</li><li>目录树功能</li><li>基于符号的代码搜索</li></ul><h3 id="11-Mobius"><a href="#11-Mobius" class="headerlink" title="11. Mobius"></a>11. <a href="http://t.cn/RQxSE27" target="_blank" rel="external">Mobius</a></h3><p>在网页右上角添加一个“小地图”，可以简单预览整个网页。在鼠标指针移动到小地图上时页面会滚动到相应的位置。按快捷键 <code>Ctrl</code>+<code>Shift</code>+<code>F</code> 可以开关。</p><h3 id="12-简悦-SimpRead"><a href="#12-简悦-SimpRead" class="headerlink" title="12.简悦- SimpRead"></a>12.<a href="http://t.cn/R0Z8mOh" target="_blank" rel="external">简悦- SimpRead</a></h3><p>简悦初衷是还原阅读本质，提升阅读体验。从名字也可以看出简单、愉悦，使用后能令 Chrome 带来如 Safari 中的阅读模式一样的完美体验。<br>主要功能点：</p><ul><li>阅读模式<br>逐一适配了 120+ 个网站，并提取 标题 描述 正文 媒体资源（ 图片/ 视频 ） 等，生成 符合中文阅读 的页面</li><li>聚焦模式<br>只高亮需要阅读，并隐藏掉其余部分，不分散用户的注意力，适合 非适配阅读模式 的网站，或者 临时阅读</li><li>可编程的站点编辑器<br>可编程，定制化</li><li>多种主题<br>白练、白磁、卯之花色、丁子色、娟鼠、月白、百合、紺鼠、黒鸢 等</li><li>同步、上传/下载 配置、同步适配列表等</li></ul><blockquote><h2 id="三-下载工具"><a href="#三-下载工具" class="headerlink" title="三.下载工具"></a>三.下载工具</h2></blockquote><h3 id="Internet-Download-Manager"><a href="#Internet-Download-Manager" class="headerlink" title="Internet Download Manager"></a>Internet Download Manager</h3><p><a href="http://www.internetdownloadmanager.com/" target="_blank" rel="external">官网</a></p><p>简评：IDM 是 Windows 平台老牌而功能强大的下载工具，软件支持多款浏览器。同时支持多线程、多媒体下载、自动捕获链接、自动识别文件名、静默下载、批量下载、计划下载任务、站点抓取、队列与网盘支持等。<br>速度比迅雷快了不知多少，同时配合插件可以下载度盘的文件了。</p><h3 id="Persepolis-Download-Manager"><a href="#Persepolis-Download-Manager" class="headerlink" title="Persepolis Download Manager"></a>Persepolis Download Manager</h3><p><a href="https://persepolisdm.github.io/" target="_blank" rel="external">官网</a></p><p>Persepolis 是一款基于 aria2 的开源下载工具。<br>支持 HTTP / FTP / BT / Magnet 磁力链接等类型的文件下载<br>更多的介绍以及用法参考<a href="https://www.iplaysoft.com/persepolis-download-manager.html" target="_blank" rel="external">异次元软件</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h2 id=&quot;零-前言&quot;&gt;&lt;a href=&quot;#零-前言&quot; class=&quot;headerlink&quot; title=&quot;零.前言&quot;&gt;&lt;/a&gt;零.前言&lt;/h2&gt;&lt;/blockquote&gt;
&lt;p&gt;题目中的实用软件并不包括常用软件，只是对个人认为比较好用的软件进行一次汇总。&lt;/p&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/20182windows_software.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="软件" scheme="http://Cloudust.coding.me/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Windows" scheme="http://Cloudust.coding.me/source/tags/Windows/"/>
    
      <category term="安利" scheme="http://Cloudust.coding.me/source/tags/%E5%AE%89%E5%88%A9/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的rEFind引导Windows10+Ubutnu双系统教程</title>
    <link href="http://Cloudust.coding.me/blog/rEFind%E5%BC%95%E5%AF%BCWindows10+Ubutnu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B20180129/"/>
    <id>http://Cloudust.coding.me/blog/rEFind引导Windows10+Ubutnu双系统教程20180129/</id>
    <published>2018-01-28T16:00:00.000Z</published>
    <updated>2018-11-03T05:24:34.307Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><br><img src="http://c1oudust-blog.test.upcdn.net/year-month_xiaoguotu.png" alt=""><br><br></div><a id="more"></a><ul><li><h3 id="准备工具："><a href="#准备工具：" class="headerlink" title="准备工具："></a>准备工具：</h3><pre><code>*  重新安装windows则需要下载：   国人收集的windows原版镜像 http://www.itellyou.cn/   微软官网 https://www.microsoft.com/zh-cn/software-download/windows10*  Ubuntu镜像 https://www.ubuntu.com/download*  U盘，做PE和系统盘。当然不用PE也可以完成安装流程。    制作系统启动盘，用软碟通刻录或者直接将镜像解压至U盘。    教程参考 https://jingyan.baidu.com/article/d713063568b20413fdf4752c.html    推荐微PE工具箱（很纯净并支持uefi启动）http://www.wepe.com.cn/download.html*  refind文件下载    官网：http://www.rodsbooks.com/refind/    我已经配置好的（带主题）：链接：https://pan.baidu.com/s/1bzSbr4 密码：5sak*  DiskGenius软件：网上可以找到，这里提供一个 http://www.upantool.com/qidong/2012/DiskGenius_3.7.1.html    Bootice或EasyUEFI工具 网上都能找到。这里提供一个 http://www.ipauly.com/2015/11/15/bootice/</code></pre></li></ul><ul><li><h3 id="安装-win10-并给-Ubuntu-分区"><a href="#安装-win10-并给-Ubuntu-分区" class="headerlink" title="安装 win10 并给 Ubuntu 分区"></a>安装 win10 并给 Ubuntu 分区</h3><pre><code>安装win10的教程网上很多，在这里就不多加赘述了。如果电脑中已有win10，那么请直接分区。现在我们给Ubuntu系统分出预留的硬盘空间以便于后续安装* 方法一：使用PE里的DiskGenius或者直接使用DiskGenius已经装好PE的U盘插到电脑上，U盘启动，一般的电脑都有热键，在机子重启时，按下f12（一般lenovo，Dell的为f12，华硕的为Esc，战神等f7，自己可以百度电脑型号），进入选择界面后选择U盘（一般名字是你的U盘品牌）可以直接Enter进入，一些机子是要设置U盘为第一启动项才能进入。进入PE系统后打开分区管理工具DiskGenius，—如果你不想保留电脑里的东西可以直接删除所有分区，选择你的硬盘右键选择转换分区表类型为GUID格式并保存，再选择快速分区（最主要的是ESP分区，为启动分区），自己分区，可以现在就留出ubuntu的安装位置，（最小为8G，推荐一般50G）,分好区后把预留ubuntu的分区右键删除当前分区留空（因为linux的文件系统不同于windows，留空以后安装ubuntu）。进入电脑的bios，开启UEFI（具体百度，一般很简单，都有自己机子的教程）。* 方法二：安装win10后使用windows自带的磁盘管理工具（右键我的电脑&gt;管理&gt;磁盘管理）压缩出一个新的分区，删除卷，留给ubuntu一块未分配的空间（最小为8G，推荐一般50G）&lt;div align=center&gt;</code></pre><p><img src="http://c1oudust-blog.test.upcdn.net/year-month_fenqu.png" alt=""></p><p><br>&emsp;&emsp;&emsp; 图文教程参照： <a href="http://jingyan.baidu.com/article/7f766dafbbcdf34100e1d049.html" target="_blank" rel="external">http://jingyan.baidu.com/article/7f766dafbbcdf34100e1d049.html</a><br><br>&emsp; &emsp; &emsp; 进入bios里关闭sectrue boot，（如果开了sectrue boot就只能安装windows，所以要关闭），具体可以百度</p></li></ul><ul><li><h3 id="安装-ubuntu"><a href="#安装-ubuntu" class="headerlink" title="安装 ubuntu"></a>安装 ubuntu</h3><pre><code>进入电脑BIOS设置U盘为第一启动项。插入U盘启动盘，重启电脑进入GRUB界面，选择Install Ubuntu进入安装ubuntu界面,选择中文简体.&lt;div align=center&gt;</code></pre><img src="http://c1oudust-blog.test.upcdn.net/year-month_ubuntu_grhub.png" alt=""></li></ul><p><img src="http://c1oudust-blog.test.upcdn.net/year-month_ubuntu_install1.png" alt=""></p><p><br>&emsp;&emsp;&emsp; 安装类型选择其他选项，继续</p><p><img src="http://c1oudust-blog.test.upcdn.net/year-month_ubuntu_install2.png" alt=""></p><p>&emsp;&emsp;&emsp; 选择之前留空的分区点加号，先给 200M 的/boot 分区</p><p><img src="http://c1oudust-blog.test.upcdn.net/year-month_ubuntu_install3.png" alt=""></p><p>&emsp;&emsp;&emsp; 确定后，再次选择剩余留空的分区再点加号，交换空间（swap 分区）给自己电脑内存大小的 2 倍空间，一般电脑为 4G，所以就给 8G 的交换空间。（图中虚拟机的内存为 2G，因此分配 4G 即 4096MB）</p><p><img src="http://c1oudust-blog.test.upcdn.net/year-month_ubuntu_install4.png" alt=""></p><p>&emsp;&emsp;&emsp; 确定后，再次选择剩余留空的分区再点加号，接下来把剩下的所有空间全划给 /</p><p><img src="http://c1oudust-blog.test.upcdn.net/year-month_ubuntu_install5.png" alt=""></p><p>&emsp;&emsp;&emsp; 注意底下的安装启动引导器的设备，选择安装 windows 系统的硬盘或者固态，即/dev/sda。（通常要用 ubuntu 引导器代替 windows 引导器选/dev/sda，要保留 windows 引导器选/boot 区装完 ubuntu 重启能进 windows，在 windows 下使用软件添加 ubuntu 启项）<br>确定分区，就会进行格式化，接下来就会安装 ubuntu 系统，选择汉语，设置用户与密码。继续，等待安装完成</p><p><img src="http://c1oudust-blog.test.upcdn.net/year-month_ubuntu_install6.png" alt=""></p><p><img src="http://c1oudust-blog.test.upcdn.net/year-month_ubuntu_install7.png" alt=""></p><p><img src="http://c1oudust-blog.test.upcdn.net/year-month_ubuntu_install8.png" alt=""></p><p><img src="http://c1oudust-blog.test.upcdn.net/year-month_ubuntu_install9.png" alt=""></p><p>&emsp;&emsp;&emsp; 安装好 ubuntu 后，第一次重启是一般会出现下图的 GRUB 引导界面，可以选择 Windows 或者 Ubuntu 进去，在这里 我们可以进入 windows 或者 Ubuntu，在两个系统下都可以安装 refind 引导。这里我们进入 windows 系统，选择 Windows Boot Manager 进入。顺便一提，Linux 下安装 refind 的方法较 Windows 更简单。不过对于新手，还是建议使用 Windows 图形界面安装。如果您感兴趣也可以进入 Ubuntu 安装，方法会在之后讲到</p><p><img src="http://c1oudust-blog.test.upcdn.net/year-month_ubuntu_grhub2.png" alt=""></p><ul><li><h3 id="Refind-的安装与配置"><a href="#Refind-的安装与配置" class="headerlink" title="Refind 的安装与配置"></a>Refind 的安装与配置</h3><pre><code>* windows下：    首先我们需要挂载efi分区以方便将refind放进其中    + 方法一：        打开终端（win+R，输入cmd），输入mountvol z: /s  之后输入mountvol  会提示已经挂载至Z：        ![]( http://c1oudust-blog.test.upcdn.net/year-month_guazai.png)    + 方法二：        进入windows系统后安装DiskGenius或者用PE系统的DiskGenius，选择ESP分区右键指派新的驱动器号，选择一个电脑本身没有的盘符，确定。        ![]( http://c1oudust-blog.test.upcdn.net/year-month_diskgenius.png)        这样我们打开我的电脑。就能看到之前挂载的efi分区了        ![]( http://c1oudust-blog.test.upcdn.net/year-month_mycomputer.png)        打开该磁盘，如果提示没有访问权限，请使用管理员权限打开文件管理器。建议在PE下进行挂载和安装refind操作或者使用DiskGenius软件访问ESP分区，把refind文件夹里的文件复制进去。注意，DiskGenius中只能复制文件不能复制文件夹，所以文件夹还需要在DiskGenius中自行新建，然后右键复制文件到当前分区，选择refind文件夹里的文件即可。        将refind文件夹放入EFI中后如图        ![]( http://c1oudust-blog.test.upcdn.net/year-month_diskgenius2.png)        使用Bootice或者EasyUEFI工具将refind添加至引导项，这里使用Bootice。打开Bootice，选择UEFI，更改启动序列。添加，选择EFI文件夹里refind中的refind_x64.efi，更改名字为refind，并将该启动项上移至第一位。保存启动项。        ![]( http://c1oudust-blog.test.upcdn.net/year-month_find_refindx64.png)        ![]( http://c1oudust-blog.test.upcdn.net/year-month_boot_change.png)        重启电脑，就能看到如效果图所示的引导界面了。        ![效果图]( http://c1oudust-blog.test.upcdn.net/year-month_xiaoguotu.png &quot;效果图&quot;)* Linux下：</code></pre><p>下载 refind 安装包后解压，进入解压后的文件夹，运行下列命令<br>sudo bash refind-install<br>重启安装成功，同时需要设置 refind 为第一启动项。<br>重启进入 refind 引导界面。<br>关机重启时就出现系统选择界面。以上就完成了用 refind 引导 windows10+ubutnu 双系统。</p></li><li><p>注：某些机型可能需要在 BIOS 里修改第一启动项为 refind，用第三方软件无效。</p></li></ul><ul><li><h3 id="关于在-refind-选择-Ubuntu-后又进入-grub-引导页面的处理方法："><a href="#关于在-refind-选择-Ubuntu-后又进入-grub-引导页面的处理方法：" class="headerlink" title="关于在 refind 选择 Ubuntu 后又进入 grub 引导页面的处理方法："></a>关于在 refind 选择 Ubuntu 后又进入 grub 引导页面的处理方法：</h3><pre><code>在Ubuntu在打开终端：输入 sudo gedit /etc/default/grub  打开编辑器找到下面两句GRUB_HIDDEN_TIMEOUT=0GRUB_TIMEOUT=3将后面的数值均改为0然后 sudo update-grub</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/year-month_xiaoguotu.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="系统" scheme="http://Cloudust.coding.me/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Ubuntu" scheme="http://Cloudust.coding.me/source/tags/Ubuntu/"/>
    
      <category term="Windows" scheme="http://Cloudust.coding.me/source/tags/Windows/"/>
    
      <category term="双系统" scheme="http://Cloudust.coding.me/source/tags/%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>起初</title>
    <link href="http://Cloudust.coding.me/blog/Lared20171029/"/>
    <id>http://Cloudust.coding.me/blog/Lared20171029/</id>
    <published>2017-10-29T11:48:23.384Z</published>
    <updated>2018-01-28T07:18:57.141Z</updated>
    
    <content type="html"><![CDATA[<p><center>欢迎来到我的博客，Lared——鸷鸟栖息之所</center><br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;欢迎来到我的博客，Lared——鸷鸟栖息之所&lt;/center&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
