<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vedfolnir</title>
  <icon>https://www.gravatar.com/avatar/52fb66bdac74c922b9ce4ddd419e8656</icon>
  <subtitle>我们飞翔得越高,在那些不能飞翔的人眼中的形象越渺小</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-27T15:42:45.963Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>C1oudust</name>
    <email>amerkiousy@outlook.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS之BFC的理解</title>
    <link href="http://yoursite.com/blog/CSS%E4%B9%8BBFC%E7%9A%84%E7%90%86%E8%A7%A320200326/"/>
    <id>http://yoursite.com/blog/CSS之BFC的理解20200326/</id>
    <published>2020-03-25T16:00:00.000Z</published>
    <updated>2020-03-27T15:42:45.963Z</updated>
    
    <content type="html"><![CDATA[<style type="text/css">img{text-align: center; margin: 0 auto;}</style><h2 id="什么是-BFC"><a href="#什么是-BFC" class="headerlink" title="什么是 BFC"></a>什么是 BFC</h2><p>Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。</p><blockquote><p>它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p></blockquote><p>而 BFC（Block Formatting Contexts）即块级格式化上下文，是一个块级元素的渲染显示规则，属于元素定位方案中普通流的一种。可以把 BFC 理解为一个封闭的容器，容器里面的子元素不会影响到外面的元素，反之也如此。</p><a id="more"></a><h3 id="元素定位方案"><a href="#元素定位方案" class="headerlink" title="元素定位方案"></a>元素定位方案</h3><p>定位方案是控制元素的布局，常见方案有三种:</p><ul><li><p>普通流 (normal flow)</p><p>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</p></li><li><p>浮动 (float)</p><p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</p></li><li><p>绝对定位 (absolute positioning)</p><p>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定</p></li></ul><h2 id="触发-BFC"><a href="#触发-BFC" class="headerlink" title="触发 BFC"></a>触发 BFC</h2><p>BFC 的布局规则如下：</p><ul><li><p>内部的盒子会在垂直方向，一个个地放置</p></li><li><p>BFC 是页面上的一个隔离的独立容器</p></li><li><p>属于同一个 BFC 的 两个相邻 Box 的 上下 margin 会发生重叠</p></li><li><p>计算 BFC 的高度时，浮动元素也参与计算</p></li><li><p>每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也是如此</p></li><li><p>BFC 的区域不会与 float 重叠</p></li></ul><p>只要元素满足下面任一条件即可触发 BFC 特性：</p><ul><li>body 根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul><h2 id="BFC-特性及应用"><a href="#BFC-特性及应用" class="headerlink" title="BFC 特性及应用"></a>BFC 特性及应用</h2><h3 id="阻止外边距折叠-margin-collapse"><a href="#阻止外边距折叠-margin-collapse" class="headerlink" title="阻止外边距折叠 (margin collapse)"></a><strong>阻止外边距折叠 (margin collapse)</strong></h3><blockquote><p><strong>MDN 关于外边距折叠的定义</strong>：<br>当块级元素 (block) 的上外边距 (margin-top) 和下外边距 (margin-bottom) 同时都有设定时只会只会保留最大边距，这种行为称为边界折叠（margin collapsing），有时也翻译为外边距重叠。</p></blockquote><p>比如以下代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"block top"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"block bottom"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.block</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">background-color</span>: lightblue;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.top</span> &#123;</div><div class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.bottom</span> &#123;</div><div class="line">  <span class="attribute">margin-top</span>: <span class="number">30px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>两个垂直排列的元素，实际在页面上的距离是 30px，而不是 20px + 30px = 50px</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing" target="_blank" rel="external">关于外边距折叠的详细参考</a></p><p>根据 BFC 布局规则的第三条，之所以会发生折叠是因为它们同属于 body 这个根元素。</p><p>那么只需要把两个 div 元素放在不同的 BFC 容器里就可以避免折叠：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"block top"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"block bottom"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>同时，<code>container</code> 类必须加上 <code>overflow: hidden</code> 属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  .container &#123;</div><div class="line">    <span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a><strong>清除浮动</strong></h3><p>正常情况下，浮动的元素会脱离文档流。</p><p>以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.block</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">background</span>: <span class="number">#eee</span>;</div><div class="line">  <span class="attribute">float</span>: left;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://c1oudust-blog.test.upcdn.net/20200320/1.jpg" alt="未清除浮动"></p><p>由于容器内元素浮动，脱离了文档流，所以容器只剩下 <code>2px</code> 的边距高度。如果使触发容器的 <code>BFC</code>，那么容器将会包裹着浮动元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</div><div class="line">  <span class="attribute">overflow</span>: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://c1oudust-blog.test.upcdn.net/20200320/2.jpg" alt="清除浮动"></p><h3 id="阻止元素被浮动元素覆盖"><a href="#阻止元素被浮动元素覆盖" class="headerlink" title="阻止元素被浮动元素覆盖"></a><strong>阻止元素被浮动元素覆盖</strong></h3><p>以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">aside</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</div><div class="line">  <span class="attribute">float</span>: left;</div><div class="line">  <span class="attribute">background</span>: <span class="number">#555555</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">main</span> &#123;</div><div class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">background-color</span>: lightblue;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://c1oudust-blog.test.upcdn.net/20200320/3.jpg" alt="浮动元素覆盖"></p><p>这时候第二个元素有部分被浮动元素所覆盖。</p><p>之所以是这样，是因为规则 5： <code>每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也是如此</code>。</p><p>要想改变效果，使其互不干扰，就得利用规则 6 ：BFC 的区域不会与 float 重叠，在第二个元素的样式中加入 <code>overflow: hidden</code>，就会变成：</p><p><img src="http://c1oudust-blog.test.upcdn.net/20200320/4.jpg" alt="浮动元素覆盖"></p>]]></content>
    
    <summary type="html">
    
      &lt;style type=&quot;text/css&quot;&gt;
img{text-align: center; margin: 0 auto;}
&lt;/style&gt;

&lt;h2 id=&quot;什么是-BFC&quot;&gt;&lt;a href=&quot;#什么是-BFC&quot; class=&quot;headerlink&quot; title=&quot;什么是 BFC&quot;&gt;&lt;/a&gt;什么是 BFC&lt;/h2&gt;&lt;p&gt;Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而 BFC（Block Formatting Contexts）即块级格式化上下文，是一个块级元素的渲染显示规则，属于元素定位方案中普通流的一种。可以把 BFC 理解为一个封闭的容器，容器里面的子元素不会影响到外面的元素，反之也如此。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/source/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://yoursite.com/source/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript之闭包的理解</title>
    <link href="http://yoursite.com/blog/JavaScript%E4%B9%8B%E9%97%AD%E5%8C%85%E7%90%86%E8%A7%A320200316/"/>
    <id>http://yoursite.com/blog/JavaScript之闭包理解20200316/</id>
    <published>2020-03-15T16:00:00.000Z</published>
    <updated>2020-03-16T19:20:02.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是闭包（Closure）"><a href="#什么是闭包（Closure）" class="headerlink" title="什么是闭包（Closure）"></a>什么是闭包（Closure）</h2><a id="more"></a><p>首先来看下列代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> local = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        local++;</div><div class="line">        <span class="built_in">console</span>.log( local );</div><div class="line">    &#125;</div><div class="line"><span class="keyword">return</span> bar;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> func = foo();</div><div class="line">func();</div></pre></td></tr></table></figure><p>在这个例子中，函数 <code>bar()</code> 的词法作用域能够访问 <code>foo()</code> 的内部作用域。然后我们将 <code>bar()</code> 函数本身当作一个值类型进行传递。<br>在 <code>foo()</code>执行后，其返回值（也就是内部的 <code>bar()</code> 函数）赋值给变量 <code>func</code> 并调用 <code>func()</code>，实际上只是通过不同的标识符引用调用了内部的函数 <code>bar()</code>。<br>显然<code>bar()</code>会被正常执行。更进一步地说，它是在自己定义的词法作用域以外的地方执行。</p><p>在 JavaScript 中，因为有垃圾回收器的存在，因此在一个函数被执行后，如果检测到他的内容在之后不会再被使用，那么引擎会考虑对其进行回收。(对于 JavaScript 的垃圾回收，可以参考<a href="https://segmentfault.com/a/1190000015641168" target="_blank" rel="external">这篇文章</a>)</p><p>然而在这个例子中，<code>foo()</code>被执行后，事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？是 <code>bar()</code> 本身在使用。</p><p>拜 <code>bar()</code> 所声明的位置所赐，它拥有涵盖 <code>foo()</code> 内部作用域的闭包，使得该作用域能够一直存活，以供 <code>bar()</code> 在之后任何时间进行引用。</p><p>换句话说，<code>bar()</code> 持有对该作用域的引用，而这个引用就叫作闭包。</p><p>因此，在几微秒之后变量 <code>func</code> 被实际调用，不出意料它可以访问定义时的词法作用域，因此它也可以如预期般访问局部变量 <code>local</code> 。</p><p>这几行代码可能过于复杂，我们可以把它精简成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> local = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( local );</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这三行代码中，<code>bar</code> 可以访问到 <code>local</code> 变量，这就是一个闭包。诚然如此，但我们通常会把这三行代码放在一个函数里。为什么呢？这就涉及到闭包的作用了。</p><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><p>闭包通常用来间接访问一个变量。也就是说，可以隐藏一个变量使它不能被直接访问。</p><p>要想达到这个效果，就可以把这个变量放在一个作用域内，然后单独创建一个对他进行控制的函数，这样我们就只能通过这个函数去访问它。</p><p>这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。</p><p>无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用<br>域的引用，无论在何处执行这个函数都会使用闭包。</p><h2 id="一些理解"><a href="#一些理解" class="headerlink" title="一些理解"></a>一些理解</h2><p>无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一级的值类型并到处传递，就会产生闭包。</p><p>在<code>定时器</code>、<code>事件监听器</code>、<code>Ajax 请求</code>、<code>跨窗口通信</code>、<code>Web Workers</code> 或者任何其他的异步或者同步任务中，只要使用了回调函数，实际上也是在使用闭包。</p><p>比如下列代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;, i * <span class="number">1000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>正常情况下，我们对这段代码行为的预期是依次输出数字 1~5，每秒一次输出一个。但实际上，这段代码在运行时会以每秒一次的频率输出五次 6。</p><p>事实上，当定时器运行时即使每个迭代中执行的是 <code>setTimeout(.., 0)</code>，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个 6 出来。</p><p>但是根据作用域的工作原理，尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 <code>i</code>。也就是说，所有函数都共享一个 <code>i</code> 的引用。</p><p>而这个循环的终止条件是 <code>i &gt; 5</code>。条件首次成立时 <code>i</code> 的值是 6。因此，输出显示的是循环结束时 <code>i</code> 的最终值。</p><p>那么怎么解决呢？</p><p>我们可以使用 <code>IIFE</code> (Immediately Invoked Function Expression)即立即调用函数来对 <code>i</code> 创建一个单独的作用域，并使用另一个变量 <code>j</code> 在每次迭代中存放 <code>i</code> 的值，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> j = i;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(j);</div><div class="line">    &#125;, j * <span class="number">1000</span>);</div><div class="line">  &#125;)();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样代码就能按照预期输出 1~5 了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是闭包（Closure）&quot;&gt;&lt;a href=&quot;#什么是闭包（Closure）&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包（Closure）&quot;&gt;&lt;/a&gt;什么是闭包（Closure）&lt;/h2&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/source/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/source/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>markdownlint语法警告类型</title>
    <link href="http://yoursite.com/blog/markdownlint%E8%AF%AD%E6%B3%95%E8%AD%A6%E5%91%8A%E7%B1%BB%E5%9E%8B20200315/"/>
    <id>http://yoursite.com/blog/markdownlint语法警告类型20200315/</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2020-03-16T20:11:16.337Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://c1oudust-blog.test.upcdn.net/Markdownlint_warning.jpg" alt="头图"></p><p>最近最近在 vscode 中安装了 markdownlint 插件来检查 markdown 语法的准确性，发现很多不准确的地方。于是参考官方文档，了解警告内容后，一一改正。</p><a id="more"></a><p>下面就来列举一下 markdownlint 的警告类型。</p><p>本文主要参考 markdownlint 的 <a href="https://github.com/DavidAnson/markdownlint/blob/master/doc/Rules.md#md002---first-heading-should-be-a-top-level-heading" target="_blank" rel="external">rules 文档</a>，对每一个规则都进行了说明，指明了一些规则中可以设置的参数，便于用户设置相应的规则。</p><h3 id="MD001-Heading-levels-should-only-increment-by-one-level-at-a-time"><a href="#MD001-Heading-levels-should-only-increment-by-one-level-at-a-time" class="headerlink" title="MD001 - Heading levels should only increment by one level at a time"></a>MD001 - Heading levels should only increment by one level at a time</h3><p>标题级数每次只能依次扩大 1, 不能隔级创建标题（从 1 级到 6 级的顺序）</p><blockquote><p># Heading 1</p><p>### Heading 3<br>跳过了二级标题</p></blockquote><h3 id="MD002-First-heading-should-be-a-top-level-heading"><a href="#MD002-First-heading-should-be-a-top-level-heading" class="headerlink" title="MD002 - First heading should be a top level heading"></a><del>MD002 - First heading should be a top level heading</del></h3><p>文档的第一个标题必须是最高级的标题（标题等级 1 级到 6 级逐渐降低）</p><p>参数：<br>“level”：指定最高级标题的级数，默认是 1</p><p>注意：MD002 已弃用，默认情况下已禁用。MD041 提供了改进的实现。</p><h3 id="MD003-Heading-style"><a href="#MD003-Heading-style" class="headerlink" title="MD003 - Heading style"></a>MD003 - Heading style</h3><p>整篇文档要采用一致的标题格式</p><p>参数：<br>“style”：字符串，指定文档标题的格式，有(“consistent”, “atx”, “atx_closed”, “setext”, “setext_with_atx”, “setext_with_atx_closed”)五种，默认是”consistent”，也就是整篇文档一致</p><p>标题格式必须统一，一般不能混用，但”setext_with_atx”, “setext_with_atx_closed”格式可以在”setext”格式二级标题后接着使用”atx”或”atx_closed”格式的标题</p><h3 id="MD004-Unordered-list-style"><a href="#MD004-Unordered-list-style" class="headerlink" title="MD004 - Unordered list style"></a>MD004 - Unordered list style</h3><p>整篇文档定义无序列表的格式要一致</p><p>错误：</p><blockquote><p>* Item 1</p><p>+ Item 2</p><p>- Item 3</p></blockquote><p>正确：</p><blockquote><p>* Item 1</p><p>* Item 2</p><p>* Item 3</p></blockquote><h3 id="MD005-Inconsistent-indentation-for-list-items-at-the-same-level"><a href="#MD005-Inconsistent-indentation-for-list-items-at-the-same-level" class="headerlink" title="MD005 - Inconsistent indentation for list items at the same level"></a>MD005 - Inconsistent indentation for list items at the same level</h3><p>同一级的列表缩进必须一致<br>在有序列表中，前面的数字序号可以左对齐，也可以右对齐</p><h3 id="MD006-Consider-starting-bulleted-lists-at-the-beginning-of-the-line"><a href="#MD006-Consider-starting-bulleted-lists-at-the-beginning-of-the-line" class="headerlink" title="MD006 - Consider starting bulleted lists at the beginning of the line"></a><del>MD006 - Consider starting bulleted lists at the beginning of the line</del></h3><p>1 级列表不能缩进</p><h3 id="MD007-Unordered-list-indentation"><a href="#MD007-Unordered-list-indentation" class="headerlink" title="MD007 - Unordered list indentation"></a>MD007 - Unordered list indentation</h3><p>无序列表嵌套缩进时默认采用两个空格</p><h3 id="MD009-Trailing-spaces"><a href="#MD009-Trailing-spaces" class="headerlink" title="MD009 - Trailing spaces"></a>MD009 - Trailing spaces</h3><p>行尾最多可以添加两个空格，超过会给出警告，两个空格正好可以用于换行</p><p>参数：<br>“br_spaces”：指定在行尾可以添加的空格数目，空格数目建议大于等于 2，如果小于 2，会默认为 0，也就是不允许任何行尾的空格<br>“list_item_empty_lines”：字符串，指定在列表中是否(true or false)用默认的空格数缩进空行，有的解释器会要求列表中的空行要缩进</p><h3 id="MD010-Hard-tabs"><a href="#MD010-Hard-tabs" class="headerlink" title="MD010 - Hard tabs"></a>MD010 - Hard tabs</h3><p>不能使用 tab 键缩进，要使用空格</p><p>参数：<br>“code_blocks”：指定本条规则在代码块里是否(true or false)生效</p><h3 id="MD011-Reversed-link-syntax"><a href="#MD011-Reversed-link-syntax" class="headerlink" title="MD011 - Reversed link syntax"></a>MD011 - Reversed link syntax</h3><p>检查内联形式的链接的创建方式是否错误，中括号和圆括号是否用对</p><h3 id="MD012-Multiple-consecutive-blank-lines"><a href="#MD012-Multiple-consecutive-blank-lines" class="headerlink" title="MD012 - Multiple consecutive blank lines"></a>MD012 - Multiple consecutive blank lines</h3><p>文档中不能有连续的空行，在代码块中此规则不会生效</p><p>参数：<br>“maximum”：指定文档中可以连续的最多空行数，默认值是 1</p><h3 id="MD013-Line-length"><a href="#MD013-Line-length" class="headerlink" title="MD013 - Line length"></a>MD013 - Line length</h3><p>默认行的最大长度是 80，此规则对代码块、表格、标题也生效</p><p>参数：<br>“line_length”：指定行的最大长度，默认是 80<br>“heading_line_length”：指定标题行的最大长度，默认是 80<br>“code_blocks”：指定规则是否(true or false)对代码块生效，默认 true<br>“tables”：指定规则是否(true or false)对表格生效，默认 true<br>“hesdings”：指定规则是否(true or false)对标题生效，默认 true</p><h3 id="MD014-Dollar-signs-used-before-commands-without-showing-output"><a href="#MD014-Dollar-signs-used-before-commands-without-showing-output" class="headerlink" title="MD014 - Dollar signs used before commands without showing output"></a>MD014 - Dollar signs used before commands without showing output</h3><p>在代码块中，终端命令前不需要有美元符号($)<br>如果代码块中既有终端命令，也有命令的输出，则终端命令前可以有美元符号($)，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> ls</div><div class="line">foo bar</div><div class="line"><span class="meta">$</span> cat foo</div><div class="line">hello world</div></pre></td></tr></table></figure><h3 id="MD018-No-space-after-hash-on-atx-style-heading"><a href="#MD018-No-space-after-hash-on-atx-style-heading" class="headerlink" title="MD018 - No space after hash on atx style heading"></a>MD018 - No space after hash on atx style heading</h3><p>在”atx”格式的标题中，#号和文字间需用一个空格隔开,否则不会生效</p><h3 id="MD019-Multiple-spaces-after-hash-on-atx-style-heading"><a href="#MD019-Multiple-spaces-after-hash-on-atx-style-heading" class="headerlink" title="MD019 - Multiple spaces after hash on atx style heading"></a>MD019 - Multiple spaces after hash on atx style heading</h3><p>在”atx”格式的标题中，#号和文字间只能用一个空格隔开，不能有多余的空格</p><h3 id="MD020-No-space-inside-hashes-on-closed-atx-style-heading"><a href="#MD020-No-space-inside-hashes-on-closed-atx-style-heading" class="headerlink" title="MD020 - No space inside hashes on closed atx style heading"></a>MD020 - No space inside hashes on closed atx style heading</h3><p>在”closed_atx”格式的标题中，文字和前后的#号之间需用一个空格隔开</p><h3 id="MD021-Multiple-spaces-inside-hashes-on-closed-atx-style-heading"><a href="#MD021-Multiple-spaces-inside-hashes-on-closed-atx-style-heading" class="headerlink" title="MD021 - Multiple spaces inside hashes on closed atx style heading"></a>MD021 - Multiple spaces inside hashes on closed atx style heading</h3><p>在”closed_atx”格式的标题中，文字和前后的#号之间只能用一个空格隔开，不能有多余的空格</p><h3 id="MD022-Headings-should-be-surrounded-by-blank-lines"><a href="#MD022-Headings-should-be-surrounded-by-blank-lines" class="headerlink" title="MD022 - Headings should be surrounded by blank lines"></a>MD022 - Headings should be surrounded by blank lines</h3><p>标题行的上下行必须都是空行</p><p>参数：<br>“lines_above”：指定标题行上方的空行数，默认为 1，可以设为更大或 0<br>“lines_below”：指定标题行下方的空行数，默认为 1，可以设为更大或 0</p><p>注意当此处的空行设为比 1 大的数时，规则 MD012 的设置也要改</p><h3 id="MD023-Headings-must-start-at-the-beginning-of-the-line"><a href="#MD023-Headings-must-start-at-the-beginning-of-the-line" class="headerlink" title="MD023 - Headings must start at the beginning of the line"></a>MD023 - Headings must start at the beginning of the line</h3><p>标题行不能缩进</p><h3 id="MD024-Multiple-headings-with-the-same-content"><a href="#MD024-Multiple-headings-with-the-same-content" class="headerlink" title="MD024 - Multiple headings with the same content"></a>MD024 - Multiple headings with the same content</h3><p>文档不能有内容重复的标题</p><p>参数：<br>“siblings_only”：默认为 false，设为 true 时，不同标题下的子标题内容可以重复</p><h3 id="MD025-Multiple-top-level-headings-in-the-same-document"><a href="#MD025-Multiple-top-level-headings-in-the-same-document" class="headerlink" title="MD025 - Multiple top level headings in the same document"></a>MD025 - Multiple top level headings in the same document</h3><p>同一文档只能有一个最高级的标题，默认是只能有一个 1 级标题</p><p>参数：<br>“level”：指定文档最高级的标题，默认是 1<br>“front_matter_title”：字符串，指定在文档开头处的 front matter 中的标题，这个标题将作为整篇文档的最高级标题，如果文档中再次出现最高级标题，将会给出警告，另外，如果不想在 front matter 中指定标题，就把本参数的值设置为””</p><h3 id="MD026-Trailing-punctuation-in-heading"><a href="#MD026-Trailing-punctuation-in-heading" class="headerlink" title="MD026 - Trailing punctuation in heading"></a>MD026 - Trailing punctuation in heading</h3><p>标题行末尾不能有以下标点符号：<code>&quot;.,;:!?&quot;</code></p><p>参数：<br>“punctuation”：字符串，指定标题行尾不能有的标点符号，默认是”.,;:!?”</p><p>此规则默认的是英文的标点符号，中文标点符号不在规则之内</p><h3 id="MD027-Multiple-spaces-after-blockquote-symbol"><a href="#MD027-Multiple-spaces-after-blockquote-symbol" class="headerlink" title="MD027 - Multiple spaces after blockquote symbol"></a>MD027 - Multiple spaces after blockquote symbol</h3><p>创建引用区块时，右尖括号 <code>&gt;</code> 和文字之间有且只能有一个空格</p><h3 id="MD028-Blank-line-inside-blockquote"><a href="#MD028-Blank-line-inside-blockquote" class="headerlink" title="MD028 - Blank line inside blockquote"></a>MD028 - Blank line inside blockquote</h3><p>两个引用区块间不能仅用一个空行隔开或者同一引用区块中不能有空行，如果一行中没有内容，则这一行要用 <code>&gt;</code> 开头</p><h3 id="MD029-Ordered-list-item-prefix"><a href="#MD029-Ordered-list-item-prefix" class="headerlink" title="MD029 - Ordered list item prefix"></a>MD029 - Ordered list item prefix</h3><p>有序列表的前缀序号格式必须只用 1 或者从 1 开始的加 1 递增数字(“one_or_ordered”)</p><p>参数：<br>“style”：字符串，指定前缀序号的格式，(“one”,”ordered”,”one_or_ordered”,”zero”)，分别表示只用 1 做前缀，用从 1 开始的加 1 递增数字做前缀，只用 1 或者从 1 开始的加 1 递增数字做前缀，只用 0 做前缀，默认值是”one_or_ordered”</p><p>本条规则支持在前缀序号中补 0，以实现对齐，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">08.  one</div><div class="line">09.  two</div><div class="line">10.  three</div><div class="line">...</div></pre></td></tr></table></figure><h3 id="MD030-Spaces-after-list-markers"><a href="#MD030-Spaces-after-list-markers" class="headerlink" title="MD030 - Spaces after list markers"></a>MD030 - Spaces after list markers</h3><p>列表（有序、无序）的前缀符号和文字之间用 1 个空格隔开<br>在列表嵌套或者同一列表项中有多个段落时，无序列表缩进两个空格，有序列表缩进 3 个空格</p><p>参数：<br>“ul_single”,”ol_single”,”ul_multi”,”ol_multi”：分别规定无序列表单个段落，有序列表单个段落，无序列表多个段落，有序列表多个段落的前缀符号和文字之间的空格数，默认是 1</p><h3 id="MD031-Fenced-code-blocks-should-be-surrounded-by-blank-lines"><a href="#MD031-Fenced-code-blocks-should-be-surrounded-by-blank-lines" class="headerlink" title="MD031 - Fenced code blocks should be surrounded by blank lines"></a>MD031 - Fenced code blocks should be surrounded by blank lines</h3><p>单独的代码块前后需要用空行隔开（除非是在文档开头或末尾），否则有些解释器不会解释为代码块</p><h3 id="MD032-Lists-should-be-surrounded-by-blank-lines"><a href="#MD032-Lists-should-be-surrounded-by-blank-lines" class="headerlink" title="MD032 - Lists should be surrounded by blank lines"></a>MD032 - Lists should be surrounded by blank lines</h3><p>列表（有序、无序）前后需要用空行隔开，否则有些解释器不会解释为列表<br>列表的缩进必须一致，否则会警告</p><h3 id="MD033-Inline-HTML"><a href="#MD033-Inline-HTML" class="headerlink" title="MD033 - Inline HTML"></a>MD033 - Inline HTML</h3><p>文档中不允许使用 HTML 语句</p><p>参数：<br>“allowed_elements”：自定义允许的元素，是一个字符串数组，默认是空(empty)</p><h3 id="MD034-Bare-URL-used"><a href="#MD034-Bare-URL-used" class="headerlink" title="MD034 - Bare URL used"></a>MD034 - Bare URL used</h3><p>单纯的链接地址需要用尖括号 (&lt;&gt;) 包裹，否则有些解释器不会解释为链接</p><h3 id="MD035-Horizontal-rule-style"><a href="#MD035-Horizontal-rule-style" class="headerlink" title="MD035 - Horizontal rule style"></a>MD035 - Horizontal rule style</h3><p>创建水平线时整篇文档要统一(consistent)，要和文档中第一次创建水平线使用的符号一致</p><p>参数：<br>“style”：字符串，指定创建水平线的方式，值有：(“consistent”,”***“,”—“,”___“)，默认是”consistent”</p><h3 id="MD036-Emphasis-used-instead-of-a-heading"><a href="#MD036-Emphasis-used-instead-of-a-heading" class="headerlink" title="MD036 - Emphasis used instead of a heading"></a>MD036 - Emphasis used instead of a heading</h3><p>不能用强调代替标题</p><p>参数：<br>“punctuation”：字符串，指定用于结尾的标点符号，以此符号结尾的强调不会被视为以强调代替标题，默认值是”.,;:!?”</p><p>此规则会检查只包含强调的单行段落，如果这种段落不是以指定的标点符号结尾，则会被视为以强调代替标题，会给出警告</p><h3 id="MD037-Spaces-inside-emphasis-markers"><a href="#MD037-Spaces-inside-emphasis-markers" class="headerlink" title="MD037 - Spaces inside emphasis markers"></a>MD037 - Spaces inside emphasis markers</h3><p>用于创建强调的符号和强调的的文字之间不能有空格</p><h3 id="MD038-Spaces-inside-code-span-elements"><a href="#MD038-Spaces-inside-code-span-elements" class="headerlink" title="MD038 - Spaces inside code span elements"></a>MD038 - Spaces inside code span elements</h3><p>当用单反引号创建代码段的时候，单反引号和它们之间的代码不能有空格<br>如果要把单反引号嵌入到代码段的首尾，创建代码段的单反引号和嵌入的单反引号间要有一个空格隔开</p><h3 id="MD039-Spaces-inside-link-text"><a href="#MD039-Spaces-inside-link-text" class="headerlink" title="MD039 - Spaces inside link text"></a>MD039 - Spaces inside link text</h3><p>链接名和包围它的中括号之间不能有空格，但链接名中间可以有空格，如：</p><blockquote><p>[百 度](<a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a> “百 度”)</p></blockquote><h3 id="MD040-Fenced-code-blocks-should-have-a-language-specified"><a href="#MD040-Fenced-code-blocks-should-have-a-language-specified" class="headerlink" title="MD040 - Fenced code blocks should have a language specified"></a>MD040 - Fenced code blocks should have a language specified</h3><p>单独的代码块（此处是指上下用三个反引号包围的代码块）应该指定代码块的编程语言，这一点有助于解释器对代码进行代码高亮</p><h3 id="MD041-First-line-in-file-should-be-a-top-level-heading"><a href="#MD041-First-line-in-file-should-be-a-top-level-heading" class="headerlink" title="MD041 - First line in file should be a top level heading"></a>MD041 - First line in file should be a top level heading</h3><p>文档的第一个非空行应该是文档最高级的标题，默认是 1 级标题</p><p>参数：<br>“level”：指定文档最高级的标题，默认是 1<br>“front_matter_title”：字符串，指定在文档开头处的 front matter 中的标题，这个标题将作为整篇文档的最高级标题，另外，如果不想在 front matter 中指定标题，就把本参数的值设置为””</p><h3 id="MD042-No-empty-links"><a href="#MD042-No-empty-links" class="headerlink" title="MD042 - No empty links"></a>MD042 - No empty links</h3><p>链接的地址不能为空</p><h3 id="MD043-Required-heading-structure"><a href="#MD043-Required-heading-structure" class="headerlink" title="MD043 - Required heading structure"></a>MD043 - Required heading structure</h3><p>要求标题遵循一定的结构，默认是没有规定的结构(“null”)</p><p>参数：<br>“headings”：字符串数组，指定标题需要遵循的结构，默认是”null”，可以自行指定结构，如；</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="string">"# head"</span>, <span class="string">"## item"</span>, <span class="string">"### detail"</span>, <span class="string">"*"</span>]</div></pre></td></tr></table></figure><p>星号(*)表示对应的标题是可选的，没有强制要求，本条具体可以参照 MD043</p><h3 id="MD044-Proper-names-should-have-the-correct-capitalization"><a href="#MD044-Proper-names-should-have-the-correct-capitalization" class="headerlink" title="MD044 - Proper names should have the correct capitalization"></a>MD044 - Proper names should have the correct capitalization</h3><p>指定一些名称，会检查它是否有正确的大写</p><p>参数：<br>“names”：字符串数组，指定要检查需要大写的名称，默认是空(“null”)<br>“code_blocks”：指定本规则是否(true or false)对代码块生效，默认是 true<br>一些经常使用的名称可以使用本规则防止其拼写错误，比如 JavaScript 中字母 J 和 S 需要大写，就可以写到参数”names”中，防止写错</p><h3 id="MD045-Images-should-have-alternate-text-alt-text"><a href="#MD045-Images-should-have-alternate-text-alt-text" class="headerlink" title="MD045 - Images should have alternate text (alt text)"></a>MD045 - Images should have alternate text (alt text)</h3><p>图片链接必须包含描述文本（alt text）</p><h3 id="MD046-Code-block-style"><a href="#MD046-Code-block-style" class="headerlink" title="MD046 - Code block style"></a>MD046 - Code block style</h3><p>整篇文档采用一致的代码格式</p><p>参数：<br>“style”: 字符串，指定代码块定义格式，有（”consistent”,”fenced”,”indented”）三种，分别代表：文档上下文一致，使用三个反引号隔开，使用缩进，默认是上下文一致</p><h3 id="MD047-Files-should-end-with-a-single-newline-character"><a href="#MD047-Files-should-end-with-a-single-newline-character" class="headerlink" title="MD047 - Files should end with a single newline character"></a>MD047 - Files should end with a single newline character</h3><p>文档需用一个空行结尾</p><h3 id="MD048-Code-fence-style"><a href="#MD048-Code-fence-style" class="headerlink" title="MD048 - Code fence style"></a>MD048 - Code fence style</h3><p>代码块围栏的样式必须匹配<br>配置的列表样式可以是要使用的特定符号（回刻度、波浪线），也可以要求在文档中保持使用情况一致。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/Markdownlint_warning.jpg&quot; alt=&quot;头图&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近最近在 vscode 中安装了 markdownlint 插件来检查 markdown 语法的准确性，发现很多不准确的地方。于是参考官方文档，了解警告内容后，一一改正。&lt;/p&gt;
    
    </summary>
    
      <category term="软件" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Markdown规范" scheme="http://yoursite.com/source/tags/Markdown%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>烈火燃尽后的生存与死亡</title>
    <link href="http://yoursite.com/blog/%E7%83%88%E7%81%AB%E7%87%83%E5%B0%BD%E5%90%8E%E7%9A%84%E7%94%9F%E5%AD%98%E4%B8%8E%E6%AD%BB%E4%BA%A120190805/"/>
    <id>http://yoursite.com/blog/烈火燃尽后的生存与死亡20190805/</id>
    <published>2019-08-04T16:00:00.000Z</published>
    <updated>2019-08-05T05:04:12.418Z</updated>
    
    <content type="html"><![CDATA[<p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20190805/TheBravest.jpg" alt=""><br><a id="more"></a></div></p><p>那些为了国家，为了民族，为了大义牺牲的人，他们行为对其本人究竟有多少意义呢。看完《烈火英雄》，我不禁对这个世界产生了些许疑问。我想象中的美好世界，每个人都能幸福生活的世界，是不是不可能存在呢。</p><p>电影把重点放在了火灾发生时的情况，对灾难发生和结束的描写很少。纵观影片，观众的大部分印象就是满屏幕的火焰和消防员咬着牙坚持对抗火焰的表情。电影使用大量爆炸，火焰燃烧的镜头以让观众切身感受到火灾现场的压迫感，而这点似乎造成了我的某种“审美疲劳”。电影中大量出现的词语“流淌火”也仿佛魔咒一般，即使看完电影回到家中，也在我脑海中很长一段时间无法散去。</p><p>消防员救火这个题材，个人认为是非常好的，然而影片的重心并不在消防员齐心协力救火，而是主角江和徐的个人英雄主义剧情。上面说到影片大部分镜头都聚焦在火和爆炸上，剩下的就是市民的反应和江、马、徐三个消防战士身上。</p><p>电影对主角江立伟的塑造并不是很到位。主角开始因为自己不经意的疏忽造成了一名消防员的牺牲，自此这朵阴云久久飘浮在他的生活中。不仅被革了职，连儿子也因为父亲的过失遭到了非语。这里的剧情很奇怪，儿子同学的父亲从何处知道主角就是那个造成消防员牺牲的人，又为何要告诉一个三观正在形成的孩子呢？不得而知。想必这是编剧为主角之后救火的英勇表现所做的铺垫吧，然而这个铺垫的意义却不是很明朗。主角是因为对造成手下消防员牺牲的愧疚才去做敢死队队员，还是对自身有一种英雄主义的想法，还是二者都有呢？这里拍的最好的片段，个人认为应该是关阀门前江问马要烟的那一段，可以说是人物塑造中不多的闪光点之一了。</p><p>救火过程中还出现了一位快要退休的消防员郑智，对于他牺牲的描写可以说是比较无厘头的，也许是编剧为了在主角牺牲之前，为调节观众情绪点的一记饭前甜点？</p><p>另一名主角徐小斌的刻画在我看来是优于主角江立伟的。一个普通的消防员，对于一个看似简单实则困难重重的任务，付出了生命。关于河里的垃圾堵住了抽水管道这点，实在是满满的讽刺。这在我看来就是典型的描写小人物手法，无论是下水的片段还是牺牲之后恋人的表现，都极其具有感情表现力。</p><p>既然编剧能写出一个人转十几个小时的阀门，那为什么不能写出生存与牺牲的对比结局呢？徐小斌的牺牲是剧情的升华，而江立伟的牺牲却如鲠在喉。电影通过大量篇幅描写的主角江立伟的牺牲所起到影响观众情绪的效果，远不如相比较短的徐小斌的片段。</p><p>悲剧需要赋予其意义， 否则就是单纯的哗众取宠，如同《战狼2》通过雇佣兵军队残忍的杀戮来突显主角的英雄行为一样。影片结尾对于群众为消防员遗体哀悼的片段，对于影片的情感升华实际上毫无帮助，观众只能体会到浓浓的悲伤，然而整个影片的氛围却是比较壮烈的，可歌可泣的。</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20190805/Chernobyl.jpeg" alt=""></div></p><p>我联想到另一个同样是真实事件改编的电影 —— 《切尔诺贝利》。两部作品有着类似的叙事手法——灾难中不同小人物的插叙描写，包括了身处灾难第一线的人和阵线后的普通群众。</p><p>在看完《切尔诺贝利》后，我的第一感受是对人类在自我毁灭中求生欲望的震撼、对战线后贡献头脑的物理学家的敬畏和当权者视人命如蝼蚁保全自身隐瞒事实的悲哀，它讲的是灾难背后的人性。我觉得这是一个观众看完它后应有的感受。而当我看完《烈火英雄》时，却对这个世界，产生了恻隐之心，甚至产生了怀疑。《烈火英雄》通过人群涌入地铁，涌入船，涌入医院的场景，来描写出群众的恐慌，以突显出灾难之大，从而侧面反映消防员的奉献精神之伟大。而在我眼里这几段描写实际上意义并不大。如果能对码头负责人的言论，对爆炸的原因深入剖析，展开领导隐瞒真相，推卸责任，群众在灾难面前不择手段，那么会更加有深度和内涵，而不仅仅成为一部标准的煽情商业片。然而这些在电影中只是轻描淡写一笔带过。</p><p>《烈火英雄》确实很燃，但仅仅燃是不够的。本片可以说是陈国辉导演的评价最好的电影，但无奈导员水平还是有限。所以才会过早的立下一眼便知的flag。比如江立伟对儿子说：“等这次回去，我天天陪你上学”。这和战争片角色说“打完这仗就回老家结婚”如出一辙，想必是十有八九回不去了。另一个反应导演水平的就是电影中的配乐。电影中的燃点，泪点大多是靠配乐来烘托的，其次就是电影中过分使用的慢镜头，就不展开说了。</p><p>还有对真实事件改编的考究，举一个影片中例子：四个阀门，一个阀门需要8000转，一共需要32000转，而假设主角2秒完成一转，则需要64000秒，共20个小时，抛去另一名消防员转的1/4，还需要十几个小时，同时需要顶着高温作业。</p><p>中国的大部分影片只要涉及类似题材的，往往刻意着重突出英雄主义，从而在其艺术表现力、真实性等方面有所欠缺。我们只能停留在爱国主义，无私奉献精神的层面上，而不能上升到人道主义和整个人类的灵魂、这样的电影带给人的永远只是情绪上的激烈反应和感动后的空虚无物，视觉上的刺激代替了心灵的震撼。比如《战狼2》，原本他们可以拍的更好，可惜文戏拖了后腿。同样是主旋律电影，《我不是药神》这部片在我心中的地位就一直很高。中国不缺主旋律电影，缺的是优秀的剧本，中国能拍出《流浪地球》那样特效的电影，可见技术和特效都是不缺的，因此还是应该把精力花在思考怎么去讲一个好的故事，通过电影引起观众对人性、灾难、英雄气概的思考上。</p><p>因此，要问我如何评价这部电影，我的回答是，如果和《切尔诺贝利》这类写实的电影相比，它差了很多，过分追求观众情感共鸣，人物表现略微空洞，剧情演绎略微浮夸（原油着火用水扑，烈火中扔掉氧气面罩，徒手扳阀门）。但从国产电影的角度来看，《烈火英雄》是一部很好的励志片，唤起人们对消防员战士英勇无畏不惧死亡的歌颂，编剧和导演的对这部电影的定位也就在此。</p><p>顺便一提，和我一起看电影的两个妹子都觉得电影非常棒，甚至有一个从电影中期就一直热泪盈眶。可见《烈火英雄》的受众并不是我这一类人，而是需要这种电影产生的正能量激励的人，这也是这部电影评价两极分化严重的原因之一。而我，从来都不是一个通过电影这种艺术形式去获得生活动力的人，仅此而已吧。</p><p>回到开头的疑问，即使存在这样一个世界，我想，也是少数人的，建立在大多数人不幸的基础之上的“幸福”世界吧。在这个世界中有无数默默奉献的小人物，他们咬着牙，就算流血也要坚持。坚持什么？他们心中存在的正义。然而讽刺的是，他们坚持的正义却是无比虚无的东西，只会成为上层人民享受生活的源泉。在我看来，不过工具人罢了。</p><p>我自诩做不了战场效命的士兵，无法改变这个并不美好的世界。但我想做自己能想到的美好的事，如果让这个世界变得美好那么一点点，也足够了。</p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/20190805/TheBravest.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="电影" scheme="http://yoursite.com/source/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>.NET Core + EF 报nuget包版本冲突错误</title>
    <link href="http://yoursite.com/blog/dotNETCoreEF%E6%8A%A5nuget%E5%8C%85%E4%B8%8D%E5%85%BC%E5%AE%B920190621/"/>
    <id>http://yoursite.com/blog/dotNETCoreEF报nuget包不兼容20190621/</id>
    <published>2019-06-20T16:00:00.000Z</published>
    <updated>2020-03-16T19:15:32.824Z</updated>
    
    <content type="html"><![CDATA[<p>错误信息如下：</p><p>错误<code>NU1107 Microsoft.EntityFrameworkCore</code> 中检测到版本冲突。直接安装/引用 <code>Microsoft.EntityFrameworkCore 2.2.4</code> 到项目 CoreWeb 可解决此问题。</p><a id="more"></a><p>NewsPublish -&gt; NewsPublish.Service -&gt; Microsoft.EntityFrameworkCore (&gt;= 2.2.4)<br>NewsPublish -&gt; Microsoft.AspNetCore.App 2.1.1 -&gt; Microsoft.EntityFrameworkCore (&gt;= 2.1.1 &amp;&amp; &lt; 2.2.0)</p><p>问题出现原因是：nuget 包版本不兼容</p><p>升级包，发现无法升级，然后查原因是.net Core 版本问题，</p><p>升级版本至 2.2，并在项目上添加目标框架为 2.2，问题解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;错误信息如下：&lt;/p&gt;
&lt;p&gt;错误&lt;code&gt;NU1107 Microsoft.EntityFrameworkCore&lt;/code&gt; 中检测到版本冲突。直接安装/引用 &lt;code&gt;Microsoft.EntityFrameworkCore 2.2.4&lt;/code&gt; 到项目 CoreWeb 可解决此问题。&lt;/p&gt;
    
    </summary>
    
      <category term=".NET" scheme="http://yoursite.com/categories/NET/"/>
    
    
      <category term="C#" scheme="http://yoursite.com/source/tags/C/"/>
    
      <category term=".NET" scheme="http://yoursite.com/source/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序报错:Page is not constructed because it is not found.</title>
    <link href="http://yoursite.com/blog/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8A%A5%E9%94%99Page_is_not_constructed20190424/"/>
    <id>http://yoursite.com/blog/小程序报错Page_is_not_constructed20190424/</id>
    <published>2019-04-23T16:00:00.000Z</published>
    <updated>2019-04-24T04:32:46.641Z</updated>
    
    <content type="html"><![CDATA[<p>在实际开发中遇到了一个错误：Page is not constructed because it is not found</p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/WeChatmicroApp_error01.jpg" alt=""><br></div><p>该错误多发生在点击事件切换页面的时候<br>解决方法：<br>在需要切换到的那个页面的 js 文件中添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Page(&#123; &#125;)</div></pre></td></tr></table></figure><blockquote><p><strong>Tips: 在 js 文件中输入 Page 回车，可自动添加 Page 方法，包括里面的 data 初始化数据及 onLoad 等生命中期方法。</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在实际开发中遇到了一个错误：Page is not constructed because it is not found&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/W
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="微信小程序" scheme="http://yoursite.com/source/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序警告：Now you can provide attr &quot;wx:key&quot; for a &quot;wx:for&quot; to improve performance.</title>
    <link href="http://yoursite.com/blog/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%AD%A6%E5%91%8Awxkey20190421/"/>
    <id>http://yoursite.com/blog/微信小程序警告wxkey20190421/</id>
    <published>2019-04-20T16:00:00.000Z</published>
    <updated>2020-03-16T19:12:02.087Z</updated>
    
    <content type="html"><![CDATA[<style type="text/css">img{text-align: center; margin: 0 auto;}</style><p>在实际开发中遇到了一个警告：Now you can provide attr <code>wx:key</code> for a <code>wx:for</code> to improve performance.</p><p><img src="http://c1oudust-blog.test.upcdn.net/WeChatmicroApp_warning.jpg" alt="小程序报错"></p><a id="more"></a><p>官方文档解释如下：</p><blockquote><p><strong>wx:key</strong><br>如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 <code>&lt;input&gt;</code>中的输入内容，<code>&lt;switch&gt;</code> 的选中状态），需要使用 <code>wx:key</code> 来指定列表中项目的唯一的标识符。<br><code>wx:key</code> 的值以两种形式提供</p><ul><li>字符串，代表在 for 循环的 array 中 item 的某个 <code>property</code>，该 <code>property</code> 的值需要是列表中唯一的字符串或数字，且不能动态改变。</li><li>保留关键字 <code>*this</code> 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如：<br>当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。<br>如不提供 <code>wx:key</code>，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。</li></ul></blockquote><p>简单来说，就是给 for 循环的每个项目添加一个唯一性标识符，以提升列表的渲染速度。<br>当一个列表是静态列表,比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;block wx:<span class="keyword">for</span>-items=<span class="string">"&#123;&#123;postList&#125;&#125;"</span> &gt;</div></pre></td></tr></table></figure><p>不添加<code>wx:key</code>则会出现<code>warning： Now you can provide attr &quot;wx:key&quot; for a &quot;wx:for&quot; to improve performance.</code></p><p>此时可以选择忽略。</p><p>如果想要去掉 warning，就要给 array 的 每一个 item 都添加一个唯一识别的 <code>property</code> 来管理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;block wx:<span class="keyword">for</span>-items=<span class="string">"&#123;&#123;postList&#125;&#125;"</span> wx:key=<span class="string">"index"</span>&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;style type=&quot;text/css&quot;&gt;

img{text-align: center; margin: 0 auto;}
&lt;/style&gt;

&lt;p&gt;在实际开发中遇到了一个警告：Now you can provide attr &lt;code&gt;wx:key&lt;/code&gt; for a &lt;code&gt;wx:for&lt;/code&gt; to improve performance.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/WeChatmicroApp_warning.jpg&quot; alt=&quot;小程序报错&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="微信小程序" scheme="http://yoursite.com/source/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Windows下使用SublimeText3调试运行Pascal程序</title>
    <link href="http://yoursite.com/blog/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8sublimetext3%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8CPascal%E7%A8%8B%E5%BA%8F20190307/"/>
    <id>http://yoursite.com/blog/Windows下使用sublimetext3调试运行Pascal程序20190307/</id>
    <published>2019-03-06T16:00:00.000Z</published>
    <updated>2019-03-07T04:57:18.153Z</updated>
    
    <content type="html"><![CDATA[<ul><li>系统：Windows 10 64bit</li><li>软件：Sublime Text 3.1.1 Build3176</li><li>编译软件：Free Pascal<a id="more"></a></li></ul><blockquote><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2></blockquote><h3 id="下载并安装-Free-Pascal"><a href="#下载并安装-Free-Pascal" class="headerlink" title="下载并安装 Free Pascal"></a>下载并安装 Free Pascal</h3><p>下载地址：<a href="https://www.freepascal.org/down/i386/win32.html" target="_blank" rel="external">Download</a></p><p>安装最新的 3.0.4 版本。</p><p>我这里选择把安装目录设为 D 盘的 FPC 文件夹。</p><p>安装过程中安装器会自动帮我们添加好环境变量，为了保险起见，我们可以测试一下。打开 cmd 命令行，执行 fpc -v，若显示版本号，则说明安装成功，跳过下一步。若报错，则需要手动配置环境变量。</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>右击我的电脑，属性–&gt;高级–&gt;环境变量。</p><p>在系统环境变量 PATH 里添加 D:\FPC\3.0.4\bin\i386-win32 （如果里面还有其他的变量，记得添加英文分号;）</p><p>以上环境变量中的具体路径请根据本人实际的 i386-win32 文件夹 路径进行设置，默认地址在 C 盘。</p><blockquote><h2 id="配置-sublime-text-编译系统"><a href="#配置-sublime-text-编译系统" class="headerlink" title="配置 sublime text 编译系统"></a>配置 sublime text 编译系统</h2></blockquote><p>需要的编译器到手了，现在我们来配置一下编辑器 Sublime Text3 的编译系统。<br>以管理员身份运行 Sublime Text 3,进入菜单 工具-&gt;编译系统-&gt;新编译系统。</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/ST3buildPascal/pascal_01.jpg" alt=""></div></p><div align="left"><p>输入如下内容</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/ST3buildPascal/pascal_02.jpg" alt=""></div></p><div align="left"><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"cmd"</span>: [<span class="string">"D:/FPC/3.0.4/bin/i386-win32/ppc386.exe"</span>, <span class="string">"$file"</span>],</div><div class="line">  <span class="attr">"file_regex"</span>: <span class="string">"^(?:pas:)?[\t ](...*?):([0-9]*):?([0-9]*)"</span>,</div><div class="line">  <span class="attr">"selector"</span>: <span class="string">"source.pas"</span>,</div><div class="line"></div><div class="line">  <span class="attr">"variants"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"name"</span>: <span class="string">"Run"</span>,</div><div class="line">      <span class="attr">"shell_cmd"</span>: <span class="string">"start cmd /c \"\"$&#123;file_path&#125;/$&#123;file_base_name&#125;\" &amp; pause\""</span></div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>把 cmd 后的路径改成你自己 ppc386.exed 的路径,将文件命名为 Pascal.sublime-build 保存至 C 盘 Users\用户名\AppData\Roaming\Sublime Text 3\Packages\User 目录下（默认就是这个）</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/ST3buildPascal/pascal_03.jpg" alt=""></div></p><div align="left"><blockquote><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2></blockquote><ol><li><p>完成之后，在 Sublime 中 Tools（工具）-&gt;bulid system（编译系统）中会出现一个 Pascal 的编译方式。选择后就可以使用了。</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/ST3buildPascal/pascal_04.jpg" alt=""></div></p><div align="left"></div></li><li><p>按下快捷键 Ctrl+B 选择 Pascal，回车即可对当前 Pascal 程序进行编译。</p><p> <div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/ST3buildPascal/pascal_05.jpg" alt=""><br><img src="http://c1oudust-blog.test.upcdn.net/ST3buildPascal/pascal_06.jpg" alt=""></div></p><div align="left"></div></li><li><p>Shift+Ctrl+P 召唤出搜索框，输入 Pascal</p><p> <div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/ST3buildPascal/pascal_07.jpg" alt=""></div></p><div align="left"></div></li><li><p>选择 Pascal-Run，即可在 cmd 中运行编译后的结果。</p><p> <div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/ST3buildPascal/pascal_08.jpg" alt=""></div></p><div align="left"></div></li></ol><blockquote><h2 id="中文乱码解决"><a href="#中文乱码解决" class="headerlink" title="中文乱码解决"></a>中文乱码解决</h2></blockquote><ol><li>Shift+Ctrl+P 召唤出搜索框；</li><li>install package （需要安装好 package control）；</li><li>搜索安装 ConvertToUTF8 和 supportGBK；</li><li>在 New File 新建 pas 代码文件之后，直接按住快捷键 Ctrl+Shift+C 设置文本的 Encoding 为 GBK 就能解决了。</li></ol></div></div></div>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;系统：Windows 10 64bit&lt;/li&gt;
&lt;li&gt;软件：Sublime Text 3.1.1 Build3176&lt;/li&gt;
&lt;li&gt;编译软件：Free Pascal
    
    </summary>
    
      <category term="Pascal" scheme="http://yoursite.com/categories/Pascal/"/>
    
    
      <category term="Windows" scheme="http://yoursite.com/source/tags/Windows/"/>
    
      <category term="Pascal" scheme="http://yoursite.com/source/tags/Pascal/"/>
    
  </entry>
  
  <entry>
    <title>对你来说活着意味着什么？</title>
    <link href="http://yoursite.com/blog/%E5%AF%B9%E4%BD%A0%E6%9D%A5%E8%AF%B4%E6%B4%BB%E7%9D%80%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%8820190119/"/>
    <id>http://yoursite.com/blog/对你来说活着意味着什么20190119/</id>
    <published>2019-01-18T16:00:00.000Z</published>
    <updated>2020-03-16T19:25:45.507Z</updated>
    
    <content type="html"><![CDATA[<style type="text/css">img{text-align: center; margin: 0 auto;}</style><p>小说是从 P 站上一位画师那知道的，自然被这个名字所吸引。联想到少年与少女站在樱花树下的插图和带有一丝悬疑色彩的名字，不由地想：“究竟是怎样一个故事呢？”直到看完了小说，电影，和最近上映的动漫电影。</p><p><img src="http://c1oudust-blog.test.upcdn.net/50960701.jpg" alt="头图"></p><a id="more"></a><iframe frameborder="no" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1305366565&auto=1&height=66"></iframe><p>电影是用插叙和倒叙来展开剧情。中年的志贺春树在母校做了老师，教导主任想起志贺学生时代是旧图书馆的图书管理员，于是便把整理旧书搬到校临时图书馆的责任就交到了志贺手上。</p><p>志贺走进阔别了多年的图书馆，恍惚中仿佛看到当年那个满脸笑容的少女从他面前一晃而过。于是时光倒流，镜头转向少年与少女相遇的那一刻，故事开始了。</p><p>而动漫采用与原作相同的开头——“同学山内樱良的告别式，是在一个和她性格完全不相称的雨天举行的”。之后志贺回忆起和樱良之间的种种，被“我”以笔触记录了下来。</p><p>本来虐心剧情我是比较逃避看多次的，不过这部影片，重点不在虐心。我从中感受到的是两个迥异的性格，因为某种催化剂产生反应，最后对彼此都带来了改变。他们在一个季节里相识，相知，分别的过程，就好像樱花的绽放与凋零，短暂而又绚烂。</p><p><img src="http://c1oudust-blog.test.upcdn.net/suizou4.jpg" alt=""></p><p>“我听说啊，樱花会假装凋谢然后再次盛放的。假装已经凋零了，其实它们会马上长出新芽，然后沉睡起来，根本没有凋零这回事。只是为了吓吓大家藏起来罢了。然后到了温暖的季节，就再一口气长出花朵来，给大家一个惊喜。”少女如是说到。</p><p>面对死亡，樱良总是摆出满不在乎的令人心疼的笑容，随后独自一人时，却又不争气的流下眼泪。</p><p>我们存活于世，总会把那个真实的自我小心翼翼地隐藏起来，反而当知道自己不久于世时，也许会活的更洒脱一点吧。但人就是这样，越坚强的人，一旦受伤，就会变得愈加脆弱，于是继续掩饰，伤口却难以隐藏。</p><p>唯一的一次，是在酒店玩真心话大冒险的最后一局。在酒精的作用下，少女终于坦露出脆弱的内心：</p><p><img src="http://c1oudust-blog.test.upcdn.net/suizou1.jpg" alt=""></p><p>志贺想起打开少女背包时看到的满满的药片，说：我选大冒险。<br>一直假装坚强的她遇到了那个与自己心意相通的人，从此不用将真心掩藏起来，因为终于有了一个能够呵护爱惜自己真心的人，这是一件很幸福的事情吧。然而就是这样的幸福氛围，越能体现出悲剧的色彩。</p><p>活着，对你来说意味着什么？</p><p>“活着就是和某个人心意相通吧，欣赏某个人，喜欢上他，讨厌他，和某个人在一起，手牵着手，相互拥抱，相互错过。”</p><p><img src="http://c1oudust-blog.test.upcdn.net/suizou2.jpg" alt=""></p><p>春树和樱良之间，并不是简单的友情或爱情，而是在那之上的更加纯粹的关系。心意相通也好，为对方做出改变也好，“这些都不是偶然，也不是命运的安排，而是你做出的选择和我做出的选择，让我们遇见了彼此。我们是靠自己的意愿相遇的”。</p><p>村上春树曾经写到：死不是生的对立面，而是作为生的一部分永恒。<br>作者给樱良安排的结局并不是传统爱情故事那样圆满的结局，甚至连因病而死都无法做到，而是很突然地在见男主的路途中遇害了。虽然之前就有了伏笔，不过看到这里还是不免感到揪心。不过想到了这句话，感觉打破这种浪漫氛围其实也让春树被救赎的剧情得到了升华 。</p><p>樱良活着的时候，她的温暖和阳光融化了春树的自我封闭；樱良死后，她的灵魂会活在在春树心中，她的“死”将作为春树“生”的一部分永恒。所以樱良的生用什么方式结束也不再那么值得去争议，因为从那个时刻起，无论樱良用什么方式死去，她的“生”都会注定在春树身上续存。</p><p><img src="http://c1oudust-blog.test.upcdn.net/suizou3.jpg" alt=""></p><blockquote><p>“为什么你就是不喊我的名字呢？<br>因为春树，你一次都没喊过我的名字对吧。<br>从认识到最后都是“你”“你”“你”的叫我，很过分耶。<br>可是啊，你偷偷跑进医院那次，我才终于明白了，你总有一天会失去我，但我不想做你的朋友或是恋人，不想做你心中那个特别的人。不过，我憧憬着这样的你，憧憬着那个和谁都不牵扯，自己独立生活，那么坚强的你。<br>因为我很脆弱，会让朋友和家人被我的悲伤影响，但春树，你一直都能保持自我。你真的很厉害，所以也请把这些勇气，分一点给大家吧，然后去喜欢上某个人，牵起对方的手，拥抱对方，即便心情郁闷，哪怕犹豫不决，也要和很多人交流沟通，连我的份一起。嗯，活下去。<br>我啊，想变成像春树那样的人，想活在你身体里，不行，不能说这些陈腔滥调的话啊。对了，可能你会不喜欢，我果然…”</p></blockquote><p><img src="http://c1oudust-blog.test.upcdn.net/suizoumain.jpg" alt=""></p><p>在电影的结尾，春树泪流满面的拿着樱良留给恭子的信去往她的婚礼现场，并说出了在樱良面前练习多次的那句话“可以做我的朋友吗”。动漫的结局则是悲剧之中多了一点浪漫，春树和恭子成为了朋友，并且一起给樱良扫墓后，相约前去樱良家。少年因为少女做出了改变，欢声笑语中，樱花飞舞，触动人心，温暖人心。</p><p>怀抱美好感情的人，只能写出拙劣的文字。庆幸看到它，感受它，思考它。有一个心意相通的人真的很美好呢，就像吃掉你的胰脏，就能活在你身体里一样。</p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;style type=&quot;text/css&quot;&gt;
img{text-align: center; margin: 0 auto;}
&lt;/style&gt;

&lt;p&gt;小说是从 P 站上一位画师那知道的，自然被这个名字所吸引。联想到少年与少女站在樱花树下的插图和带有一丝悬疑色彩的名字，不由地想：“究竟是怎样一个故事呢？”直到看完了小说，电影，和最近上映的动漫电影。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/50960701.jpg&quot; alt=&quot;头图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="电影" scheme="http://yoursite.com/source/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="动漫" scheme="http://yoursite.com/source/tags/%E5%8A%A8%E6%BC%AB/"/>
    
  </entry>
  
  <entry>
    <title>计算机操作系统调度算法模拟程序设计（C#）</title>
    <link href="http://yoursite.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A120181214/"/>
    <id>http://yoursite.com/blog/计算机操作系统调度算法模拟程序设计20181214/</id>
    <published>2018-12-13T16:00:00.000Z</published>
    <updated>2019-02-10T07:17:17.921Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a><strong>实验目的</strong></h2></blockquote><p>用 C#语言编程实现对 N 个进程采用四种进程调度算法——先来先服务算法（FCFS）、短进程优先算法（SJF）、高响应比优先调度算法(HRRN)和时间片轮转调度算法（RR）调度执行模拟。</p><a id="more"></a><blockquote><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a><strong>实验原理</strong></h2></blockquote><p>先构建每个用来标识进程的进程控制块 PCB，包括以下字段：</p><ul><li>进程标识数 id</li><li>进程优先数 priority，并规定优先数越大的进程，其优先权越高</li><li>进程到达时间 arriveTime</li><li>进程已占用 CPU 时间 serveTime</li><li>进程还需占用的 CPU 时间 needTime。当进程运行完毕时，needTime 变为 0</li><li>进程被阻塞的时间 blockTime，表示已阻塞的进程再等待 blockTime 个时间片后，将转换成就绪状态</li><li>进程状态 state</li></ul><h3 id="FCFS-算法"><a href="#FCFS-算法" class="headerlink" title="FCFS 算法"></a><strong>FCFS 算法</strong></h3><p>先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用 FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，然后投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</p><h3 id="SJ-P-F-算法"><a href="#SJ-P-F-算法" class="headerlink" title="SJ(P)F 算法"></a><strong>SJ(P)F 算法</strong></h3><p>短作业(进程)优先调度算法 SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。</p><h3 id="HRRN-算法"><a href="#HRRN-算法" class="headerlink" title="HRRN 算法"></a><strong>HRRN 算法</strong></h3><p>高响应比算法，是一种动态调整优先级的算法。HRRN 算法每次都计算作业的优先级，随着作业等待时间的变长，优先级不断的提高，所以能够得到更快的执行。<br>这个优先级可以描述为: 优先级 = (作业已等待时间 + 作业的服务时间) / 作业的服务时间<br>在本实验的代码模拟中，设定初始优先级固定，之后当进程运行一个时间片后，优先级减 3，同时就绪队列中的其他进程优先级加 1。</p><h3 id="RR-算法"><a href="#RR-算法" class="headerlink" title="RR 算法"></a><strong>RR 算法</strong></h3><p>RR 算法是使用非常广泛的一种调度算法。<br>首先将所有就绪的队列按 FCFS 策略排成一个就绪队列，然后系统设置一定的时间片，每次给队首作业分配时间片。如果此作业运行结束，即使时间片没用完，立刻从队列中去除此作业，并给下一个作业分配新的时间片；如果作业时间片用完没有运行结束，则将此作业重新加入就绪队列尾部等待调度。</p><blockquote><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a><strong>代码部分</strong></h2></blockquote><h3 id="PCB-类"><a href="#PCB-类" class="headerlink" title="PCB 类"></a><strong>PCB 类</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">using System;</div><div class="line">public class PCB</div><div class="line">&#123;</div><div class="line">    public int id &#123; get; set; &#125;</div><div class="line">    public int priority &#123; get; set; &#125;</div><div class="line">    public int cpuTime &#123; get; set; &#125;</div><div class="line">    public int blockTime &#123; get; set; &#125;</div><div class="line">    public int state &#123; get; set; &#125;</div><div class="line">    public int arriveTime &#123; get; set; &#125;</div><div class="line">    public int serveTime &#123; get; set; &#125;</div><div class="line">    public int needTime &#123; get; set; &#125;</div><div class="line">    public int finishTime &#123; get; set; &#125;</div><div class="line">    //state : 1:ready,2:running</div><div class="line">    public PCB(int id, int arriveTime, int serveTime, int state)</div><div class="line">    &#123;</div><div class="line">        this.id = id;</div><div class="line">        this.arriveTime = arriveTime;</div><div class="line">        this.serveTime = serveTime;</div><div class="line">        this.state = state;</div><div class="line">    &#125;</div><div class="line">    public PCB(int id, int arriveTime, int serveTime, int blockTime, int state)</div><div class="line">    &#123;</div><div class="line">        this.id = id;</div><div class="line">        this.arriveTime = arriveTime;</div><div class="line">        this.serveTime = serveTime;</div><div class="line">        this.blockTime = blockTime;</div><div class="line">        this.state = state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public PCB(int id, int priority, int arriveTime, int serveTime, int state, bool isD)</div><div class="line">    &#123;</div><div class="line">        this.id = id;</div><div class="line">        this.priority = priority;</div><div class="line">        this.arriveTime = arriveTime;</div><div class="line">        this.serveTime = serveTime;</div><div class="line">        this.state = state;</div><div class="line">    &#125;</div><div class="line">    public void showState()</div><div class="line">    &#123;</div><div class="line">        System.Console.WriteLine(&quot;&#123;0&#125;\t\t&#123;1&#125;\t\t&#123;2&#125;\t\t&#123;3&#125;\t\t&#123;4&#125;\t\t&#123;5&#125;&quot;, id, priority, arriveTime, needTime, serveTime, state);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    public void showState(int i)</div><div class="line">    &#123;</div><div class="line">        System.Console.WriteLine(&quot;&#123;0&#125;\t\t&#123;1&#125;\t\t&#123;2&#125;\t\t&#123;3&#125;\t\t&#123;4&#125;\t\t&#123;5&#125;\t\t&#123;6&#125;&quot;, id, priority, arriveTime, needTime, serveTime, blockTime, state);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a><strong>FCFS</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">using System;</div><div class="line">using System.Threading;</div><div class="line">using System.Collections.Generic;</div><div class="line"></div><div class="line">class FCFS</div><div class="line">&#123;</div><div class="line">    List&lt;PCB&gt; Ready = new List&lt;PCB&gt;();</div><div class="line">    static int FCFS_PRIORITY = 15;</div><div class="line">    int times;</div><div class="line">    public void Init()</div><div class="line">    &#123;</div><div class="line">        PCB a = new PCB(1, 0, 3, 1),</div><div class="line">            b = new PCB(2, 2, 6, 1),</div><div class="line">            c = new PCB(3, 4, 4, 1),</div><div class="line">            d = new PCB(4, 6, 5, 1),</div><div class="line">            e = new PCB(5, 8, 2, 1);</div><div class="line">        times = 1;</div><div class="line">        Ready.Add(e);</div><div class="line">        Ready.Add(d);</div><div class="line">        Ready.Add(c);</div><div class="line">        Ready.Add(b);</div><div class="line">        Ready.Add(a);</div><div class="line">        //对优先权priority与服务需要的时间needTime进行赋值</div><div class="line">        for (int i = 0; i &lt; Ready.Count; i++)</div><div class="line">        &#123;</div><div class="line">            Ready[i].priority = FCFS_PRIORITY - Ready[i].needTime;</div><div class="line">            Ready[i].needTime = Ready[i].serveTime;</div><div class="line">        &#125;</div><div class="line">        PCB temp = null;</div><div class="line">        //对优先权排序</div><div class="line">        for (int i = 0; i &lt; Ready.Count - 1; i++)</div><div class="line">        &#123;</div><div class="line">            for (int j = 0; j &lt; Ready.Count - i - 1; j++)</div><div class="line">            &#123;</div><div class="line">                if (Ready[j].priority &lt; Ready[j + 1].priority)</div><div class="line">                &#123;</div><div class="line">                    temp = Ready[j];</div><div class="line">                    Ready[j] = Ready[j + 1];</div><div class="line">                    Ready[j + 1] = temp;</div><div class="line">                &#125;</div><div class="line">                else if (Ready[j].priority == Ready[j + 1].priority)</div><div class="line">                &#123;</div><div class="line">                    if (Ready[j].serveTime &gt; Ready[j + 1].serveTime)</div><div class="line">                    &#123;</div><div class="line">                        temp = Ready[j];</div><div class="line">                        Ready[j] = Ready[j + 1];</div><div class="line">                        Ready[j + 1] = temp;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void Start()</div><div class="line">    &#123;</div><div class="line">        System.Console.WriteLine(&quot;先来先服务(FCFS)&quot;);</div><div class="line">        System.Console.WriteLine(&quot;进程状态标志(procState)：1：准备，2：正在运行&quot;);</div><div class="line">        System.Console.WriteLine(&quot;===================================================================================&quot;);</div><div class="line">        while (Ready != null &amp;&amp; Ready.Count &gt; 0)</div><div class="line">        &#123;</div><div class="line">            System.Console.WriteLine(&quot;Id\t     Priority\t     ArriveTime\t       NeedTime\t    ServeTime\t    State\n&quot;);</div><div class="line">            if (Ready[0] != null)</div><div class="line">            &#123;</div><div class="line">                while (Ready[0].needTime &gt; 0)</div><div class="line">                &#123;</div><div class="line">                    Ready[0].state = 2;</div><div class="line">                    // 输出单个时间片中全部进程的状态</div><div class="line">                    // foreach (var item in Ready)</div><div class="line">                    // &#123;</div><div class="line">                    //     item.showState();</div><div class="line">                    // &#125;</div><div class="line">                    // 仅输出单个时间片运行中的程序状态</div><div class="line">                    Ready[0].showState();</div><div class="line">                    System.Console.WriteLine(&quot;time:&#123;0&#125;&quot;, times);</div><div class="line">                    Thread.Sleep(1000);</div><div class="line">                    System.Console.WriteLine(&quot;-----------------------------------------------------------------------------------&quot;);</div><div class="line">                    Ready[0].needTime--;</div><div class="line">                    times++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            Ready[0].state = 0;</div><div class="line">            System.Console.WriteLine(&quot;===================================================================================&quot;);</div><div class="line">            System.Console.WriteLine(&quot;\t\t\t\t\t\t\t\t\tprocess &#123;0&#125; completed\n&quot;, Ready[0].id);</div><div class="line">            Ready.RemoveAt(0);</div><div class="line">        &#125;</div><div class="line">        System.Console.WriteLine(&quot;                 All processes have been completed,takes &#123;0&#125; times\n&quot;, times - 1);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="SJB"><a href="#SJB" class="headerlink" title="SJB"></a><strong>SJB</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">using System;</div><div class="line">using System.Threading;</div><div class="line">using System.Collections.Generic;</div><div class="line"></div><div class="line">class SJF</div><div class="line">&#123;</div><div class="line">    List&lt;PCB&gt; Ready = new List&lt;PCB&gt;();</div><div class="line">    static int SJF_PRIORITY = 15;</div><div class="line">    int times;</div><div class="line">    public void Init()</div><div class="line">    &#123;</div><div class="line">        PCB a = new PCB(1, 0, 3, 1),</div><div class="line">            b = new PCB(2, 2, 6, 1),</div><div class="line">            c = new PCB(3, 4, 4, 1),</div><div class="line">            d = new PCB(4, 6, 5, 1),</div><div class="line">            e = new PCB(5, 8, 2, 1);</div><div class="line">        times = 1;</div><div class="line">        Ready.Add(e);</div><div class="line">        Ready.Add(d);</div><div class="line">        Ready.Add(c);</div><div class="line">        Ready.Add(b);</div><div class="line">        Ready.Add(a);</div><div class="line">        //对优先权priority与服务需要的时间needTime进行赋值</div><div class="line">        for (int i = 0; i &lt; Ready.Count; i++)</div><div class="line">        &#123;</div><div class="line">            Ready[i].priority = SJF_PRIORITY - Ready[i].serveTime;</div><div class="line">            Ready[i].needTime = Ready[i].serveTime;</div><div class="line">        &#125;</div><div class="line">        PCB temp = null;</div><div class="line">        //对优先权排序</div><div class="line">        for (int i = 0; i &lt; Ready.Count - 1; i++)</div><div class="line">        &#123;</div><div class="line">            for (int j = 0; j &lt; Ready.Count - i - 1; j++)</div><div class="line">            &#123;</div><div class="line">                if (Ready[j].priority &lt; Ready[j + 1].priority)</div><div class="line">                &#123;</div><div class="line">                    temp = Ready[j];</div><div class="line">                    Ready[j] = Ready[j + 1];</div><div class="line">                    Ready[j + 1] = temp;</div><div class="line">                &#125;</div><div class="line">                else if (Ready[j].priority == Ready[j + 1].priority)</div><div class="line">                &#123;</div><div class="line">                    if (Ready[j].arriveTime &gt; Ready[j + 1].arriveTime)</div><div class="line">                    &#123;</div><div class="line">                        temp = Ready[j];</div><div class="line">                        Ready[j] = Ready[j + 1];</div><div class="line">                        Ready[j + 1] = temp;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void Start()</div><div class="line">    &#123;</div><div class="line">        System.Console.WriteLine(&quot;短作业优先(SJF)&quot;);</div><div class="line">        System.Console.WriteLine(&quot;进程状态标志(procState)：1：准备，2：正在运行&quot;);</div><div class="line">        System.Console.WriteLine(&quot;===================================================================================&quot;);</div><div class="line">        while (Ready != null &amp;&amp; Ready.Count &gt; 0)</div><div class="line">        &#123;</div><div class="line">            System.Console.WriteLine(&quot;Id\t     Priority\t     ArriveTime\t       NeedTime\t    ServeTime\t    State\n&quot;);</div><div class="line">            if (Ready[0] != null)</div><div class="line">            &#123;</div><div class="line">                while (Ready[0].needTime &gt; 0)</div><div class="line">                &#123;</div><div class="line">                    Ready[0].state = 2;</div><div class="line">                    // 输出单个时间片中全部进程的状态</div><div class="line">                    // foreach (var item in Ready)</div><div class="line">                    // &#123;</div><div class="line">                    //     item.showState();</div><div class="line">                    // &#125;</div><div class="line">                    // 仅输出单个时间片运行中的程序状态</div><div class="line">                    Ready[0].showState();</div><div class="line">                    System.Console.WriteLine(&quot;time:&#123;0&#125;&quot;, times);</div><div class="line">                    Thread.Sleep(1000);</div><div class="line">                    System.Console.WriteLine(&quot;-----------------------------------------------------------------------------------&quot;);</div><div class="line">                    Ready[0].needTime--;</div><div class="line">                    times++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            Ready[0].state = 0;</div><div class="line">            System.Console.WriteLine(&quot;===================================================================================&quot;);</div><div class="line">            System.Console.WriteLine(&quot;\t\t\t\t\t\t\t\t\tprocess &#123;0&#125; completed\n&quot;, Ready[0].id);</div><div class="line">            Ready.RemoveAt(0);</div><div class="line">        &#125;</div><div class="line">        System.Console.WriteLine(&quot;                 All processes have been completed,takes &#123;0&#125; times\n&quot;, times - 1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="HRRN"><a href="#HRRN" class="headerlink" title="HRRN"></a><strong>HRRN</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">using System;</div><div class="line">using System.Threading;</div><div class="line">using System.Collections.Generic;</div><div class="line"></div><div class="line">class HRRN</div><div class="line">&#123;</div><div class="line">    List&lt;PCB&gt; Ready = new List&lt;PCB&gt;();</div><div class="line">    int times;</div><div class="line">    public void Init()</div><div class="line">    &#123;</div><div class="line">        PCB a = new PCB(1, 2, 0, 3, 1, true),</div><div class="line">            b = new PCB(2, 10, 2, 6, 1, true),</div><div class="line">            c = new PCB(3, 5, 4, 4, 1, true),</div><div class="line">            d = new PCB(4, 3, 6, 5, 1, true),</div><div class="line">            e = new PCB(5, 8, 8, 2, 1, true);</div><div class="line">        times = 1;</div><div class="line">        Ready.Add(e);</div><div class="line">        Ready.Add(d);</div><div class="line">        Ready.Add(c);</div><div class="line">        Ready.Add(b);</div><div class="line">        Ready.Add(a);</div><div class="line">        //对服务需要的时间needTime进行赋值</div><div class="line">        for (int i = 0; i &lt; Ready.Count; i++)</div><div class="line">            Ready[i].needTime = Ready[i].serveTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void Start()</div><div class="line">    &#123;</div><div class="line">        System.Console.WriteLine(&quot;高响应比优先调度算法(HRRN)&quot;);</div><div class="line">        System.Console.WriteLine(&quot;进程状态标志(State)：1：准备，2：正在运行&quot;);</div><div class="line">        System.Console.WriteLine(&quot;===================================================================================&quot;);</div><div class="line">        while (Ready.Count &gt; 0)</div><div class="line">        &#123;</div><div class="line">            PriorityChange();</div><div class="line">            Ready[0].state = 2;</div><div class="line">            System.Console.WriteLine(&quot;Id\t     Priority\t     ArriveTime\t       NeedTime\t    ServeTime\t    State\n&quot;);</div><div class="line">            // 输出单个时间片中全部进程的状态</div><div class="line">            // foreach (var item in Ready)</div><div class="line">            // &#123;</div><div class="line">            //     item.showState(1);</div><div class="line">            // &#125;</div><div class="line">            // 仅输出单个时间片运行中的进程状态</div><div class="line">            Ready[0].showState();</div><div class="line">            Ready[0].needTime--;</div><div class="line">            Ready[0].priority -= 3;</div><div class="line">            if (Ready[0].needTime == 0)</div><div class="line">            &#123;</div><div class="line">                Ready[0].state = 0;</div><div class="line">                System.Console.WriteLine(&quot;\t\t\t\t\t\t\t\t\tprocess &#123;0&#125; completed\n&quot;, Ready[0].id);</div><div class="line">                System.Console.WriteLine(&quot;===================================================================================&quot;);</div><div class="line">                Ready.RemoveAt(0);</div><div class="line">            &#125;</div><div class="line">            for (int i = 1; i &lt; Ready.Count - 1; i++)</div><div class="line">            &#123;</div><div class="line">                Ready[i].priority++;</div><div class="line">            &#125;</div><div class="line">            Thread.Sleep(1000);</div><div class="line">            System.Console.WriteLine(&quot;-----------------------------------------------------------------------------------&quot;);</div><div class="line">            System.Console.WriteLine(&quot;time:&#123;0&#125;&quot;, times);</div><div class="line">            times++;</div><div class="line">        &#125;</div><div class="line">        System.Console.WriteLine(&quot;                 All processes have been completed,takes &#123;0&#125; times\n&quot;, times - 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void PriorityChange()</div><div class="line">    &#123;</div><div class="line">        PCB temp = null;</div><div class="line">        //对优先权排序</div><div class="line">        for (int i = 0; i &lt; Ready.Count - 1; i++)</div><div class="line">        &#123;</div><div class="line">            for (int j = 0; j &lt; Ready.Count - i - 1; j++)</div><div class="line">            &#123;</div><div class="line">                if (Ready[j].priority &lt; Ready[j + 1].priority)</div><div class="line">                &#123;</div><div class="line">                    temp = Ready[j];</div><div class="line">                    Ready[j] = Ready[j + 1];</div><div class="line">                    Ready[j + 1] = temp;</div><div class="line">                &#125;</div><div class="line">                else if (Ready[j].priority == Ready[j + 1].priority) //优先权相同则短任务优先</div><div class="line">                &#123;</div><div class="line">                    if (Ready[j].serveTime &gt; Ready[j + 1].serveTime)</div><div class="line">                    &#123;</div><div class="line">                        temp = Ready[j];</div><div class="line">                        Ready[j] = Ready[j + 1];</div><div class="line">                        Ready[j + 1] = temp;</div><div class="line">                    &#125;</div><div class="line">                    else if (Ready[j].arriveTime &gt; Ready[j + 1].arriveTime) //服务时间相同则先到优先</div><div class="line">                    &#123;</div><div class="line">                        temp = Ready[j];</div><div class="line">                        Ready[j] = Ready[j + 1];</div><div class="line">                        Ready[j + 1] = temp;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="RR"><a href="#RR" class="headerlink" title="RR"></a><strong>RR</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">using System;</div><div class="line">using System.Threading;</div><div class="line">using System.Collections.Generic;</div><div class="line"></div><div class="line">class RR</div><div class="line">&#123;</div><div class="line">    List&lt;PCB&gt; Ready = new List&lt;PCB&gt;();</div><div class="line">    List&lt;PCB&gt; Block = new List&lt;PCB&gt;();</div><div class="line">    static int RR_PRIORITY = 15;</div><div class="line">    int times;</div><div class="line">    public void Init()</div><div class="line">    &#123;</div><div class="line">        PCB a = new PCB(1, 0, 3, 1, 1),</div><div class="line">            b = new PCB(2, 2, 6, 1, 1),</div><div class="line">            c = new PCB(3, 4, 4, 1, 1),</div><div class="line">            d = new PCB(4, 6, 5, 1, 1),</div><div class="line">            e = new PCB(5, 8, 2, 1, 1);</div><div class="line">        times = 1;</div><div class="line">        Ready.Add(e);</div><div class="line">        Ready.Add(d);</div><div class="line">        Ready.Add(c);</div><div class="line">        Ready.Add(b);</div><div class="line">        Ready.Add(a);</div><div class="line">        //对优先权priority与服务需要的时间needTime进行赋值</div><div class="line">        for (int i = 0; i &lt; Ready.Count; i++)</div><div class="line">        &#123;</div><div class="line">            Ready[i].priority = RR_PRIORITY - Ready[i].needTime;</div><div class="line">            Ready[i].needTime = Ready[i].serveTime;</div><div class="line">        &#125;</div><div class="line">        PCB temp = null;</div><div class="line">        //对优先权排序</div><div class="line">        for (int i = 0; i &lt; Ready.Count - 1; i++)</div><div class="line">        &#123;</div><div class="line">            for (int j = 0; j &lt; Ready.Count - i - 1; j++)</div><div class="line">            &#123;</div><div class="line">                if (Ready[j].priority &lt; Ready[j + 1].priority)</div><div class="line">                &#123;</div><div class="line">                    temp = Ready[j];</div><div class="line">                    Ready[j] = Ready[j + 1];</div><div class="line">                    Ready[j + 1] = temp;</div><div class="line">                &#125;</div><div class="line">                else if (Ready[j].priority == Ready[j + 1].priority)</div><div class="line">                &#123;</div><div class="line">                    if (Ready[j].serveTime &gt; Ready[j + 1].serveTime)</div><div class="line">                    &#123;</div><div class="line">                        temp = Ready[j];</div><div class="line">                        Ready[j] = Ready[j + 1];</div><div class="line">                        Ready[j + 1] = temp;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void Start()</div><div class="line">    &#123;</div><div class="line">        System.Console.WriteLine(&quot;时间片轮转(RR)&quot;);</div><div class="line">        System.Console.WriteLine(&quot;进程状态标志(procState):1：准备，2：正在运行&quot;);</div><div class="line">        System.Console.WriteLine(&quot;===================================================================================&quot;);</div><div class="line">        while (Ready.Count &gt; 0 || Block.Count &gt; 0)</div><div class="line">        &#123;</div><div class="line"></div><div class="line">            if (Ready.Count &gt; 0)</div><div class="line">            &#123;</div><div class="line">                Ready[0].state = 2;</div><div class="line">                System.Console.WriteLine(&quot;Id\t     Priority\t     ArriveTime\t       NeedTime\t    ServeTime\t    blockTime\t     State\n&quot;);</div><div class="line">                // 输出单个时间片中全部进程的状态</div><div class="line">                // foreach (var item in Ready)</div><div class="line">                // &#123;</div><div class="line">                //     item.showState(1);</div><div class="line">                // &#125;</div><div class="line">                // 仅输出单个时间片运行中的进程状态</div><div class="line">                Ready[0].showState(1);</div><div class="line">                Ready[0].needTime--;</div><div class="line">                if (Ready[0].needTime == 0)</div><div class="line">                &#123;</div><div class="line">                    Ready[0].state = 0;</div><div class="line">                    System.Console.WriteLine(&quot;\t\t\t\t\t\t\t\t\tprocess &#123;0&#125; completed\n&quot;, Ready[0].id);</div><div class="line">                    System.Console.WriteLine(&quot;===================================================================================&quot;);</div><div class="line">                    Ready.RemoveAt(0);</div><div class="line">                &#125;</div><div class="line">                else</div><div class="line">                &#123;</div><div class="line">                    Block.Add(Ready[0]);</div><div class="line">                    Ready.RemoveAt(0);</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                System.Console.WriteLine(&quot;Ready list is empty!&quot;);</div><div class="line"></div><div class="line">            Thread.Sleep(1000);</div><div class="line">            if (Block.Count &gt; 0)</div><div class="line">            &#123;</div><div class="line"></div><div class="line">                Block[0].blockTime--;</div><div class="line">                if (Block[0].blockTime == 0)</div><div class="line">                &#123;</div><div class="line">                    Block[0].blockTime = 1;</div><div class="line">                    Ready.Add(Block[0]);</div><div class="line">                    Block.RemoveAt(0);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            System.Console.WriteLine(&quot;-----------------------------------------------------------------------------------&quot;);</div><div class="line">            System.Console.WriteLine(&quot;time:&#123;0&#125;&quot;, times);</div><div class="line">            times++;</div><div class="line">        &#125;</div><div class="line">        System.Console.WriteLine(&quot;                 All processes have been completed,takes &#123;0&#125; times\n&quot;, times - 1);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a><strong>实验心得</strong></h2></blockquote><p>操作系统这门课程并不是教如何使用操作系统的，而是讲操作系统内部机制的。操作系统的目标是为用户提供一个良好的界面，方便用户使用计算机，同时对内部各种软硬件资源能够进行有效地管理和分配，使整个系统能高效率得运行。操作系统主要有五大功能：处理机管理、存储器管理、设备管理、文件管理、用户接口。我们现在使用的大多是 PC 机，都是只有一块 CPU，而有时却要在计算机上运行多个程序，那么每道程序在什么时候使用 CPU，这需要合理得分配协调才行，操作系统关于处理机的分配有相应的调度算法，这些工作都由操作系统实现。</p><p>这次综合实验利用 C#语言对 4 种调度算法进行了设计和模拟实现，并充分考虑了进程在执行过程中可能发生的多种情况，更好的体现了进程的就绪态和执行态二者之间的关系以及相互的转换。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h2 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的&quot; class=&quot;headerlink&quot; title=&quot;实验目的&quot;&gt;&lt;/a&gt;&lt;strong&gt;实验目的&lt;/strong&gt;&lt;/h2&gt;&lt;/blockquote&gt;
&lt;p&gt;用 C#语言编程实现对 N 个进程采用四种进程调度算法——先来先服务算法（FCFS）、短进程优先算法（SJF）、高响应比优先调度算法(HRRN)和时间片轮转调度算法（RR）调度执行模拟。&lt;/p&gt;
    
    </summary>
    
      <category term="C#" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C#" scheme="http://yoursite.com/source/tags/C/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/source/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>《太吾绘卷》是否能成为武侠迷期待的真正江湖？</title>
    <link href="http://yoursite.com/blog/%E3%80%8A%E5%A4%AA%E5%90%BE%E7%BB%98%E5%8D%B7%E3%80%8B%E6%98%AF%E5%90%A6%E8%83%BD%E6%88%90%E4%B8%BA%E6%AD%A6%E4%BE%A0%E8%BF%B7%E6%9C%9F%E5%BE%85%E7%9A%84%E7%9C%9F%E6%AD%A3%E6%B1%9F%E6%B9%96%EF%BC%9F20181013/"/>
    <id>http://yoursite.com/blog/《太吾绘卷》是否能成为武侠迷期待的真正江湖？20181013/</id>
    <published>2018-10-12T16:00:00.000Z</published>
    <updated>2020-03-16T19:19:07.798Z</updated>
    
    <content type="html"><![CDATA[<style type="text/css">img{text-align: center; margin: 0 auto;}</style><p><img src="http://c1oudust-blog.test.upcdn.net/201810TheScrollofTaiwu.png" alt="头图"></p><a id="more"></a><p>对于关注国产游戏的玩家来说，这段时间最火莫过于《太吾绘卷》了,我在耳闻目染后，便亲自体验了一番。这篇“测评”是我将在玩游戏中途即兴写的感受合在了一起，吐槽度比较大。下面开始正文。</p><p><img src="http://c1oudust-blog.test.upcdn.net/201810WuXia_game_recent.jpg" alt="最近的几款武侠风游戏"></p><p>其实这段时间以武侠为卖点的国产游戏不少，前些时候的《天命奇御》，最近刚上架的《侠隐行录：困境疑云》、《御俠客》以及即将上线的《河洛群侠传》。相比之下，《太吾绘卷》没有精美的人物与场景建模，没有爽快的实时打斗，却在短短十天内完成了 40 万销量的壮举。<br>在体验过太吾后，不得不大呼过瘾。游戏虽然还在 EA 阶段，但却足够复杂。玩家需要花足够多的时间去熟悉它的诸多玩法，这也正是《太吾绘卷》的魅力所在。玩过 P 社游戏的玩家会知道，通常需要 20 小时左右的时间才能完全上手这些游戏。</p><p><img src="http://c1oudust-blog.test.upcdn.net/201810jiyi.png" alt="各种技艺"></p><p>正所谓开放式江湖，《太吾绘卷》在设计上下了很多功夫。数百种可供修炼的武学以及中国传统技艺——木工、炼铁、医术、纺丝等等。高深的武功往往除了天资之外，还对应着相同的心法。一位行走江湖如鱼得水的侠客仅仅靠武功还不够，更需要有诗书礼乐方面的造诣。角色的立场参照了 DND 九宫盒，从刚正到唯我，玩家可以根据喜好选择选项，惩恶扬善还是唯我独尊，从而打造出属于自己的江湖侠客。下图为解包得到的功法数据，可以看到策划相当给力。</p><p><img src="http://c1oudust-blog.test.upcdn.net/201810Gongfu_Data.png" alt="解包得到的功法数据，可以看到策划相当给力。"></p><p>类似于《巫师》里的广为流传的昆特牌，《太吾绘卷》也引入了一个极其有趣的休闲玩法——促织决斗，说白了就是斗蛐蛐。作者确实在这个玩法中下了很大功夫——总共做了 35 种不同的蛐蛐动画，每种 80 帧，共占游戏 300M 左右。听说作者为了给蛐蛐写介绍，几乎翻烂了《促织经》。</p><p><img src="http://c1oudust-blog.test.upcdn.net/201810ququ.png" alt="促织"></p><p><strong>《太吾绘卷》的“成功”值得我们思考。</strong></p><p>国产游戏圈内曾一度掀起武侠游戏的热潮，从《仙剑系列》《轩辕剑》《金庸群侠传》这些老一辈的武侠 rpg 到前文所提到的现时期的武侠游戏。玩家一方面仍旧喜爱这些老游戏所创造出的武侠世界，另一方面又被这个概念过度消费，新兴的武侠游戏往往喜欢打“情怀”的旗号，实际上基本玩法还是没有太大改变。就目前而言，除了商业游戏，独立游戏依旧是武侠 rpg 的传统体系：“完成任务 → 提高属性 → 学武功心法 → 打败更强的敌人”，周而复始。而《太吾绘卷》的出现似乎让陈旧的武侠游戏环境生出了一缕新芽，这不仅仅在于其复杂的游戏系统，同样归功于太吾在 roguelike 随机性上的尝试——除了玩家，整个“江湖”中，人物的所有数据皆是随机生成。在给玩家带来新鲜感的同时，其弊端也不可不谈。随机生成的 NPC 只是一堆数据，相比以往的武侠游戏来说，他们毫无故事与感情，就如同《底特律》里尚未觉醒的仿生人。</p><p><strong>这是《太吾绘卷》在以往武侠游戏基础上的大胆尝试，也是其最大的不足之处。</strong></p><p>我们为什么喜欢武侠类游戏？比起读武侠小说和看武侠剧，武侠类游戏能给我们更好的代入感，然后我们置身于武侠的世界，体验一幕幕难忘的瞬间。我们玩《古剑奇谭》，会被百里屠苏、风晴雪一行人的经历而感动，而《太吾绘卷》中，这些随机生成的 NPC 并不能给我们足够的代入感。有人也许会说，这是一个 Roguelike 啊，数据本身就是随机的。诚然如此，但比起操纵一堆随机复制的 NPC，我还是更喜欢跟有血有肉的 NPC 交谈，在偌大的世界中听他们各自的故事。</p><p>在游戏设计上我们可以看到制作组的野心——模拟经营，角色扮演，地图探索…《太吾绘卷》几乎囊括了这些传统武侠和文字策略类游戏的所有玩法，制作组给所有玩法都构建了一套足够复杂的系统，但每一个系统，都做的不甚完美。拿太吾村的经营来说，玩家花大量时间收集资源在村子里建造的大多数建筑，只是为了对修炼或者制造提供方便，那些建筑完全可以在很多门派里找到啊，而一位侠客获得盘缠的方法，除了随地“卖艺”，居然只能靠村子里的产业。</p><p><img src="http://c1oudust-blog.test.upcdn.net/201810TaiwuVillage.png" alt="太吾村建筑"></p><p>在玩法上《太吾绘卷》最终还是没能完全脱离那一套传统体系。即使你在江湖中安安稳稳的学武，娶妻生子，或者隐居太吾村，游戏界面右上方的任务就会时刻提醒你：该去打 boss 了，不打 boss 提升支持度还怎么获得更好的武功？这样你就必须去把武功的等级和心法都修炼的更好，可悲的是，《太吾绘卷》的修炼系统，依然很复杂，很“浪费”时间，至少笔者在修炼的时候，只想快点了事，完全没有感觉到它的乐趣。而修炼的结果呢？《太吾绘卷》的战斗体系，按理说应该是武侠游戏中足够重要的系统，却做的极其简陋——有人戏称其为“回合制皮影戏”，不是没有道理。但这毕竟是一个文字游戏，不能表现出实时战斗的畅快场面也无可厚非，不过笔者还是希望这种一板一眼的回合打斗能够被一个更加灵活、更能体现出武侠风格的战斗模式替代。继续说地图探索，在创建人物界面中看到可供选择出生地点时，笔者可以说对地形系统比较感兴趣，但在玩游戏的过程中却大失所望。</p><p><img src="http://c1oudust-blog.test.upcdn.net/201810qipan.png" alt="略显单调的走棋盘玩法"></p><p>roguelike 或者沙盒的一大特点是什么？就是探索，而《太吾绘卷》在其玩法上却只是蜻蜓点水。地图中棋盘的地形可谓比较多样，但除了在获得资源数量和经过所需时间以外，完全没有任何区别，刨去提前可以看到的随机战斗事件和奇遇事件，整个随机生成的地图大而空，没有任何交互。在游戏中要从地图上的一个地方走到门派或者城市，只能一格一格走，在多次重复进行鼠标或者键盘的按压中，玩家的耐心也被渐渐消磨殆尽。</p><p>最后再就剧情吐槽一句：“都轮回了这么多世了，义父您在哪儿啊…”</p><p>说了这么多缺点，不能否认的是这款游戏依旧很好玩，比较贴近我心目中的武侠世界。笔者喜欢武侠，执着于独立游戏，当然对《太吾绘卷》抱有很大的期待。</p><p>现阶段的太吾绘卷，跟文章题目里的“真正江湖”相比还只是尚未长成的嫩芽，唯一知道的是，这朵花也许会很大，足以成为国产游戏万花丛中最独一无二的一朵。期待太吾正式版的发布，希望《太吾绘卷》能不负期待，成为武侠迷想象中真正的“会呼吸的江湖”。</p><p>以上</p>]]></content>
    
    <summary type="html">
    
      &lt;style type=&quot;text/css&quot;&gt;
img{text-align: center; margin: 0 auto;}
&lt;/style&gt;

&lt;p&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/201810TheScrollofTaiwu.png&quot; alt=&quot;头图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="测评" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%84/"/>
    
    
      <category term="游戏" scheme="http://yoursite.com/source/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="steam" scheme="http://yoursite.com/source/tags/steam/"/>
    
  </entry>
  
  <entry>
    <title>使用EasyX图形库编写2D游戏</title>
    <link href="http://yoursite.com/blog/%E4%BD%BF%E7%94%A8easyx%E5%9B%BE%E5%BD%A2%E5%BA%93%E7%BC%96%E5%86%992D%E6%B8%B8%E6%88%8F20180723/"/>
    <id>http://yoursite.com/blog/使用easyx图形库编写2D游戏20180723/</id>
    <published>2018-07-22T16:00:00.000Z</published>
    <updated>2018-11-03T05:25:24.893Z</updated>
    
    <content type="html"><![CDATA[<p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20187Flappy_Paper_Plane_menu.png" alt=""><br><a id="more"></a></div></p><h2 id="什么是-EasyX"><a href="#什么是-EasyX" class="headerlink" title="什么是 EasyX"></a>什么是 EasyX</h2><p>一言以蔽之，EasyX 是一个 C++ 图形库，封装了一些基本的绘图函数，可以实现在控制台窗口绘制图像，帮助 C/C++语言初学者快速上手图形编程。</p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>那么如何使用呢？<br>首先去它的<a href="https://www.easyx.cn/downloads/" target="_blank" rel="external">官网</a>下载安装包，选择对应的 VS 版本，可以看到这个库虽然年代比较久远，不过也对新版本的 VS 有所支持。<br>由于我使用的是 VS2017，所以下载最新的 2018 春分版。下载好解压，双击安装，库文件就会一键安装到你的 VS 路径里。<br>然后在项目里引用头文件 graphics.h 就可以使用了。<br>我们可以在 EasyX 官网的<a href="https://www.easyx.cn/samples/" target="_blank" rel="external">范例程序</a>里看到很多免费的小项目和例子，再结合官网的入门教程，就可以很轻松的入门了。</p><h2 id="开始设计"><a href="#开始设计" class="headerlink" title="开始设计"></a>开始设计</h2><p>这里我用它来设计一个基础的小游戏 —— Flappy Paper Plane。<br>游戏类似 Flappy Bird ,玩家控制纸飞机躲避障碍。</p><h3 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h3><p>本程序应完成以下几方面的功能：</p><ul><li><p>开始界面菜单的显示；</p></li><li><p>通过按键对玩家进行控制；</p></li><li><p>实现障碍物的自动移动；</p></li><li><p>游戏结束提示。</p></li></ul><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><ul><li>整个游戏流程放在一个 while 循环中。</li><li>通过控制图片坐标来实现玩家的上下移动和障碍物的左右移动。</li><li>程序函数模块：<ul><li>初始化游戏数据 initGame()</li><li>加载游戏所需位图 loadImages()</li><li>控制玩家移动 fly()</li><li>控制障碍物移动 thornMove()</li><li>碰撞检测 judgement()</li><li>打印图像 print()</li></ul></li></ul><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>首先创建玩家和障碍物的结构体，用结构体以便后续对游戏功能进行拓展。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thornPoint</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">int</span> y;</div><div class="line">&#125;thornPoint;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">playerPoint</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">int</span> y;</div><div class="line">&#125;playerPoint;</div></pre></td></tr></table></figure><h4 id="初始化游戏数据"><a href="#初始化游戏数据" class="headerlink" title="初始化游戏数据"></a>初始化游戏数据</h4><p>包括创建绘图窗口，初始化坐标系，初始化角色与障碍物坐标。</p><p>首先使用 initgraph 函数用来创建一个 1000x600 大小的绘图窗口。</p><p>由于图形库默认坐标原点在窗口左上角，因此将其设置为常见的平面直角坐标系以便于坐标计算。但由于将坐标系倒过来了，因此要求图片文件也是倒过来的，这样加载进绘图窗口中就是正的了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setorigin(<span class="number">0</span>, <span class="number">600</span>);</div><div class="line">setaspectratio(<span class="number">1</span>, <span class="number">-1</span>);</div></pre></td></tr></table></figure><p>接下来对玩家和障碍物坐标的初始化。完整代码段如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">initgraph(HORIZONAL, VERTICAL);   <span class="comment">// 创建绘图窗口</span></div><div class="line">setorigin(<span class="number">0</span>, <span class="number">600</span>);      <span class="comment">//设置坐标原点</span></div><div class="line">setaspectratio(<span class="number">1</span>, <span class="number">-1</span>);  <span class="comment">//设置为直角坐标系</span></div><div class="line"></div><div class="line">srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>)); <span class="comment">//初始化障碍物与玩家坐标</span></div><div class="line">thornPoint.y = <span class="number">-300</span>;</div><div class="line">thornPoint.x = <span class="number">950</span>;</div><div class="line">playerPoint.x = <span class="number">400</span>;</div><div class="line">playerPoint.y = <span class="number">300</span>;</div><div class="line">isDead = <span class="literal">false</span>;</div><div class="line">speed = <span class="number">0</span>;</div></pre></td></tr></table></figure><h4 id="加载游戏所需位图"><a href="#加载游戏所需位图" class="headerlink" title="加载游戏所需位图"></a>加载游戏所需位图</h4><p>我们需要实现一个图片的背景透明，方法之一就是使用位图的掩码图。</p><p>拿玩家的图片为例：</p><p>掩码图中想要显示的区域为黑色，想透明的区域为白色，如下：</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20187fly.png" alt=""></div></p><p>用 loadimage 函数将所有位图素材的引用保存到定义好的 IMAGE 变量中。拿玩家的位图为例,后两个参数为图片的尺寸（毫米）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IMAGE player,player_;</div><div class="line">loadimage(&amp;player, <span class="string">L"res\\fly.bmp"</span>, <span class="number">120</span>, <span class="number">46</span>);</div><div class="line">loadimage(&amp;player_, <span class="string">L"res\\flyx.bmp"</span>, <span class="number">120</span>, <span class="number">46</span>);</div></pre></td></tr></table></figure><h4 id="控制玩家与障碍物移动"><a href="#控制玩家与障碍物移动" class="headerlink" title="控制玩家与障碍物移动"></a>控制玩家与障碍物移动</h4><p>采用两个变量 isPress 和 speed 控制玩家自然下落和按键上升。<br>当没有按下按键时，此时检测 isPress 的值为 false，玩家坐标下移。<br>当按下按键时，isPress 为 true，这是给 speed 一个值，即为按下按钮时玩家上升的速度。判断速度是否为 0，不为 0 时玩家坐标上移，speed 递减直到为 0。<br>这部分代码段如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">ispress = <span class="literal">false</span>;</div><div class="line"><span class="keyword">if</span> (isPress == <span class="literal">false</span>)</div><div class="line">&#123;</div><div class="line"> playerPoint.y -= <span class="number">1</span>;<span class="comment">//下落</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (_kbhit())<span class="comment">//读取空格</span></div><div class="line">&#123;</div><div class="line">key = _getch();</div><div class="line"><span class="keyword">if</span> (key == <span class="string">' '</span>)</div><div class="line">&#123;</div><div class="line">  speed = <span class="number">40</span>;</div><div class="line">  isPress = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(;speed != <span class="number">0</span>;speed --;)</div><div class="line">&#123;</div><div class="line">    playerPoint.y += <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>控制障碍物移动：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thornPoint.x -= <span class="number">2</span>;</div></pre></td></tr></table></figure><p>使边界坐标判断，使障碍物在离开窗口最左边时回到窗口最右边，并且随机一个纵坐标值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (thornPoint.x &lt;= <span class="number">-100</span>)</div><div class="line">&#123;</div><div class="line">    thornPoint.y = -(rand() % <span class="number">250</span> +<span class="number">100</span>);</div><div class="line">    thornPoint.x = <span class="number">950</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h4><p>使用坐标是否重叠来判断碰撞。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( playerPoint.y &lt;= <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">    isDead = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (playerPoint.y &lt; thornPoint.y + <span class="number">580</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (playerPoint.x + <span class="number">120</span> == thornPoint .x+ <span class="number">50</span> || playerPoint.x == thornPoint.x + <span class="number">50</span>)</div><div class="line">       isDead = <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="将位图输出至绘图窗口"><a href="#将位图输出至绘图窗口" class="headerlink" title="将位图输出至绘图窗口"></a>将位图输出至绘图窗口</h4><p>使用 putimage 函数，拿玩家位图为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">putimage(playerPoint.x, playerPoint.y, &amp;player_, SRCAND);</div><div class="line">putimage(playerPoint.x, playerPoint.y, &amp;player, SRCPAINT);</div></pre></td></tr></table></figure><p>putimage 函数的最后一个参数为三元光栅操作码，代表屏幕颜色和图像颜色的叠加方式，SRCAND 是 AND 方式，而 SRCPAINT 是 OR 方式，大概意思就是：</p><p>白色(1)&amp;任何颜色=原颜色，黑色(0)&amp;任何颜色=黑色,黑色(0)| 任何颜色=原颜色</p><h3 id="游戏效果"><a href="#游戏效果" class="headerlink" title="游戏效果"></a>游戏效果</h3><p><img src="http://c1oudust-blog.test.upcdn.net/20187plane_gameing.png" alt=""></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><ul><li>这个项目是我在课设中做的一个相当简陋的 demo，本来想做成 3D 视角，不过因为时间关系就放弃了。当时只实现了基本功能，甚至连计分功能的没有，不过作为 EasyX 的初学者示范程序来说还是很不错的。</li><li>游戏背景来自画师 Philip Govedare，很喜欢他笔下的天空和大地。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/20187Flappy_Paper_Plane_menu.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="EasyX" scheme="http://yoursite.com/source/tags/EasyX/"/>
    
  </entry>
  
  <entry>
    <title>C#中的结构和类</title>
    <link href="http://yoursite.com/blog/CSharp%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E7%B1%BB20180629/"/>
    <id>http://yoursite.com/blog/CSharp中的结构和类20180629/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2019-02-10T07:17:20.653Z</updated>
    
    <content type="html"><![CDATA[<p>对于C/C++而言，结构和类的差别非常小，而在C#中，很多时候，只是声明的时候关键字一个是class，一个是struct而已。<br><a id="more"></a></p><p>以下定义一个结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public struct MyStruct</div><div class="line">&#123;</div><div class="line">    private string MyString;</div><div class="line">    private int MyNum;</div><div class="line">    public string MyString</div><div class="line">    &#123;</div><div class="line">        get</div><div class="line">        &#123;</div><div class="line">            return MyString;</div><div class="line">        &#125;</div><div class="line">        set</div><div class="line">        &#123;</div><div class="line">            MyString = value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public int GetMyNum()</div><div class="line">    &#123;</div><div class="line">        return MyNum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到结构体和类非常相似,但细纠起来，还是有很多的不同。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul><li>结构属于值类型，继承自System.ValueType，值类型在堆栈上分配地址。值类型能够降低垃圾回收，表现出更好的性能。但其也有不好的一面，比如会涉及到装箱拆箱等操作,因此不适合处理逻辑复杂的对象。所有基类型都是结构类型，如int 对应的是System.int32结构。</li><li>对于值类型，编译器既不会生成默认构造函数。也不会调用默认构造函数。因此C#不允许结构体有无参的默认构造函数。结构体的构造函数内必须初始化所有变量。</li><li>结构体对象之间赋值是创建新的结构，结构体不能从另外的结构继承，本身也不能够被继承，虽然结构没有明确的用 sealed 声明，可是结构是隐式的 sealed。</li><li>虽然结构不能被继承 可是结构能够继承接口，方法和类继承接口一样。</li></ul><h3 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h3><blockquote><ul><li>没有默认的构造函数，但是能够添加构造函数；</li><li>没有析构函数；</li><li>没有abstract和sealed，不能有protected修饰符；</li><li>可以不使用new实例化；</li><li>在结构初始化实例字段是错误的。</li></ul></blockquote><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul><li><p>类是属于引用类型，继承自System.Object，引用类型是在堆上面分配地址。类对象之间的赋值是通过复制引用实现的。</p></li><li><p>如何不加sealed修饰符，类是可以继承其他类和接口且本身也可被继承。</p></li></ul><h3 id="内部结构-1"><a href="#内部结构-1" class="headerlink" title="内部结构"></a>内部结构</h3><blockquote><ul><li>有默认的构造函数；</li><li>有析构函数；</li><li>可以使用abstract和sealed，有protected修饰符；</li><li>必须使用new初始化。</li></ul></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>堆栈的空间有限，对于有大量逻辑的复杂对象，使用类比结构体好一些。</li><li>在表示抽象和多级别层次的对象时，使用类是更好的选择。</li><li>在大多数情况下对象的类型只是数据时，使用结构是最好的选择。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于C/C++而言，结构和类的差别非常小，而在C#中，很多时候，只是声明的时候关键字一个是class，一个是struct而已。&lt;br&gt;
    
    </summary>
    
      <category term="C#" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C#" scheme="http://yoursite.com/source/tags/C/"/>
    
      <category term="strcut" scheme="http://yoursite.com/source/tags/strcut/"/>
    
  </entry>
  
  <entry>
    <title>阻止我们成功的，只有懒惰</title>
    <link href="http://yoursite.com/blog/%E9%98%BB%E6%AD%A2%E6%88%91%E4%BB%AC%E6%88%90%E5%8A%9F%E7%9A%84%EF%BC%8C%E5%8F%AA%E6%9C%89%E6%87%92%E6%83%B020180625/"/>
    <id>http://yoursite.com/blog/阻止我们成功的，只有懒惰20180625/</id>
    <published>2018-06-24T16:00:00.000Z</published>
    <updated>2020-03-16T19:27:11.887Z</updated>
    
    <content type="html"><![CDATA[<style type="text/css">img{text-align: center; margin: 0 auto;}</style><p><img src="http://c1oudust-blog.test.upcdn.net/2018638631998_p0_master1200.jpg" alt="id=38631998" title="流星雨 id=38631998"></p><a id="more"></a><p>在一次和舍友的聊天中，我们谈到一个现实中的朋友。</p><p>他刚上大学的时候就很活跃，当我们还在努力将同学的脸和名字对号入座的时候，他就已经在人际关系上八面玲珑了。这些体现在他日常打交道的点滴中 —— 经常去各个宿舍串门、偶尔会送一些水果或零食、私下里会主动去帮老师忙 —— 就连几个比较严厉的老师都对他赞赏有加。</p><p>我当时甚至觉得他几乎把所有的时间都花在了社交和经营关系上。而事实上我个人不太喜欢跟这种人交往，除了不擅长应对他们外，主要是因为我的交际观念在于宜精不宜多，况且我也没有大量时间去跟无论圈内还是圈外的多数人，都维持长时间的优质关系。但这并不影响我对他的佩服，佩服一个能把人脉资源转化为价值的人。</p><p>从认识他第一天起，我就能感受到他身上某种独特的人格魅力。像是对任何事都保持乐观，经常露出自信的微笑，做事果断不拖泥带水之类的话，都不足以完全概括他整个人。而对于外貌，我唯一印象深刻的就是他笑起来有两个酒窝，很甜。</p><p>一个聪明人从来不会去做没有意义的事，之后，这些人脉关系理所当然的有了用武之地。大一的时候，大多数学生处于娱乐状态，他和大四的几个学生合作创办了一家校园外卖，之后因为一些问题变卖了这份“事业”，但这便是他“创业”的开端。在大二到大三两年期间，他成功为学校做了另一个，也学校里唯一一个能直接送到宿舍的校园外卖。之后他垄断了学校的快递产业 —— 整合成统一的快递柜，极大了提高学生寄收快递的效率。他还是学校附近很多培训机构的代理，经常可以看到他活跃于各大兼职群…… 在创业过程中，他的魅力博得了女神的青睐，可以说是“事业与爱情双收”了。在朋友圈，时常能看到他饭局的照片，还带有一些激励性话语。</p><p>当舍友讨论到为什么我们成为不了他那样的人时，我插了一句：因为懒。</p><p>这句话便引起了一次思想碰撞，他们坚持认为成功不是我想的那么容易，更重要的是金钱、人脉和机会，而勤奋，只不过是满足了所有前提之后的理所当然的手段罢了，勤奋相比这些而言根本不值一提。</p><p>对成功而言，金钱、人脉、机遇的确必不可少，但我想，当一个人有这种想法时，他在这件事上的失败就已经注定了。</p><p><img src="http://c1oudust-blog.test.upcdn.net/2018616317335_p0_master1200.jpg" alt="id=16317335" title="流星雨 id=16317335"></p><p>朋友创业的过程，在我眼里其实并没有那么的举步维艰，也没有传说中的“浸透了奋斗的泪泉, 洒遍了牺牲的血雨”，只是认准了目标，以力所能及的方式努力着。很多人喜欢用成功者的天赋或者机遇来进行自我安慰，不是因为天生智商或者后天情商上的差距，只是因为懒，懒到不敢去想自己怎么去做，懒到不愿意付出，懒到想付出立刻就有回报，懒到想不付出就能坐享其成。</p><p>还没有开始，就放弃了，实在可悲。反过来想想，成功人士之所以很少，就是因为有很多还没有做就放弃了的人，再加上做了一半放弃的人，而真正成功的不就是那些坚持到最后的人吗？ 在很多人望洋兴叹感慨自己余力不足的时候，另一些人在默默努力着，他们就是下一个成功者。</p><p>大学是人生的一个分水岭，也是一个小型社会 —— 你会见到形形色色的人。有刻苦学习然后考研走上光明仕途的人，有在人际交往中游刃有余利用人脉获取利益的人，有着迷于某个事物最后在其兴趣领域获得良好评价的人，也有放弃学习娱乐至上最后凭借关系获得权势的人。每当你想要批判别人的时候，你就要记住，这个世界上并不是人人都有你的优越条件，换句话说，你的优势并不是与生俱来的天赋，而是很多人或者是你努力的结果。</p><p>很多人把成功人士的成功看作是在极其恶劣竞争中所诞生的幸运儿，换句话说，就是换了时间、地点、人物，就不可能成功。从某种意义上来说的确如此，但他们的高估往往使他们感到恐惧，因而面对成功，理所当然地认为自己无法达到，而当有人满怀热血的想去尽力争取时，他们便不屑一顾，甚至对其冷嘲热讽。把别人与他们置于同一种境地 —— 自己无法达到的目标，面对那遥遥领先的成功者，其他人又如何达到呢？</p><p>他们并没有看到成功者努力的身影，也没用有看到成功者被像他们一样的人讽刺时的眼神，只是自以为自己看的很透 —— “那些成功者都是妖孽中的妖孽，是我们这种凡人无论怎么努力也达不到的存在，你看，我就是因为知道自己根本达不到才放弃追求成功，而进去自己的舒适区中，舒服地过着美好的每一天，难道不好吗？明知道自己没有天赋，还非要去争取的愣头青，等你失败，就会知道我现在的话都是苦口良药了” —— 他们经常这么安慰自己，并以此规劝想要为成功付出的年轻人，想让他们不思进取，让他们满足于当前暂时舒适的生活，让他们最终成为自己。</p><p>阻止我们成功的，永远都是懒惰。有很多时候我们自甘堕落，躺在床上刷一天微博或抖音，看一下午直播，通宵玩游戏。可是后来想想，为什么要花这么多宝贵的时间到这些为了消遣而诞生的东西上呢？因为我们害怕付出得不到收获，我们更喜欢轻松地达成目的，这就是人类，从古至今，人类的每一个发明不都是为了方便自己吗。而现代不需要这样了，即使足不出户，只需要一部手机，我们也能轻松获得精神愉悦感。大多数情况下，比起成功的喜悦感，人们更喜欢这些很轻松就能获得的精神愉悦感，即使他们转瞬即逝，不过并不重要，他们很乐意投入更多的时间来维持这种愉悦感。</p><p>归根结底，成功者成功的原因，不单在于勤奋，而失败者之所以失败，只是因为懒。</p>]]></content>
    
    <summary type="html">
    
      &lt;style type=&quot;text/css&quot;&gt;
img{text-align: center; margin: 0 auto;}
&lt;/style&gt;

&lt;p&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/2018638631998_p0_master1200.jpg&quot; alt=&quot;id=38631998&quot; title=&quot;流星雨 id=38631998&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/source/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="思想" scheme="http://yoursite.com/source/tags/%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Windows10下使用Linux的另一种方式 —— WSL与其桌面环境安装</title>
    <link href="http://yoursite.com/blog/Windows10%E4%B8%8B%E4%BD%BF%E7%94%A8Linux%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%20%E2%80%94%E2%80%94%20WSL%E4%B8%8E%E5%85%B6%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%8520180509/"/>
    <id>http://yoursite.com/blog/Windows10下使用Linux的另一种方式 —— WSL与其桌面环境安装20180509/</id>
    <published>2018-05-08T16:00:00.000Z</published>
    <updated>2018-11-03T05:24:44.011Z</updated>
    
    <content type="html"><![CDATA[<p>早在 Build 2016 上，微软就介绍了处于 Beta 阶段的 Windows 下的 Linux 子系统 —— Windows Subsystem for Linux（WSL），它可以让开发者们在 Windows 10 下不需要虚拟机就可以运行 Linux 系统。</p><a id="more"></a><h3 id="Ubuntu-子系统的安装"><a href="#Ubuntu-子系统的安装" class="headerlink" title="Ubuntu 子系统的安装"></a>Ubuntu 子系统的安装</h3><p>为了体验这一功能，需要在<code>控制面板-&gt;程序和功能-&gt;启用或关闭Windows功能</code> 中 开启 WSL 服务，如图所示：</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185OpenWSLService.png" alt=""></div></p><p>也可以通过在 PowerShell(管理员) 运行以下命令开启开启</p><p><code>Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</code></p><p>之后在设置里开启开发人员模式</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185developerMode.png" alt=""></div></p><p>然后在 Windows 的应用商店里就能只能下载想要体验的 Linux 子系统了。可以看到它提供了很多类型的 Linux 系统，这里就选择我最喜欢的 Ubuntu Linux 来做演示。</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185WSLwindowstore.png" alt=""></div></p><p>等待安装完成后，点击开始菜单里的 Ubuntu 图标或者在 powershell 里输入<code>bash</code>即可启动 Ubuntu Linux 子系统。等待了几分钟的初始化之后，我们输入用户名和密码（可以跳过），然后就能看到 Ubuntu 的命令行界面了.</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185ubuntuOnWindows.png" alt=""></div></p><p>在刚安装好 WSL 后，与普通实体机上的 Ubuntu 系统一样，需要更新软件列表和软件包：<br><code>sudo apt update</code><br><code>sudo apt upgrade</code></p><p>这样就可以像使用普通 Ubuntu 系统一样使用 WSL 了。</p><h3 id="桌面环境的安装与启动"><a href="#桌面环境的安装与启动" class="headerlink" title="桌面环境的安装与启动"></a>桌面环境的安装与启动</h3><p>WSL 的方便之处就在于它和双系统的 Linux 没有很大区别，并且比虚拟机性能更快一点。美中不足的是，WSL 并没有自带图形化界面，因此如果想要运行桌面应用，就不禁徒叹奈何了。<br>不过在 WSL 推出不久，就有大神提供了 WSL 安装桌面环境的方法，并发到了 WSL github 的 issues 里：<a href="http://t.cn/R3AWMQo" target="_blank" rel="external">Run any Desktop Environment in WSL</a></p><p>根据这个教程，我们就可以在 WSL 里安装桌面环境以获得比较完整的体验。</p><ul><li><p><strong>安装 X-Windows</strong></p><p>可供选择安装的 X-Windows 有多个：VcXsrv Windows X Server、Xming、Cygwin X Server，教程中选择的是 VcXsrv，因为比较容易和稳定。</p><p>软件首页：<br><a href="https://sourceforge.net/projects/vcxsrv/" target="_blank" rel="external">https://sourceforge.net/projects/vcxsrv/</a></p><p>下载地址：<br><a href="https://ncu.dl.sourceforge.net/project/vcxsrv/vcxsrv/1.19.3.3/vcxsrv-64.1.19.3.3.installer.exe" target="_blank" rel="external">https://ncu.dl.sourceforge.net/project/vcxsrv/vcxsrv/1.19.3.3/vcxsrv-64.1.19.3.3.installer.exe</a></p><p>安装后首次启动会自动进入界面设置。</p><p>选择：“one large window”，Display number 设置成 0，其它默认：</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185Xwindow.png" alt=""></div></p></li><li><p><strong>WSL 安装桌面环境</strong></p><p>这里选择安装 unity 桌面环境，我们同样可以选择 xfce4 桌面环境。</p><p>在 bash 下执行 <code>sudo apt-get install ubuntu-desktop unity compizconfig-settings-manager</code></p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185installdesktop.png" alt=""></div></p><p>需要提醒的是，Ubuntu 桌面版自带的 unity 桌面环境与依赖包有 600 多 M，解压之后近 2.6G，所以前提需要保证足够的磁盘空间。</p></li><li><p><strong>配置 compiz 并运行桌面环境</strong></p><p>启动 X-Windows，在 Bash 中执行：</p><p><code>export DISPLAY=localhost:0</code></p><p><code>ccsm</code></p><p>在 X-windows 中，即会弹出 ccsm 的配置界面，勾选需要的 Desktop 组件（只需要勾选 Desktop 中的 Ubuntu Unity Plugin 即可，其它默认）：</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185ccsm.png" alt=""></div></p><p>点击 close 关闭 ccsm，执行 compiz，短暂的加载后，在 X-windows 的界面中就能看到桌面版的 Ubuntu 了。</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185compiz.png" alt=""><br><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185UbuntuDesktoponWSL.png" alt=""></div></div></p></li></ul><h3 id="其他推荐"><a href="#其他推荐" class="headerlink" title="其他推荐"></a>其他推荐</h3><p>关于 WSL 的玩法有很多，可以参照：<a href="http://t.cn/RtbzH6h" target="_blank" rel="external">玩转 Windows 10 中的 Linux 子系统</a> 和 <a href="http://t.cn/RTsqoVJ" target="_blank" rel="external">Windows10 内置 Linux 子系统初体验</a></p><p>这里推荐一个软件 —— <a href="https://goreliu.github.io/wsl-terminal/README.zh_CN.html" target="_blank" rel="external">wsl-terminal</a>，用于 WSL 的终端模拟器，基于 mintty 和 wslbridge。github 上有很全的中文文档，添加了很多实用功能，可以利用终端做更多很酷很有趣的事~</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185cmatrix.gif" alt=""></div></p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185w3cbaidu.png" alt=""></div></p><p>自此，开始折腾自己的 Linux 吧~</p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早在 Build 2016 上，微软就介绍了处于 Beta 阶段的 Windows 下的 Linux 子系统 —— Windows Subsystem for Linux（WSL），它可以让开发者们在 Windows 10 下不需要虚拟机就可以运行 Linux 系统。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="http://yoursite.com/source/tags/Ubuntu/"/>
    
      <category term="Windows" scheme="http://yoursite.com/source/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>腾讯没梦想，自媒体有春梦</title>
    <link href="http://yoursite.com/blog/%E8%85%BE%E8%AE%AF%E6%B2%A1%E6%A2%A6%E6%83%B3%EF%BC%8C%E8%87%AA%E5%AA%92%E4%BD%93%E6%9C%89%E6%98%A5%E6%A2%A620180509/"/>
    <id>http://yoursite.com/blog/腾讯没梦想，自媒体有春梦20180509/</id>
    <published>2018-05-08T16:00:00.000Z</published>
    <updated>2018-11-03T05:26:03.115Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185mmexport1525840185248.jpg" alt=""><br></div><a id="more"></a><blockquote><p>这是一个辜负了曾经那些认真的文字工作者的疯狂流量时代，这是一个读者平均阅读水平 low 穿地球的时代，写爆文成了考量自媒体水平的最大标准，于是就不管文章观点是否客观，不管论述是否符合逻辑，只管大把写，然后大把捞钱。这些自媒体人现在看到了商机，一个个都摇身一变成了天才，自己是个太监没有阴茎就能教你性交，自己考不上清华北大就能教你高效学习法，自己没法成功就能教你成功，自己没法自律就能教你自律，自己写的东西像狗屎一样就能教你写作，自己没有大公司的管理经验能教几千亿市值公司的老板怎么开公司。</p></blockquote><p>&emsp; &emsp; &emsp;&emsp; &emsp; &emsp;&emsp; &emsp; &emsp;&emsp; &emsp; &emsp;&emsp; &emsp; &emsp;&emsp; &emsp; &emsp;&emsp; &emsp; &emsp;&emsp; &emsp; &emsp;——语出俄罗斯著名作家，诺贝尔文学奖获得者沃兹基·硕德</p><p>因为一篇阅读量百万+的批评腾讯的雄文，这两天科技圈已然完全炸掉了，所有大佬和互联网人士都在讨论腾讯到底有没有梦想……</p><p>首先刷屏的原文是这个:<br><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDczODM3Mw==&amp;mid=2653028142&amp;idx=1&amp;sn=0dd174c676138016803af3d9ac77e919&amp;scene=21#wechat_redirect" target="_blank" rel="external">《腾讯没有梦想》</a></p><p>然后因此冒出了无数反驳的文章，比如：</p><p>《驳腾讯没有梦想》</p><p>《谁说腾讯没有梦想？》</p><p>《讨论“腾讯的梦想”是个伪命题》</p><p>《腾讯需要有梦想吗》</p><p>《讨论腾讯有没有梦想，不是大课是唠嗑》</p><p>《难以让人信服的“腾讯没有梦想”》</p><p>《腾讯没有梦想？只是你不希望 ta 有罢了》</p><p>……</p><p>不知道大家看到这么多七七八八的标题的时候，是什么感受，反正我觉得有点辣眼睛……</p><p>总之我当时的关注点，并不是这篇文章到底说的对不对，而是觉得非常有趣，<strong>因为这算是一个非常成功的传播学案例。</strong></p><p>这篇文章作者作为一个资深编辑，深谙写出传播能力广文章的诀窍，其行文手法之高明，令人叹服，所以这篇文章就是来分析这位编辑的“高明”手法的。至于他写的到底正确与否，嘿嘿。</p><h3 id="用极端和奇葩的观点博人眼球"><a href="#用极端和奇葩的观点博人眼球" class="headerlink" title="用极端和奇葩的观点博人眼球"></a>用极端和奇葩的观点博人眼球</h3><p>这篇文章的标题就是这样，《腾讯没有梦想》这六个字，观点<strong>非常极端，博人眼球</strong>，我相信大部分人在朋友圈看到这样的标题，都会去点开。</p><p>越极端的观点越能吸引人，这是一个被媒体人玩烂了的道理，相关的案例随手拈来，例如几个小时前罗永浩发了篇微博，声称“<strong>5 月 15 号（锤子发布会）之后失去灵魂的苹果将会疯狂的抄袭我们。”</strong>：</p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185mmexport1525840189719.jpg" alt=""><br></div><p>是个人都能看出，没有人会相信罗永浩的这么一套言论，罗永浩是在用奇葩的观点吸引眼球，就算转发他微博和观点的人全部都是在骂他，<strong>他的目的仍然达到了——为了给锤子发布会造势吸引流量。</strong></p><p>罗永浩并不是第一次使用这样的技巧，前两年罗永浩就说过自己以后会收购“必将衰落的苹果”，有网友认为这种手段很低劣，但事实却证明每次都非常的奏效，尴尬的是，在吐槽罗永浩的同时，这篇文章也同样陷入了罗永浩想要吸引流量的圈套。</p><h3 id="用废话式的论述和结论，来显得自己很有道理"><a href="#用废话式的论述和结论，来显得自己很有道理" class="headerlink" title="用废话式的论述和结论，来显得自己很有道理"></a>用废话式的论述和结论，来显得自己很有道理</h3><p>文中似乎下了很多结论性的东西，乍一看还非常有道理的样子，包括但不限于以下几句：</p><blockquote><p>“市场还有机会，但机会不一定再属于腾讯。”</p><p>“腾讯内部的数据并不互通，腾讯内部各部门的冲突和分化导致腾讯在整体上无法形成统一而强有力的战略和执行”。</p><p>“原本的确定性红利吃完了，腾讯的优势就不一定是绝对垄断性的了。 ”</p></blockquote><p>上面分别引用了文中的三处内容，发现什么共同特征没有？</p><p>这些经过一番论述后产生的结论性的句子，初看起来都宛如箴言一般，鞭辟入里，一副极为有道理的样子。</p><p>但仔细思考你就会发现，这其实都是废话。</p><p>第一句，套在任何公司上都不违和……谁都知道市场上还有机会，谁都知道机会不一定属于自己公司……</p><p>第二句，这很明显是大公司的通病，直到现在也没人能拿出解决方案，潘乱把大公司的通病写出来是想做什么，自己能拿出解决方案吗？方案呢？不过一个写自媒体的编辑，就想解决那么多大企业的管理人才都解决不了的事情吗？只能说勇气可嘉，天真烂漫。</p><p>第三句也很明显是废话，因为对于未来发生的事情，这世上几乎就没有多少真正一定的事情。即便是明天早上太阳会不会升起，也没人敢说一定，因为万一小行星撞地球世界毁灭了呢？更何况是一个公司未来的发展呢。</p><p>这种废话型的结论，看似愚蠢，但实则杀伤力很强，很多鸡汤也运用了类似的语言技巧，因为大家通读下来找不到这些结论的毛病，很多思考能力不强的人就觉得说的非常正确，很有道理什么的，但仔细想想就会发现说的都是一些不痛不痒、毫无营养的废话。</p><h3 id="以偏概全与错误归因"><a href="#以偏概全与错误归因" class="headerlink" title="以偏概全与错误归因"></a>以偏概全与错误归因</h3><p>什么叫错误归因呢？</p><p>还是举文中的例子。作者把王者荣耀没有成功出海，和绝地求生手游版在海外的成功做对比，论证出了王者荣耀开发的时候，因为没有考虑版本全球化所以才会出海失败，而绝地求生手游因为考虑了版本全球化所以才成功。</p><p>这就犯了错误归因的错误，是个人都知道，绝地求生是一个早就在全球非常火的电脑端网游了，腾讯拿到绝地求生的正版授权后，做出来的手游只要不太差，在国外一定会大火，和什么版本全球化关系很小。为什么，因为电脑版玩家的受众明明白白的摆在那了啊！而王者荣耀不同，本身就是一个本土化的游戏，出海困难很正常啊，这怎么能类比呢？</p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185PUBG.jpg" alt=""><br></div><p>至于以偏概全的例子就太多了。例如，是个人都知道，腾讯在游戏这一块，尤其是手游，对于中国的其他企业几乎是碾压级别的优势，其他的企业……几乎一个能打的都没有……</p><p>但是你要搞清楚，作者可是想证明“腾讯没有梦想”啊！怎么能容忍腾讯这种霸主级别的碾压呢！要知道，腾讯可是一个没有梦想的公司啊！</p><p>但这位作者实在是在腾讯的游戏领域挑不出几个毛病了，于是开始春秋笔法了：</p><blockquote><p>对手游来说，玩家成长速度消耗速度都很快，流量转化的难度在逐渐变大。最初用户没得玩，腾讯推什么用户就玩什么，比如天天系列的大众休闲游戏，靠微信和应用宝导量就能轻易横扫市场；再后来用户的需求更深度，腾讯就推一些好的游戏， 比如王者荣耀和飞车炫舞，靠的也还是端游 IP 和端游玩法的移植；到如今，用户更垂直，审美更多元，玩家对游戏的需求更多样化个性化，对于《恋与制作人》、《旅行青蛙》这样的针对特定人群的特色游戏，腾讯一时有些使不上力气。</p></blockquote><p>这段文字，光前面的论述，就有一种“虽然你很牛逼，但是你没什么了不起，不过是你走运罢了”的酸臭感，最后看到“腾讯一时有些使不上力气”这句话的时候，我甚至差点笑出声，看来作者实在是觉得，光是靠以偏概全的两个游戏《恋与制作人》，《旅行青蛙》（居然这个也被作者拿来凑数，心疼旅行青蛙），确实难以得出腾讯游戏药丸的结论，所以就语焉不详的写了这句话……</p><p>还有，作者在文中对于腾讯做信息流败给今日头条这件事，着墨很多，想通过腾讯这样的失败证明腾讯没有梦想。<strong>这也犯了以偏概全的错误。</strong></p><p>每个公司都有成功的产品，也有失败的产品，和小公司不同，对于大公司来讲，个别产品的失败其实并不重要，他们拥有很多试错的机会，只要十个产品里面能成一个，那就算是巨大的成功了。</p><p>且不论腾讯除了信息流之外还有多少成功的产品，就算只比信息流，也完全得不出“腾讯没有梦想”来，因为，做信息流和短视频最成功的就只有今日头条+旗下的抖音了，快手也算一个，那么我们岂不是要说除了今日头条和快手之外所有做信息流的公司都没有梦想呢？</p><p>要知道，抖音这款 app 火了，影响最大的可是微博，对于微信影响很小，根本就不是一个竞品，有人会因为玩抖音不上微博，没有人会因为玩抖音不聊天吧？建议作者再写几篇《新浪没有梦想》，《网易没有梦想》，《小米没有梦想》。</p><h3 id="用含混的定义来混淆逻辑"><a href="#用含混的定义来混淆逻辑" class="headerlink" title="用含混的定义来混淆逻辑"></a>用含混的定义来混淆逻辑</h3><p>我觉得人人都应该学一点数学，学完之后至少学会了用定义式思维思考问题，这样思考的话，你会发现有些概念根本就是模糊不清的，</p><p>正如汪峰经常问的问题：“你的梦想是什么？”一样，文中的作者说的“梦想”到底是个什么东西？是创新？是好口碑？还是市值增长？作者并没有给出明确的定义，这就给了作者很大的混淆空间。</p><p>那时候大家都很羡慕海外的创投环境，因为当时美国的大公司非常喜欢收购小公司，这让市场充满了新鲜的活力，而彼时的腾讯总是被喷抄袭，所以创业者都要面临一个问题：“如果你做的东西，腾讯也做了怎么办？”毫无疑问，这一定是毁灭性的。</p><p>而后来腾讯从良了，不抄了，现在开始像国外的巨头一样投资小公司了，你以为这就能挡住大神的口水攻击了吗？<strong>并不能，大神会说你没有梦想……</strong></p><p><strong>如果这样叫没有梦想，那我宁愿腾讯天天没有梦想，日日没有梦想才好。</strong></p><h3 id="总结：批评的姿势"><a href="#总结：批评的姿势" class="headerlink" title="总结：批评的姿势"></a>总结：批评的姿势</h3><p>总的来说，这篇作者在干的事情就是：</p><p><strong>以一个写自媒体的编辑的身份</strong>，以一个没有任何巨头公司的任何管理经验的身份，以一个对腾讯真正的内部战略和公司形势并不知情的身份，仅靠一篇文章，就站在一个类似于洞察者一般至高无上的角度，<strong>对一个如日中天、市值几千亿美金的大公司，对一个随便拉出一个高管，才能都远超自己的公司</strong>，各种横加批评和各种否定其战略和模式，不知道是哪里来的自信和勇气？</p><p>先操心下自己的房贷能不能还上，操心下自己儿子小学入学的问题，再来考虑一个几千亿美金市值的大公司的宏观战略部署好吧？</p><p>赚着互联网民工的钱，操着市值几千亿美金公司老总的心。</p><p>这篇文章让我想到了知乎的一个问题，当时 alphago 下围棋完胜李世石，引起世界轰动后，高晓松评论道：</p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185gxs1.jpg" alt=""><br><img src="http://c1oudust-blog.test.upcdn.net/20185gxs2.jpg" alt=""><br><img src="http://c1oudust-blog.test.upcdn.net/20185gxs3.jpg" alt=""><br></div></p><p><div align="center"><br>嗯……高晓松说alphago下棋没有美感……没有美感……</div></p><p><div align="center"><br>对此，知乎上答主@伯张的老爷写出了犀利无比的答案…..</div></p><p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20185bzdly.jpg" alt=""></div></p><p>套用在这里就是：</p><p>“那如果当真是所向披靡的公司，上市之后市值暴涨几百倍呢？”</p><p>潘乱沉吟半晌。</p><p>“那，就说他没有梦想。”</p><p><div align="left"><br>以上。</div></p><hr><p>文章转载自：<a href="http://t.cn/R3Zej8q" target="_blank" rel="external">逆鳞先生</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/20185mmexport1525840185248.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/source/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="互联网" scheme="http://yoursite.com/source/tags/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>《救赎之路》到底救赎了谁？</title>
    <link href="http://yoursite.com/blog/%E3%80%8A%E6%95%91%E8%B5%8E%E4%B9%8B%E8%B7%AF%E3%80%8B%E5%88%B0%E5%BA%95%E6%95%91%E8%B5%8E%E4%BA%86%E8%B0%81%EF%BC%9F20180429/"/>
    <id>http://yoursite.com/blog/《救赎之路》到底救赎了谁？20180429/</id>
    <published>2018-04-28T16:00:00.000Z</published>
    <updated>2020-03-16T19:17:52.483Z</updated>
    
    <content type="html"><![CDATA[<style type="text/css">img{text-align: center; margin: 0 auto;}</style><p><img src="http://c1oudust-blog.test.upcdn.net/20184sinner.jpg" alt="头图"></p><a id="more"></a><p>早些时间在 B 站看到过这个游戏的试玩视频，当时的第一反应：哎呦，不错啊，这是国产？</p><p>时至今日，当我手动通关了这个游戏之后的第一反应是这样的：</p><p><img src="http://c1oudust-blog.test.upcdn.net/20184emmmm.jpg" alt="emmm"></p><p>一言难尽。</p><p>我不会说游戏与黑魂到底有多么相似，因为一个独立游戏从质量上来说，无论是画面还是战斗都自然无法和 3A 大作相比较。</p><p>《救赎之路》砍掉了普通角色扮演游戏中的一系列流程，这可能是制作组开始游戏企划时一个比较艰难的决定。想做一款类魂游戏，但在时间和经历上不是很允许或者根本无法达到，因此只能放弃很多元素，只把游戏体验放到了魂系列的一个核心点——挑战难度极大的 boss 战上。其实这也无可厚非，只要能在 boss 战上做到比较好的效果，那它也能算是一款不错的独立游戏。</p><p>那么，《救赎之路》的 boss 战模式设计成功了吗？我的答案是：基本成功了。</p><ul><li><p>在游戏中，每个 boss 无论是形态还是攻击方式，都比较贴合其对应的那一宗罪。而其攻击方式的变化也是比较多的，大部分 boss 都有两种形态，也算是把难度提升了一大截。再来开看主角的攻击方式：主角有在游戏开始有两种武器，大剑和剑盾，剑盾攻击不高，好在比较灵敏的攻击速度，而大剑是我比较喜欢的武器，尤其是攻击到敌人后那个比较明显的停顿，有种刀刀入骨感觉，从战斗的手感来说已经是比较优秀了。</p></li><li><p>boss 所在的场景是游戏中一个比较出彩的地方，得益于强大的虚幻 4 引擎的表现和制作组用心的设计，每个场景都十分有特色。个人比较喜欢色欲和傲慢以及暴怒所在的场景。</p></li></ul><p>就色欲而言，茭白的月光倒映在镜面般的湖泊中，加上四周生长的银色藤蔓，整个场景有种静谧诡异的魔法气息。</p><p><img src="http://c1oudust-blog.test.upcdn.net/20184Lust.png" alt="露纳之湖" title="露纳之湖"></p><p>而傲慢所在的场景，周围的断垣残壁与高高的石柱，和身材高大的 boss 交相呼应，则显得十分壮阔大气。</p><p><img src="http://c1oudust-blog.test.upcdn.net/20184Pride.png" alt="失落荣耀竞技场" title="失落荣耀竞技场"></p><p>同样，在充满熔岩的火焰长廊尽头，身材巨大的暴怒从岩浆中缓缓出现，给人以一种压抑与兴奋并存的感觉。</p><p><img src="http://c1oudust-blog.test.upcdn.net/20184Wrath.png" alt="折磨深渊" title="折磨深渊"></p><ul><li>游戏独特的创新处 —— Level-Down 系统。每挑战一个 boss 时，主角都会进行献祭，根据所挑战 boss 的不同，主角被减弱的能力就各有不同，这是体现游戏难度的另一个要素。而哟西本身并没有规定打 boss 的顺序，这样玩家就能自行选择，并在能力削弱上达成比较合理的安排。但这个设计在影响游戏难度上的变化不够明显。游戏是难，但只能说是个别 boss 难，而不是越来越难，因为对于一个“抖 M”玩家来说，通常只要摸清 boss 的攻击模式，击败 boss 就是套路级别的事了。而被削弱的各项能力，对于击败 boss 来说影响也不是很大，因此个人认为，Level-Down 系统的设计虽然新颖，但创新力度还是不够。</li></ul><p>以上是《救赎之路》的一些优点，而游戏本身还是有一些瑕疵的，不过它们并不是很影响游戏本身的体验：</p><ul><li><p>BGM 的缺乏。音效部分可以说是《救赎之路》最大的短板之一，无论是攻击，行走，还是背景音乐，在游戏中都没有过多的表现。背景音乐？不存在的，貌似嫉妒的场景是有 BGM 的==，当然一个独立游戏制作组想要请专业的团队制作配乐，毫无疑问代价太大了，所以 bgm 的缺乏完全能够理解。</p></li><li><p>未锁定 boss 时的镜头依然不能自由转动视角，也就是所谓的锁镜头方式。不过好在游戏只有 boss，因此个人倒是没有什么可吐槽的，如果是一个杂兵多而场景大的游戏，用锁镜头那真是要狠狠地吐槽一顿了。</p></li><li><p>弹反的时机把控要十分精准才能完成，这个机制的设计基本都是聊胜于无了，个人感觉，因为有了翻滚，用到弹反的地方还是很少的。喜欢弹反的朋友可以试试能否弹反 boss 的攻击。</p></li><li><p>武器种类并不是很多，而通关主线会给一把暴食的双剑，通关三周目又能获得一把镰刀。目前个本人也就仅仅通关了一周目，而且没有继续通关二周目和打挑战模式的想法。</p></li></ul><p>以下是一些吐槽：</p><ul><li><p>主角最后的剧情并没有看懂，意思是最后救赎了自己然后获得了王位？</p></li><li><p>总有很多人说这个游戏中 boss 的动作抄袭黑暗之魂，血缘等游戏。但其实并没有，因为游戏中大部分的动作都是虚幻 4 商城里的，这里应该手动滑稽。</p></li><li><p>这个游戏的手感个人认为是近几年国产动作游戏里不能说数一数二，也是名列前茅。和之前的《隐龙传》和《初体计划》相比也是有其优势。有些人总是拿国产小型制作组做的独立游戏跟国外的大作比，然后一顿批判，似乎这种“哀其不幸，怒其不争”的态度能让中国的单机游戏市场环境能够更好一点。如果你真心希望国产单机能够越来越好，就请不要践踏制作组的心血，如果不是和某个靠打着幌子骗玩家钱的制作组一样，大部分国产制作组还是很良心的。</p></li><li><p>另外，据说这游戏的动作捕捉都是让美术自己上去做的，制作组是真的穷。给国产点信心吧，有钱了会更好。</p></li></ul><p><strong>总之，《救赎之路》算是一款比较不错的独立游戏，如果你喜欢类魂游戏高难度的 boss 战或者对国产动作游戏比较感兴趣，那你大可以去尝试一下这部作品。如果你喜欢精巧的构思和值得思索的剧情，那这款游戏并不适合你。</strong></p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;style type=&quot;text/css&quot;&gt;
img{text-align: center; margin: 0 auto;}
&lt;/style&gt;

&lt;p&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/20184sinner.jpg&quot; alt=&quot;头图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="测评" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%84/"/>
    
    
      <category term="游戏" scheme="http://yoursite.com/source/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>不太“硬核”的硬核动作游戏 —— 《隐龙传隐踪》</title>
    <link href="http://yoursite.com/blog/%E4%B8%8D%E5%A4%AA%E2%80%9C%E7%A1%AC%E6%A0%B8%E2%80%9D%E7%9A%84%E7%A1%AC%E6%A0%B8%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F%20%E2%80%94%E2%80%94%20%E3%80%8A%E9%9A%90%E9%BE%99%E4%BC%A0%E9%9A%90%E8%B8%AA%E3%80%8B20180407/"/>
    <id>http://yoursite.com/blog/不太“硬核”的硬核动作游戏 —— 《隐龙传隐踪》20180407/</id>
    <published>2018-04-06T16:00:00.000Z</published>
    <updated>2020-03-16T19:23:29.907Z</updated>
    
    <content type="html"><![CDATA[<style type="text/css">img{text-align: center; margin: 0 auto;}</style><p><img src="http://c1oudust-blog.test.upcdn.net/20184hidden dragon.jpg" alt="头图"></p><a id="more"></a><p>之前听说在 CJ 上火的不得了的游戏，无奈因为在通关另一款游戏而搁置了，现在刚好遇到清明假期，就挤出时间玩一下。</p><h3 id="画面"><a href="#画面" class="headerlink" title="画面"></a>画面</h3><p>首先值得肯定的是《隐龙传》使用了三渲二技术，画面比起普通的 2D 格斗上了一个档次，特效做起来也十分炫目。</p><p><img src="http://c1oudust-blog.test.upcdn.net/20184The cell.jpg" alt="游戏开始时的牢房，可以看到地下狱卒的尸体"></p><p><img src="http://c1oudust-blog.test.upcdn.net/20184LUO YANG.jpg" alt="洛阳城"></p><p><img src="http://c1oudust-blog.test.upcdn.net/20184Bamboo Grove.jpg" alt="竹林"></p><p><img src="http://c1oudust-blog.test.upcdn.net/20184Organs castle.jpg" alt="机关城，可以看到不是很精细的贴图，但场景设计的还不错"></p><p><img src="http://c1oudust-blog.test.upcdn.net/20184The hidden city.jpg" alt="隐城山道"></p><p>从开局的牢房，到后来的洛阳城，竹林，机关城，隐城，每个场景的建模都很有古风场景的特色，除了竹林，其他场景均以暗色调为主。游戏建模方面给人感觉略显粗糙，主要是贴图不够精细，而场景的亮度又偏暗导致的。这点倒是可以理解，毕竟只是独立游戏，本人也对独立游戏的画面精美性没有硬性要求。个人比较喜欢的是游戏中介绍世界观时出现的水墨画场景，很有感觉。<br><img src="http://c1oudust-blog.test.upcdn.net/20184Ink.jpg" alt="水墨"></p><h3 id="游戏性"><a href="#游戏性" class="headerlink" title="游戏性"></a>游戏性</h3><p>横版动作游戏中一气呵成的打斗连招是最判断一个动作游戏操作性的重要标准。《隐龙传》的上手难度并不算高，通过轻重攻击能打出很华丽的连招，但连招的动作却给人一种很僵硬的感觉，尤其是以重攻击开头的连招能看到很明显的停顿。游戏可以在地上可以释放的连招只有寥寥几套，而敌人的血量又通常偏高，在玩家反复使用这几套连招而丧失新鲜感后，就只会觉得疲惫和乏味。</p><p><img src="http://c1oudust-blog.test.upcdn.net/20184combo.jpg" alt="动作"></p><p>游戏一共有两种武器 —— 剑和飞刀（钩爪是辅助用的不能算是武器）。在前期伤害不高，几乎没有用飞刀，在后期就成了消耗神器，所以一定要点满飞刀的技能。游戏中一个比较独特，也可以说是弊病的设计 —— 霸体系统，在霸体状态下的人物无法被打断出招和产生僵直。</p><p><img src="http://c1oudust-blog.test.upcdn.net/20184bati.jpg" alt="武器"></p><p>游戏后几章的绝大多数精英小兵和 boss 都有霸体状态，这给游戏增加了不少难度。由于无法打断技能，因此没有霸体的你只有规避他而不能用技能打断其出招。在后期，你的连招很有可能没有放完就被霸体的敌人打出僵直，这就会让玩家感到更加烦躁，很难获得动作游戏的爽快感。另外，由于这个十分不友好的设定，游戏要无伤通关基本是不可能的，这些设定完全违背了作为一个动作游戏的本质。</p><p><img src="http://c1oudust-blog.test.upcdn.net/20184combo_2.jpg" alt="霸体"></p><p>游戏的闪避系统需要消耗体力，没有装备特殊心法只能一次性闪避三次，同时等待体力恢复。而闪避系统的收益 —— 防反，虽然炫酷，但实则有点鸡肋，还不如击飞敌人或使敌人僵直来得实在。</p><p>游戏中有几个需要解密的场景，解密不难，却略显枯燥，比如机关城中的五行石盘。在主角前往机关城的路中有一段需要跑酷的场景，几段需要精确把握跳跃时机的路和周围爆炸傀儡的追赶，成为了游戏中最具有难度的一关（居然比 boss 战都难，有没有搞错）。而失败几次后你就会看到制作组充满恶意的嘲讽 —— 弹幕护体!游戏中像这样的跳跃关卡还有很多，在拿到了钩爪后这些关卡就变成了纯粹的背板。</p><p><img src="http://c1oudust-blog.test.upcdn.net/20184parkour.jpg" alt="满满的恶意"></p><p>关于游戏的收集系统。游戏中的宝箱分为两种，一种是普通的箱子，里面只有蓝魂和药，另一种就是比较“高端”一点的，里面可以拿到武器、心法还有一些特殊收集品。但游戏第一周目中第二种宝箱实在是少的可怜，而可供收集的武器和心法又那么多，所以一周目的流程无论如何都没办法收集齐所有的心法加武器，这也太坑爹了吧 OTZ，这只是一个横版动作游戏不是什么 RPG 啦！更坑爹的是这游戏居然没有存档点，自动存档大概是在小关卡的门口，剧情过后和 boss 战前。人家《艾希》好歹有个标注存档位置的机器人啊，哪怕是自动保存，这游戏却连一个已存档的提示都没有。</p><h3 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h3><p>作为一个资深游戏剧情爱好者，对这个游戏的剧情塑造极其不满。游戏的背景设定中规中矩 —— 武氏后人、渴望复仇的神秘组织“爻”，惨遭灭门的玄剑门，化身于剑中为主角指引方向的剑魂。主角作为玄剑门的最后一人，对灭门案进行探查，经过神秘人的指引，拨开重重疑云，最终完成复仇归隐山林。</p><p><img src="http://c1oudust-blog.test.upcdn.net/20184Hidden dragon_End.jpg" alt="结局是归隐山林"></p><p>这明明是一个很极其王道的江湖武侠故事，但在游戏中却丝毫没有表现力，在短短 5 6 个小时的游戏流程中，细节可谓是少之又少，过场剧情动画也是简单粗暴，这跟显得比较宏伟的开场动画相比就十分尴尬了。不说在剧情中对主角是玄剑门弟子的描写桥段甚少，就连主角的名字“陆天源”都是由 boss 叫出来才知道的。关于玄剑门灭门案可以推测出是二师兄背叛了宗门，与“爻”联合杀死了掌门，之后自己也沦为丹药的牺牲品（莫名想起奎尔萨拉斯之战）。</p><p>在主角刚开始所在的牢房中可以看到几个躺着的狱卒尸体，而一路走下去只有在牢房外才看到活着的狱卒，那么牢房中的狱卒究竟是如何死的，牢房为何空无一人，主角又是如何幸免于难，这些都未作说明。</p><p>作为指引主角的神秘人“朱红”的身世也没有详细描述。玩家只知道她是吐蕃族匠人，也是铸造龙鼎之人，用剩余材料铸成隐龙剑，以身化为剑魂以便后人报仇。</p><p><img src="http://c1oudust-blog.test.upcdn.net/2018420180405133339_1.jpg" alt="剧情"><br>后期主角找到隐城的方式也是槽点满满，杀死了暗鸦，断了线索，这里应该是由“朱红”对主角做指引，或者主角发现暗鸦房间后进行探索比较好，而游戏中仅仅是因为妹子想起了白鬼和暗鸦房间里的画，主角就找到了隐城，这段剧情实在让人摸不着头脑。这让我想起另一个江湖风横版动作游戏《雨雪》，对于剧情描述的把控比《隐龙传》不知道高到哪里去了。</p><p><img src="http://c1oudust-blog.test.upcdn.net/20184bamboo_2.jpg" alt="剧情动画中我最喜欢的一个分镜"></p><p><strong>总之，《隐龙传隐踪》是一款不太“硬核”的硬核动作游戏，如果你是一个硬核 ACT 爱好者，那可能会失望不少，如果你只是单纯喜欢武侠风或者横版卷轴式动作游戏，不太追求丰富的剧情和华丽的画面，它会是一个不错的选择。在国产独立游戏中，《隐龙传》的质量也能勉强跻身于中上水平。</strong></p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;style type=&quot;text/css&quot;&gt;
img{text-align: center; margin: 0 auto;}
&lt;/style&gt;

&lt;p&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/20184hidden dragon.jpg&quot; alt=&quot;头图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="测评" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%84/"/>
    
    
      <category term="游戏" scheme="http://yoursite.com/source/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="steam" scheme="http://yoursite.com/source/tags/steam/"/>
    
  </entry>
  
  <entry>
    <title>冰冷世界中的孤独爱恋 —— 《水形物语》与《沙耶之歌》</title>
    <link href="http://yoursite.com/blog/%E5%86%B0%E5%86%B7%E4%B8%96%E7%95%8C%E4%B8%AD%E7%9A%84%E5%AD%A4%E7%8B%AC%E7%88%B1%E6%81%8B%20%E2%80%94%E2%80%94%20%E3%80%8A%E6%B0%B4%E5%BD%A2%E7%89%A9%E8%AF%AD%E3%80%8B%E4%B8%8E%E3%80%8A%E6%B2%99%E8%80%B6%E4%B9%8B%E6%AD%8C%E3%80%8B20180322/"/>
    <id>http://yoursite.com/blog/冰冷世界中的孤独爱恋 —— 《水形物语》与《沙耶之歌》20180322/</id>
    <published>2018-03-21T16:00:00.000Z</published>
    <updated>2020-03-16T19:20:59.217Z</updated>
    
    <content type="html"><![CDATA[<style type="text/css">img{text-align: center; margin: 0 auto;}</style><p><img src="http://c1oudust-blog.test.upcdn.net/20183saya_and_water.jpg" alt="头图"></p><a id="more"></a><p>三月飞雪，恰逢雪后初晴，空气中还残留着化雪后寒意。呼出的暖气凝结在镜片上，变成淡淡薄霜，又渐渐消散。鲜有行人的街道上，苍白的路灯光透过丝丝冷风，沉浸在《水形物语》的意境中。</p><p>比起定位成奇幻爱情片，《水形物语》更是一部黑暗成人童话。除了色调和音乐上的讨喜，《水形物语》对孤独的诠释也足以成为使之获得金狮奖的原因之一。位于社会最底层的哑巴清洁工，研究所中身负枷锁的鱼人，同性恋老年落魄画家，背叛了一切的克格勃科学家 —— 无时无刻不在倾诉着这个孤独的世界。</p><p>所以，整个故事无非是孤独者的彼此救赎。</p><p>那么孤独的人聚集在一起就能摆脱孤独吗？答案当然是不能。畸形人兽恋在伦理中无法被理解，同性恋最终受到排斥，为了心中的大义所背叛一切的人最终被其大义背叛。</p><p>这点与《沙耶之歌》似乎如出一辙 —— 老虚笔下所描绘的渴望变成人类的“怪物”沙耶与厌恶世界的病态主人公郁纪的绝望爱情故事。</p><p>郁纪在车祸之后所看到的，是一个充满污秽与肮脏的世界，人类变成 “肉块” ，声音令人作呕，建筑上充满了鲜血、腐肉与不可言状之物，所及之处是破碎和混乱的风景。于是他的性格变得极端，自私，人性的黑暗完全体现在了他身上。身陷腐肉固然痛苦，然而真正使他化为恶魔的却是他自身的劣根性。后来郁纪对自己曾经朋友所犯下的恶行，很多是源于他的食欲与性欲。</p><p>但幸运的是，他遇到了同类——沙耶，一个在病态的郁纪眼里以少女形态出现的生物，在郁纪被视为异端，孤立无援之时出现的一盏灯。沙耶为郁纪的接纳而开心，郁纪为这个柔软美好的存在而稍微从孤独中挣脱出来了。沙耶就是“人”这个符号的象征 —— 被发现吃人肉时的惊恐，不想被郁纪知道真身的自卑，对瑶进行改造后的喜悦，这都是人类所具有的情感与性格。</p><p>“无论形态如何，那灵魂的形状是与我们所接近的。”</p><p>《水形物语》中主人公的生活环境虽然不如《沙耶之歌》中的那么恶劣与极端，但依然在强烈体现着孤独。</p><p>故事的大背景发生在冷战时期的美国，剧院上的小隔间以及工作所在研究所，是哑女千篇一律生活的起点与终点。</p><p>哑女是孤独的 —— 生活简单的千篇一律，唯一的乐趣是在浴缸里自慰。无法说话，自然不能表达出自己的情感，只有用狠狠的砸墙来表达其极度想要拯救男主的心情。</p><p>老年画家是孤独的 —— 同性恋，画作从未被接受，始终与猫为伴。</p><p>鱼人是孤独的 —— 被南美土著奉为神灵却在研究所遭受折磨。它是所有人的玩物，更是女主收养的美丽的宠物。</p><p>苏联科学家是孤独的 —— 不被美国人信任，不被自己人信任，甚至自己的名字 “迪米特里” 也是一个不能说出口的秘密。他是影片中唯一一个三观正常的人，却也是第一个死掉的人。</p><p>连大反派也是孤独的 —— 在家庭与工作中，都格格不入，只有通过虐待男主来发泄心中的郁闷。</p><p>他们的孤独，不被也无法被人理解，以至于通过相互依赖才能缓解独自存活的痛苦。在现实生活中越是难以被人理解、心灵和精神越孤独的人，越想要在幻想中创造一个这样能完全理解、完全接受自己的灵魂。孤独之人所在的世界是冰冷的，唯一能抵御冰冷孤独世界的东西，只有爱 —— 畸形的爱。而就好像人类离不开食物一样，当这种爱变成赖以生存的食粮，一种病态而美丽的安全感就会滋生其中 —— 像毒品使人沦陷。</p><p>《水形物语》中，鱼人与哑女最终突破了囚禁他们的冰冷牢笼，哑女脖颈间的神秘伤疤化为腮，与鱼人重获新生。在《沙耶之歌》中，爱仍旧是存在的。一个结局里，身处绝境濒临死亡两“人”仍然艰难地接近彼此，想要在生命最后留住对方的体温，而另一个结局里，沙耶结束了自己的生命，孕育出了无数“孢子”，为郁纪创造了一个美丽的新世界。他们的确相爱着，即使曾经自私冷酷，但在这一秒，心脏只为对方悸动，灵魂也只为对方无私。</p><p><img src="http://c1oudust-blog.test.upcdn.net/20183songofsaya.jpg" alt="沙耶之歌"></p><p><img src="http://c1oudust-blog.test.upcdn.net/20183water.jpeg" alt="水形物语"></p><p>这就是世界。没有纯粹的善恶，也不像英雄电影那种非黑即白。而我们是人类，始终贪婪丑陋自私，也始终追求着能令自己变得无私美好的迷失。每个人都是孤独的个体，在漫漫时间长河中，能遇到一个自己所爱的事物，即使相隔深渊，也依然要去追寻吧。<br>　　以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;style type=&quot;text/css&quot;&gt;
img{text-align: center; margin: 0 auto;}
&lt;/style&gt;

&lt;p&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/20183saya_and_water.jpg&quot; alt=&quot;头图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="游戏" scheme="http://yoursite.com/source/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="电影" scheme="http://yoursite.com/source/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>关于自学计算机专业课程的一点体会</title>
    <link href="http://yoursite.com/blog/%E5%85%B3%E4%BA%8E%E8%87%AA%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E7%9A%84%E4%B8%80%E7%82%B9%E4%BD%93%E4%BC%9A20180226/"/>
    <id>http://yoursite.com/blog/关于自学计算机专业课程的一点体会20180226/</id>
    <published>2018-02-25T16:00:00.000Z</published>
    <updated>2018-11-03T05:25:33.284Z</updated>
    
    <content type="html"><![CDATA[<p><div align="center"><br><img src="http://c1oudust-blog.test.upcdn.net/20182Bangalore_India_Tech_books_for_sale_small.jpg" alt=""><br><a id="more"></a></div></p><blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2></blockquote><p>作为一个计算机专业的大学生，深感学校课堂试教育的局限性，从而在大学中的许多课程基本都靠自学。因此对自学计算机专业的课程做以总结。</p><p>其实在实际开发中，并不能完全用到那些枯燥抽象的计算机专业课。所以为什么还要去学它们呢？原因只有一个，让你在计算机行业能有更长远的发展，以防止程序员只能吃青春饭的现象。这些专业理论课就如同武侠小说中的内功，而编程语言框架等则都属于外功招式。试想，一个徒有花拳绣腿的人怎么可能与一个拥有深厚内功的人抗衡呢。</p><p>经过对比，可以发现各个大学计算机专业的核心课程高度一致，这是国际计算机学会 ACM(Association for Computing Machinery) 和 IEEE-CS 联合工作组发布的 CS2013(计算机科学课程指南 2013) 报告，提出的计算机科学知识体的概念。该报告给出的关于计算机科学的十八个知识领域如下：</p><div align="center"><table><thead><tr><th style="text-align:center">缩写</th><th style="text-align:left">英文</th><th style="text-align:left">中文</th></tr></thead><tbody><tr><td style="text-align:center">AL</td><td style="text-align:left">Algorithms and Complexity</td><td style="text-align:left">《算法与复杂度》</td></tr><tr><td style="text-align:center">AR</td><td style="text-align:left">Architecture and Organization</td><td style="text-align:left">《计算机结构体系与组织》</td></tr><tr><td style="text-align:center">CN</td><td style="text-align:left">Computational Science</td><td style="text-align:left">《计算科学》</td></tr><tr><td style="text-align:center">DS</td><td style="text-align:left">Discrete Structures</td><td style="text-align:left">《离散数学》</td></tr><tr><td style="text-align:center">GV</td><td style="text-align:left">Graphics and Visualization</td><td style="text-align:left">《图形与可视化》</td></tr><tr><td style="text-align:center">HCI</td><td style="text-align:left">Human-Computer Interaction</td><td style="text-align:left">《人机交互》</td></tr><tr><td style="text-align:center">IAS</td><td style="text-align:left">Information Assurance and Security</td><td style="text-align:left">《信息保障与安全》</td></tr><tr><td style="text-align:center">IM</td><td style="text-align:left">Information Management</td><td style="text-align:left">《信息管理》</td></tr><tr><td style="text-align:center">IS</td><td style="text-align:left">Intelligent Systems</td><td style="text-align:left">《智能系统》</td></tr><tr><td style="text-align:center">NC</td><td style="text-align:left">Networking and Communications</td><td style="text-align:left">《网络与通讯》</td></tr><tr><td style="text-align:center">OS</td><td style="text-align:left">Operating Systems</td><td style="text-align:left">《操作系统》</td></tr><tr><td style="text-align:center">PBD</td><td style="text-align:left">Platform-based Development</td><td style="text-align:left">《基于平台的开发》</td></tr><tr><td style="text-align:center">PD</td><td style="text-align:left">Parallel and Distributed Computing</td><td style="text-align:left">《并行与分布式计算》</td></tr><tr><td style="text-align:center">PL</td><td style="text-align:left">Programming Languages</td><td style="text-align:left">《程序设计语言》</td></tr><tr><td style="text-align:center">SDF</td><td style="text-align:left">Software Development Fundamentals</td><td style="text-align:left">《软件开发基本原理》</td></tr><tr><td style="text-align:center">SE</td><td style="text-align:left">Software Engineering</td><td style="text-align:left">《软件工程》</td></tr><tr><td style="text-align:center">SF</td><td style="text-align:left">Systems Fundamentals</td><td style="text-align:left">《系统基本原理》</td></tr><tr><td style="text-align:center">SP</td><td style="text-align:left">Social Issues and Professional Practice</td><td style="text-align:left">《社会问题与专业实践》</td></tr></tbody></table><div align="left"><p>而 ACM 又将对这些知识的掌握程度分为以下三级：</p><ul><li><p>Familiarity: What do you know about this? 理解一个概念是什么或意味着什么。</p></li><li><p>Usage: What do you know how to do? 能够以具体的方式使用或应用概念。例如，在程序中适当地使用特定的概念，使用特定的证明技术，或执行特定的分析。</p></li><li><p>Assessment: Why would you do that? 能够从多角度考虑一个概念和/或为解决某个特定问题选择特定的方法。这种程度的掌握涉及到从能够解决问题的所有方案中中选择最适合的方法的能力。</p></li></ul><p>那么在业余时间自学计算机专业课程是否可能？完全可以！计算机专业是人类历史上第一个可以在互联网上学到到几乎所有专业知识的专业，在互联网，可以听到从本科到研究生层次，从国内重点大学到国外知名高校的几乎所有的课程，除了一些硬件课程需要必备的设备之外，其他课程只需要一台能上网的电脑就完全足够了。</p><blockquote><h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2></blockquote><p><img src="http://oyq24xmaa.bkt.clouddn.com/20182学习路线.png" alt="学习路线"></p><ul><li><p>首先需要对计算机科学和计算机产业进行总体的认识，可以通过阅读计算机导论有关的书籍进行了解。</p></li><li><p>在对计算机概论有一个比较全面的了解后，我们最先需要的就是掌握一门编程语言，同时学好数学。在大学的计算机专业中，这两部分往往安排在大一至大二。</p><p>关于初学者第一门编程语言，比较常见的有这几种：</p><ul><li><strong>C</strong>：国内大多高校所普遍使用的入门语言。</li><li><strong>JAVA/C#</strong>：两者都是很典型的面向对象的编程语言，后期的课程如数据结构与算法也有不少学校使用其作为范例编程语言。 JAVA 有很多非常活跃的开源社区与数不尽的开发者为其提供代码以供学习。而 C# 的背后则是 IT 巨头微软，并且 C# 的语法糖被很多新生语言所借鉴，如 Google 现今的官方开发语言 kotlin。</li><li><strong>Python</strong>：典型的动态语言，国内一部门高校所选用的新兴入门语言，应用极为广泛。尤其是现今的大数据与人工智能时代，更加离不开 Python。</li></ul></li></ul><p>这些编程语言的均可以通过书籍与视频结合的学习方法。关于学习的书籍和视频网上已经有很多了，这里就不做赘述。</p><p>计算机专业必须掌握的四门数学课程，包括高等数学、离散数学、线性代数、概率论与数理统计。为什么要学数学？因为具备基本的数学能力是对所有计算机专业人员的基本要求。在实际开发项目中，对程序员的数学功底要求其实并不高，很多框架的底层都有强大的算法作为支撑，但初级程序员并不需要完全理解这些算法。对于初级程序员来说，仅仅需要有高中的数学基础加上一些数据结构的知识就行了。但对于中高级程序员来说，则必须基本良好的数学功底，尤其是需要使用一些特定技术进行开发，建模或者设计相关算法，例如现今比较流行的人工智能，它的实现就需要强大的 AI 算法——这意味的技术水平的提高，学习领域的深入，所需要的数学功底也是逐渐提高的。</p><p>本人以前觉得只要掌握大学中所学的数学就足够了，然而在深入学习中却发现大学中所学的数学基础课程还远远不够用于开发，例如我在学习 unity 的过程中，经常碰到三维向量，欧拉角与四元数等等，为了理解这些东西，我重新回过头来学习了一遍计算机图形学中的 3D 数学。</p><p>国内的大部分数学教材，往往只讲相关的法则定理证明等等理论知识，而不会涉及到其发展历史和具体应用，不强调解决特定问题的思路，文字枯燥，并不适合自学。还有些教材往往写的过于简练，比如经常出现“由此可见”，“由此可得”等词语，本人在自学的过程中对这些词眼极为头疼，于是便放弃了使用国内的教材。</p><p>这里可以参考知乎上@周筠 的回答：<a href="https://www.zhihu.com/question/26761596/answer/36428134" target="_blank" rel="external">计算机系的高数，离散，线代都是用在哪些方面的？ - 周筠的回答 - 知乎</a>，讲的很不错。</p><ul><li><p>在掌握了编程语言与数学基础后，就可以进入专业基础课和一些使用技术的学习。各个学校的计算机专业基础课都大同小异，总数有十多门。但最重要的就是以下四门科目，也是计算机专业学生的考研科目——数据结构与算法、计算机组成原理、操作系统、计算机网络。同样采用视频与教材结合的方式。</p><ul><li><strong>数据结构与算法</strong>：参考书籍：机械工业出版社的 <a href="https://book.douban.com/subject/26696971/" target="_blank" rel="external">《算法基础 打开算法之门》</a>和<a href="https://book.douban.com/subject/20432061/" target="_blank" rel="external">《算法导论》</a></li></ul><p>公开课：<br><a href="http://t.cn/REb4byh" target="_blank" rel="external">麻省理工学院公开课：算法导论</a></p><p><a href="http://t.cn/R006U7j" target="_blank" rel="external">Data Structures • 数据结构</a></p><ul><li><strong>计算机组成原理</strong>：这门课可以用两个字概括——抽象。对于在校大学生，我们不需要(也不可能)完整的理解它，因此可以把它和操作系统这门课结合起来学习。<br>参考书籍：人民邮电出版社的<a href="http://book.douban.com/subject/1886058/" target="_blank" rel="external">《计算机组成：结构化方法》</a></li></ul><p>公开课：<br><a href="http://t.cn/REbGSJL" target="_blank" rel="external">计算机组成原理</a></p><ul><li><strong>操作系统</strong>：</li></ul><p>参考书籍：中国电力出版社的<a href="https://book.douban.com/subject/1230413/" target="_blank" rel="external">《深入理解计算机系统》</a></p><p>公开课：<br><a href="http://t.cn/R5A810s" target="_blank" rel="external">浙江大学操作系统 38 讲</a></p><p><a href="http://t.cn/REb5TGW" target="_blank" rel="external">操作系统原理</a></p><ul><li><strong>计算机网络</strong>：这门课应该从上层往下层学习，而且需要通过实验以加深理解。</li></ul><p>参考书籍：<a href="https://book.douban.com/subject/21267825/" target="_blank" rel="external">《计算机网络教程：自顶向下方法》</a></p><p>公开课：<br>哈工大的 <a href="http://t.cn/R8wibet" target="_blank" rel="external">计算机网络</a></p><p><a href="http://t.cn/REbcou4" target="_blank" rel="external">计算机网络基础</a></p><p>作为大学生，以上科目可以先完整的看一遍教学视频，配合参考书籍和学校的教程进一步学习，重点还是在学习的过程中多去实践。在学习理论科目的同时，我们可以学习一些相关的实用技术，如各种流行的开发框架和工具等来加深理解。</p></li></ul><ul><li>在完成了以上学习后，就进入了一个新的自学阶段，这一阶段的学习就可以针对你感兴趣的特定领域进行了解和学习。比如人工智能，物联网，大数据，web 开发，游戏开发等等。这一阶段的学习目的非常明确，就是培养特定领域的专业编程技能，从而能够选择进入相关领域继续研究(考研考博)或者进入参加。</li></ul><p>最重要的一点是：你需要打好扎实的基础。其实在很多大公司眼里，新人只是一张能够吸墨的白纸，你的基础扎实程度就代表你能够吸收多少墨汁。所以在大学期间，不要过分追求项目经验。但这并不代表着你不需要对所学的知识加以实践，只是相比“怎么做”，你更加需要明白“为什么”。</p><blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2></blockquote><p>上面的课程有些我已经学完了，而有些还在学习过程中。<br>我喜欢去总结我所经历的事物，即使人生发生的种种只是过眼云烟，但我还是希望一些有意义的事能永远留下。</p><p>以上。</p><blockquote><p>参考：</p></blockquote><p><a href="http://ai.stanford.edu/users/sahami/CS2013/" target="_blank" rel="external"><em>Computer Science Curricula 2013</em></a></p><p><a href="http://t.cn/REbVxPz" target="_blank" rel="external"><em>计算机专业如何自学好以及职业规划？</em></a></p></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://c1oudust-blog.test.upcdn.net/20182Bangalore_India_Tech_books_for_sale_small.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="http://yoursite.com/source/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
