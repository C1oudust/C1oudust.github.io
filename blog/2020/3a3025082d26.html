<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><title>Vedfolnir</title><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=1.0.0"><script>var CONFIG = {
  theme: {"images":"images","js":"js","css":"css","post":{"excerpt":false,"tags":true,"tags_icon":"fa-solid fa-hashtag"},"post_meta":{"created":{"enable":true,"icon":false},"updated":{"enable":false,"icon":false},"reading_time":{"enable":true,"icon":false},"word_count":{"enable":false,"icon":false}},"icon":{"paginator_prev":"fa-solid fa-chevron-left","paginator_next":"fa-solid fa-chevron-right"},"logo":null,"header":{"fixed":true,"blur":true},"menu":{"home":"/ || fas fa-home"},"menu_settings":{"icon_only":false,"text_only":true},"back2top":{"enable":true,"icon":"fa-solid fa-arrow-up"},"footer":{"copyright":{"enable":true,"start":2017,"end":null,"author":"C1oudust"},"beian":{"enable":true,"text":"冀ICP备 - 19035656号"},"powered":{"enable":true}},"dark_mode":{"enable":true,"default":"dark"},"layout":{"content":"768px","sidebar":"300px","content_sidebar_gap":"30px","main_padding":{"default":"20px","tablet":"15px","mobile":"10px"}},"pjax":{"enable":true,"avoid_banner":false,"elements":null,"selectors":null,"switches":null,"switchesOptions":null,"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0}},
};
var Util = window.Util || {};
window.CONFIG = CONFIG;</script><script>function getDarkMode() {
  var darkMode = false;
  try {
    if (localStorage.getItem('dark') == '1') {
      darkMode = true;
    }
    else if(!localStorage.getItem('dark')){
      if (!localStorage.getItem('dark') && CONFIG.theme.dark_mode.default == 'dark'){
        darkMode = true;
      }
      if (window.matchMedia('(prefers-color-scheme: dark)').matches){
        darkMode = true;
      }
    }
  } catch (err) {
    /* empty */
    console.log('err',err)
  }
  return darkMode;
}

if (getDarkMode()) {
  document.querySelector('html').classList = 'dark';
}</script><meta name="generator" content="Hexo 6.3.0"></head><body><header class="header"><nav class="nav"><div class="spacer"></div><div class="menu"><a class="menu-item" href="/" title="首页"><span class="menu-item__text">首页</span></a><div class="dark-mode"><a><svg xmlns="http://www.w3.org/2000/svg" class="mode-button-moon" viewBox="0 0 24 24" width="1.2em" height="1.2em" style="vertical-align: sub;display:none"><path fill="currentColor" d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12S6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938A7.999 7.999 0 0 0 4 12z"></path></svg></a><a><svg xmlns="http://www.w3.org/2000/svg" class="mode-button-sun" viewBox="0 0 24 24" width="1.2em" height="1.2em" style="vertical-align: sub;display:none"><path fill="currentColor" d="M12 18a6 6 0 1 1 0-12a6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8a4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636L5.636 7.05L3.515 4.93zM16.95 18.364l1.414-1.414l2.121 2.121l-1.414 1.414l-2.121-2.121zm2.121-14.85l1.414 1.415l-2.121 2.121l-1.414-1.414l2.121-2.121zM5.636 16.95l1.414 1.414l-2.121 2.121l-1.414-1.414l2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"></path></svg></a></div></div></nav></header><main class="main"><div id="is-post"></div><div class="post-header"><h1 class="post-title slide-enter-50">JavaScript之闭包的理解</h1><div class="post-meta slide-enter-50"><span class="item-meta--createtime">03-16</span><span class="item-meta--readtime">· 4分钟</span></div></div><article><div class="content slide-enter-content">
        <h2 id=""   >
          <a href="#什么是闭包（Closure）" class="header-anchor" aria-hidden="true">#</a>
          <div style="position:relative;top:-6rem" id="什么是闭包（Closure）"></div>
          <a href="#什么是闭包（Closure）" class="headerlink" title="什么是闭包（Closure）"></a>什么是闭包（Closure）
        </h2>
      <span id="more"></span>

<p>在《JavaScript高级程序设计》里，有以下定义：</p>
<blockquote>
<p>闭包指有权访问另一个函数作用域中变量的函数。</p>
</blockquote>
<p>首先来看下列代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> local = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">        local++;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>( local );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = <span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">func</span>();</span><br></pre></td></tr></table></figure>

<p>在这个例子中，函数 <code>bar()</code> 的词法作用域能够访问 <code>foo()</code> 的内部作用域。然后我们将 <code>bar()</code> 函数本身当作一个值类型进行传递。<br>在 <code>foo()</code>执行后，其返回值（也就是内部的 <code>bar()</code> 函数）赋值给变量 <code>func</code> 并调用 <code>func()</code>，实际上只是通过不同的标识符引用调用了内部的函数 <code>bar()</code>。<br>显然<code>bar()</code>会被正常执行。更进一步地说，它是在自己定义的词法作用域以外的地方执行。</p>
<p>在 JavaScript 中，因为有垃圾回收器的存在，因此在一个函数被执行后，如果检测到他的内容在之后不会再被使用，那么引擎会考虑对其进行回收。(对于 JavaScript 的垃圾回收，可以参考<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015641168">这篇文章</a>)</p>
<p>然而在这个例子中，<code>foo()</code>被执行后，事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？是 <code>bar()</code> 本身在使用。</p>
<p>拜 <code>bar()</code> 所声明的位置所赐，它拥有涵盖 <code>foo()</code> 内部作用域的闭包，使得该作用域能够一直存活，以供 <code>bar()</code> 在之后任何时间进行引用。</p>
<p>换句话说，<code>bar()</code> 持有对该作用域的引用，而这个引用就叫作闭包。</p>
<p>因此，在几微秒之后变量 <code>func</code> 被实际调用，不出意料它可以访问定义时的词法作用域，因此它也可以如预期般访问局部变量 <code>local</code> 。</p>
<p>这几行代码可能过于复杂，我们可以把它精简成这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> local = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( local );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这三行代码中，<code>bar</code> 可以访问到 <code>local</code> 变量，这就是一个闭包。诚然如此，但我们通常会把这三行代码放在一个函数里。为什么呢？这就涉及到闭包的作用了。</p>

        <h2 id=""   >
          <a href="#闭包的作用" class="header-anchor" aria-hidden="true">#</a>
          <div style="position:relative;top:-6rem" id="闭包的作用"></div>
          <a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用
        </h2>
      <p>闭包通常用来间接访问一个变量。也就是说，可以隐藏一个变量使它不能被直接访问。</p>
<p>要想达到这个效果，就可以把这个变量放在一个作用域内，然后单独创建一个对他进行控制的函数，这样我们就只能通过这个函数去访问它。</p>
<p>这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。</p>
<p>无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用<br>域的引用，无论在何处执行这个函数都会使用闭包。</p>

        <h2 id=""   >
          <a href="#一些理解" class="header-anchor" aria-hidden="true">#</a>
          <div style="position:relative;top:-6rem" id="一些理解"></div>
          <a href="#一些理解" class="headerlink" title="一些理解"></a>一些理解
        </h2>
      <p>无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一级的值类型并到处传递，就会产生闭包。</p>
<p>在<code>定时器</code>、<code>事件监听器</code>、<code>Ajax 请求</code>、<code>跨窗口通信</code>、<code>Web Workers</code> 或者任何其他的异步或者同步任务中，只要使用了回调函数，实际上也是在使用闭包。</p>
<p>比如下列代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下，我们对这段代码行为的预期是依次输出数字 1~5，每秒一次输出一个。但实际上，这段代码在运行时会以每秒一次的频率输出五次 6。</p>
<p>事实上，当定时器运行时即使每个迭代中执行的是 <code>setTimeout(.., 0)</code>，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个 6 出来。</p>
<p>但是根据作用域的工作原理，尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 <code>i</code>。也就是说，所有函数都共享一个 <code>i</code> 的引用。</p>
<p>而这个循环的终止条件是 <code>i &gt; 5</code>。条件首次成立时 <code>i</code> 的值是 6。因此，输出显示的是循环结束时 <code>i</code> 的最终值。</p>
<p>那么怎么解决呢？</p>
<p>我们可以使用 <code>IIFE</code> (Immediately Invoked Function Expression)即立即调用函数来对 <code>i</code> 创建一个单独的作用域，并使用另一个变量 <code>j</code> 在每次迭代中存放 <code>i</code> 的值，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> j = i;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(j);</span><br><span class="line">    &#125;, j * <span class="number">1000</span>);</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样代码就能按照预期输出 1~5 了。</p>
</div></article><div class="post-footer"><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fa-solid fa-hashtag"></i></span><a class="post-tags-item__link" href="https://c1oudust.cn/tags/%E5%89%8D%E7%AB%AF/">前端</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fa-solid fa-hashtag"></i></span><a class="post-tags-item__link" href="https://c1oudust.cn/tags/JavaScript/">JavaScript</a></span></div><nav class="post-paginator paginator"><div class="paginator-inner"><a class="paginator-prev prev extend" href="/blog/2020/cffcba4f3bd9.html" title="JavaScript之阻止冒泡和取消默认事件"><i class="fa-solid fa-chevron-left"></i></a><a class="paginator-next next extend" href="/blog/2020/4a0aa82965cc.html" title="markdownlint语法警告类型"><i class="fa-solid fa-chevron-right"></i></a></div></nav></div></main><footer class="footer"><div class="footer-info"><span>2017-2023 </span><div class="icon">©</div><span>C1oudust</span><span class="devider">|</span><a class="beian" target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">冀ICP备 - 19035656号</a></div><div class="footer-powered"><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><i class="back2top__icon fa-solid fa-arrow-up"></i></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title",".main",".pjax-reload"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });
    //- if (Stun.utils.pjaxReloadBoot) {
    //-   Stun.utils.pjaxReloadBoot();
    //- }
    //- if (Stun.utils.pjaxReloadScroll) {
    //-   Stun.utils.pjaxReloadScroll();
    //- }
    //- if (Stun.utils.pjaxReloadSidebar) {
    //-   Stun.utils.pjaxReloadSidebar();
    //- }
    //- Util.initHeader();

    //- }
  }, false);
}, false);</script><script src="/js/header.js?v=1.0.0"></script><script src="/js/utils.js?v=1.0.0"></script><script src="/js/scroll.js?v=1.0.0"></script><script src="/js/canvas.js?v=1.0.0"></script></body></html>